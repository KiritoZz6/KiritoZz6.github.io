<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>LeetCode刷题笔记第一期 | 🌸樱花酒吧🍻</title><meta name="keywords" content="LeetCode"><meta name="author" content="Sakura."><meta name="copyright" content="Sakura."><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="LeetCode刷题笔记第一期前言之前一直想在刷题的时候把想要记下的笔记记下来，但是没有找到很好的地方，但是现在有了博客之后就可以写在这的 写这个刷题笔记一个是想时不时回来巩固一下算法，另一个是想记录下自己的算法能力成长的过程，同时也是想为实习做准备 写这个笔记是大二暑假时期，之前也有一些算法基础，参加过的算法相关竞赛只有一次蓝桥杯，也希望能够通过刷题和做笔记能够有所长进 ✨注：我写算法的语言主打">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode刷题笔记第一期">
<meta property="og:url" content="http://sakura-pub.ltd/LeetCode/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%9C%9F/index.html">
<meta property="og:site_name" content="🌸樱花酒吧🍻">
<meta property="og:description" content="LeetCode刷题笔记第一期前言之前一直想在刷题的时候把想要记下的笔记记下来，但是没有找到很好的地方，但是现在有了博客之后就可以写在这的 写这个刷题笔记一个是想时不时回来巩固一下算法，另一个是想记录下自己的算法能力成长的过程，同时也是想为实习做准备 写这个笔记是大二暑假时期，之前也有一些算法基础，参加过的算法相关竞赛只有一次蓝桥杯，也希望能够通过刷题和做笔记能够有所长进 ✨注：我写算法的语言主打">
<meta property="og:locale">
<meta property="og:image" content="https://p6-tt.byteimg.com/origin/pgc-image/2082d6b2afed4da6a0720e50564c352d.jpg">
<meta property="article:published_time" content="2021-07-17T15:54:05.000Z">
<meta property="article:modified_time" content="2021-08-15T02:29:43.128Z">
<meta property="article:author" content="Sakura.">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p6-tt.byteimg.com/origin/pgc-image/2082d6b2afed4da6a0720e50564c352d.jpg"><link rel="shortcut icon" href="/img/0.png"><link rel="canonical" href="http://sakura-pub.ltd/LeetCode/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%9C%9F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'LeetCode刷题笔记第一期',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-08-15 10:29:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="https://sakura-pub.ltd/css/Sakura.css"><link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="🌸樱花酒吧🍻" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://p6-tt.byteimg.com/origin/pgc-image/bef029045c8e4b85a41b875bfa6aaad5.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">33</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">4</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类目录</span></a></li><li><a class="site-page child" href="/LeetCode/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%9C%9F/"><i class="fa-fw fas-archive"></i><span> LeetCode刷题笔记</span></a></li><li><a class="site-page child" href="/categories/%E8%AE%B0%E4%BA%8B/"><span> 记事</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/%E8%AE%B0%E4%BA%8B/%E5%85%B3%E4%BA%8E%E6%88%91/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://p6-tt.byteimg.com/origin/pgc-image/2082d6b2afed4da6a0720e50564c352d.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">🌸樱花酒吧🍻</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类目录</span></a></li><li><a class="site-page child" href="/LeetCode/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%9C%9F/"><i class="fa-fw fas-archive"></i><span> LeetCode刷题笔记</span></a></li><li><a class="site-page child" href="/categories/%E8%AE%B0%E4%BA%8B/"><span> 记事</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/%E8%AE%B0%E4%BA%8B/%E5%85%B3%E4%BA%8E%E6%88%91/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">LeetCode刷题笔记第一期</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-07-17T15:54:05.000Z" title="Created 2021-07-17 23:54:05">2021-07-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-08-15T02:29:43.128Z" title="Updated 2021-08-15 10:29:43">2021-08-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/">LeetCode刷题笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="LeetCode刷题笔记第一期"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">Comments:</span><a href="/LeetCode/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%9C%9F/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/LeetCode/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%9C%9F/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="LeetCode刷题笔记第一期"><a href="#LeetCode刷题笔记第一期" class="headerlink" title="LeetCode刷题笔记第一期"></a>LeetCode刷题笔记第一期</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前一直想在刷题的时候把想要记下的笔记记下来，但是没有找到很好的地方，但是现在有了博客之后就可以写在这的</p>
<p>写这个刷题笔记一个是想时不时回来巩固一下算法，另一个是想记录下自己的算法能力成长的过程，同时也是想为实习做准备</p>
<p>写这个笔记是大二暑假时期，之前也有一些算法基础，参加过的算法相关竞赛只有一次蓝桥杯，也希望能够通过刷题和做笔记能够有所长进</p>
<p>✨注：我写算法的语言主打C++</p>
<p>那么，就开始吧！</p>
<hr>
<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452.用最少数量的箭引爆气球"></a>452.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">用最少数量的箭引爆气球</a></h2><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 <code>xstart</code>，<code>xend</code>， 且满足  <code>xstart</code> ≤ x ≤ <code>xend</code>，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p>
<p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p>
<p>示例：</p>
<blockquote>
<p>输入：points = [[10,16],[2,8],[1,6],[7,12]]<br>输出：2<br>解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</p>
</blockquote>
<p>这一题拿到题目时看了好几次都看不懂题目，看了一下别人画的图才明白题的意思，和另外题 <code>435. 无重叠区间</code>有点相似</p>
<p>我们可以在每一次射击箭的时候尽量往用少一点的方向去想，当气球重叠时便一起射，这是局部最优，然后每次局部最优所造成的就是全局最优，射完全部气球所用的弓箭是最少，这便可以用贪心算法来求解</p>
<p>借用官方解答所给的图来解释</p>
<p><img src="https://p9-tt.byteimg.com/origin/pgc-image/f83bd4a2e87746078b4cac68d1f4d1d5.png"></p>
<p>当把弓箭挪到右区间最小的时候（如第三个图的蓝色）就可以一箭四雕，因为题目所给的条件<code>xstart</code> ≤ x ≤ <code>xend</code>时气球就会给射爆，这里包含了边界值条件，所以在闭区间位置也满足</p>
<p>因此我就有了基本思路，先把这些气球排列，然后从第二个气球遍历，每次与前一个气球作比较，如果两个气球区间相交，那就可以略过当前气球进入下一次比较（做个标记，代表可以在这一个弓箭射完），具体如何略过看代码；如果气球不相交了，那就证明要用多一发弓箭了，此时弓箭数要加一，然后继续往下比较</p>
<p>下面是自己参考别人解答后写出来的代码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">bool</span> <span class="token function">VecSort</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">int</span> <span class="token function">findMinArrowShots</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> points<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> size <span class="token operator">=</span> points<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>size<span class="token punctuation">)</span><span class="token comment">//数组为空</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token function">sort</span><span class="token punctuation">(</span>points<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>points<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>VecSort<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//按气球起点进行从小到大排序</span>

        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//返回结果，不为空至少需要一只箭</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token comment">//从前往后遍历气球</span>

            <span class="token keyword">if</span><span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">></span>points<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token comment">//当前气球与前一个气球不重叠</span>
                res<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
                <span class="token comment">//重叠则跳过当前气球</span>
                <span class="token comment">//（利用闭区间最右位置可以射到的规则让其长度变短，以达到可跳过的当前气球目的）</span>
                points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>std<span class="token operator">::</span><span class="token function">min</span><span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>points<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>

        <span class="token punctuation">&#125;</span>

        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这样做出来之后时间复杂度为<em>O(nlogn)<em>因为用了个快排，空间复杂度为</em>O(1)</em></p>
<img src="https://p6-tt.byteimg.com/origin/pgc-image/3af7d43845b04870bda4754ca1805c0e.jpg" alt="452.jpg" style="zoom:80%;" />

<hr>
<h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-labels/">763. 划分字母区间</a></h2><p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p>
<p>示例：</p>
<blockquote>
<p>输入：S = “ababcbacadefegdehijhklij”<br>输出：[9,7,8]<br>解释：<br>划分结果为 “ababcbaca”, “defegde”, “hijhklij”。<br>每个字母最多出现在一个片段中。<br>像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。</p>
</blockquote>
<p>这种题型第一次见，不怎么会，因为尽可能地要划分多个区域，从而达到某个或多个字母只出现在这片区域中，那么就可以先记录下每个字母最后出现的位置</p>
<p>然后再次遍历字符串，不断更新标识符<code>end</code>，该标识符指向的是当前遍历过的字母中，最持久的字符最后出现的位置，也相当于是这片区域最后的位置，所以我们只用找出这个标识符最终的位置就能够划分一个区域出来了</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">partitionLabels</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> str_size <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>str_size<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>str_size <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>res<span class="token punctuation">;</span>
        <span class="token keyword">int</span> map<span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//记录每个字母最后出现的位置</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>str_size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            map<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">int</span> start<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> end<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//记录分割数据的开头和结尾位置</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>str_size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            end <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">max</span><span class="token punctuation">(</span>end<span class="token punctuation">,</span>map<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//贪心策略地方，尽可能找到字母最后出现的位置从而划分区域</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> end<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token comment">//如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了</span>
                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>end<span class="token operator">-</span>start<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                start <span class="token operator">=</span> end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>时间复杂度<em>O(n)<em>，空间复杂度</em>O(1)</em></p>
<img src="https://p5-tt.byteimg.com/origin/pgc-image/c6d28e63caa845aba5e8479b6f016d58.jpg" alt="763.jpg" style="zoom:80%;" />

<hr>
<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="88-合并两个有序数组—（简单）"><a href="#88-合并两个有序数组—（简单）" class="headerlink" title="88. 合并两个有序数组—（简单）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-sorted-array/">88. 合并两个有序数组</a>—（简单）</h2><p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</p>
<p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。</p>
<p>示例1：</p>
<blockquote>
<p>输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br>输出：[1,2,2,3,5,6]</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入：nums1 = [1], m = 1, nums2 = [], n = 0<br>输出：[1]</p>
</blockquote>
<p>这道题是多指针中的一种题型，但是它需要的是逆向指针，知道原理后比较简单</p>
<p>因为这两个数组已经排好序，我们可以把两个指针分别放在两个数组的末尾，即 nums1 的m - 1 位和 nums2 的 n - 1 位每次将较大的那个数字复制到 nums1 的后边，然后向前移动一位。因为我们也要定位 nums1 的末尾，所以我们还需要第三个指针，以便复制。<br>在以下的代码里，我们直接利用 m 和 n 当作两个数组的指针，再额外创立一个 pos 指针，起始位置为 m + n - 1。每次向前移动 m 或 n 的时候，也要向前移动 pos。这里需要注意，如果 nums1的数字已经复制完，不要忘记把 nums2 的数字继续复制；如果 nums2 的数字已经复制完，剩余nums1 的数字不需要改变，因为它们已经被排好序。  </p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> size1 <span class="token operator">=</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> size2 <span class="token operator">=</span> nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>size2<span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>

        <span class="token comment">//需要三个指针，分别是m-1,n-1和m+n-1，前两个可以用m n 代替</span>

        <span class="token keyword">int</span> pos <span class="token operator">=</span> m<span class="token operator">+</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        n<span class="token operator">--</span><span class="token punctuation">;</span>m<span class="token operator">--</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> m<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            nums1<span class="token punctuation">[</span>pos<span class="token operator">--</span><span class="token punctuation">]</span><span class="token operator">=</span>nums1<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token operator">></span>nums2<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">?</span>nums1<span class="token punctuation">[</span>m<span class="token operator">--</span><span class="token punctuation">]</span><span class="token operator">:</span>nums2<span class="token punctuation">[</span>n<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            nums1<span class="token punctuation">[</span>pos<span class="token operator">--</span><span class="token punctuation">]</span><span class="token operator">=</span>nums2<span class="token punctuation">[</span>n<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>时间复杂度<em>O(m+n)<em>，因为指针最多遍历m+n个数，空间复杂度</em>O(1)</em></p>
<hr>
<h2 id="142-环形链表-II—（中等）"><a href="#142-环形链表-II—（中等）" class="headerlink" title="142. 环形链表 II—（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a>—（中等）</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p>
<p>说明：不允许修改给定的链表。</p>
<p><em>进阶：</em></p>
<p><em>你是否可以使用 O(1) 空间解决此题？</em></p>
<blockquote>
<p>示例：</p>
<img src="https://p6-tt.byteimg.com/origin/pgc-image/aeba8d5b296441c6a8d25a7bc3e7eb31.png" alt="1" style="zoom:80%;" />

<p>输入：head = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
</blockquote>
<p>本题第一次做稍微有难度，涉及到一些数学知识</p>
<p>所使用的是快慢指针，两个指针都是从头结点开始，快指针每次走两格，慢指针每次走一格，如果他们可以相遇，就代表链表是有环的，因为快指针每次走的比慢指针多<code>1</code>格，只要是有环路肯定能相遇</p>
<p>其次，在第一次相遇后，我们将快指针重置为头结点位置，之后快慢指针<code>同时走</code>，每次都是走<code>1</code>步，直到两指针再一次相遇就是我们要找的环入口了，具体是为什么呢？我们看下面的图</p>
<img src="https://p5-tt.byteimg.com/origin/pgc-image/c1f26d9f0524448ebd0245449d12eb45.png" alt="code" style="zoom:80%;" />

<p>我们设<code>x</code>是头结点到环形入口节点的节点数，<code>y</code>是从入口节点到两个指针第一次相遇的节点的节点数，当第一次两指针在同一个节点相遇时，慢指针走了<code>x+y</code>，快指针走了<code>x+y+n(z+y)</code>其中<code>n(z+y)</code>是在环内多走了<code>n</code>圈</p>
<p>又因为快指针走的节点数是慢指针的两倍则有方程：<code>2(x+y)=x+y+n(z+y)</code>，化简的出<code>x=n(y+z)-y</code>，从n(y+z)提出一个y+z得出公式：<code>x=(n-1)(y+z)+z</code>，这个时候我们假设<code>n=1</code>，即快指针只用在环内多走一圈就，就可以得出<code>x=z</code></p>
<p>这样就得出了最终的结论：当两个指针在第一次相遇后，此时相遇节点到环形入口节点长度<code>等于</code>头结点到环形入口长度，那么问题就很容易了，我们随便将一个指针<code>重置</code>回头结点，再让两个指针同时出发，并且每一步只走<code>一格</code>长度，当再次相遇时，位置就是环形入口节点了</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 */</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    ListNode <span class="token operator">*</span><span class="token function">detectCycle</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token operator">||</span>head<span class="token operator">-></span>next<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>

        ListNode<span class="token operator">*</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token comment">//快指针</span>
        ListNode<span class="token operator">*</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token comment">//慢指针</span>

        <span class="token comment">//第一次相遇，判断是否有环路</span>
        <span class="token keyword">do</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>fast<span class="token operator">||</span><span class="token operator">!</span>fast<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>

            fast<span class="token operator">=</span>fast<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>
            slow<span class="token operator">=</span>slow<span class="token operator">-></span>next<span class="token punctuation">;</span>

        <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>slow<span class="token operator">!=</span>fast<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//重置快指针</span>
        fast <span class="token operator">=</span> head<span class="token punctuation">;</span>

        <span class="token comment">//第二次相遇则是入口</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token operator">!=</span>slow<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            fast <span class="token operator">=</span> fast<span class="token operator">-></span>next<span class="token punctuation">;</span>
            slow <span class="token operator">=</span> slow<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">return</span> slow<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>时间复杂度为：<em>O(n)<em>，空间复杂度为</em>O(1)</em></p>
<hr>
<h2 id="76-最小覆盖子串—（困难）"><a href="#76-最小覆盖子串—（困难）" class="headerlink" title="76. 最小覆盖子串—（困难）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a>—（困难）</h2><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p>
<p>注意：</p>
<p>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br>如果 s 中存在这样的子串，我们保证它是唯一的答案。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：s = “ADOBECODEBANC”, t = “ABC”<br>输出：”BANC”</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：s = “a”, t = “a”<br>输出：”a”</p>
</blockquote>
<p>示例 3:</p>
<blockquote>
<p>输入: s = “a”, t = “aa”<br>输出: “”<br>解释: t 中两个字符 ‘a’ 均应包含在 s 的子串中，<br>因此没有符合条件的子字符串，返回空字符串。</p>
</blockquote>
<p>这个题目中要注意的是字符串t是可以包含<em>重复</em>字母的</p>
<p>所运用的是滑动窗口，由于之前没有做过滑动窗口的题，所以先看了解释才开始做的，更多细节在<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-window-substring/solution/zui-xiao-fu-gai-zi-chuan-by-leetcode-solution/">官方解析</a>和视频，滑动窗口图示如下：</p>
<img src="https://cube-resources.lenovo.com.cn/cube/86cf648e03a1a5daceab2cfbdb802819.gif" alt="滑动窗口" style="zoom:80%;" />

<p>首先是运用两个数组，一个是记录滑动窗口中遍历到的t字符串含有的字母个数，而另一个则是记录t字符串每个字母的个数。然后还有个比较重要的就是<code>distance</code>，这个变量是用来记录当前滑动窗口区域中拥有对照字符串t中所需要的字符个数</p>
<p>整个滑动窗口流程大致是：</p>
<p>当右指针前进时遍历到一个所需字符则<code>distance+1</code>，直到<code>distance == t.size()</code>时停止前进，<strong>注意当一个字符出现超过所需数但是distance还没达标时，distance不增加</strong>，如下面代码中的<code>winFre[s[right]]&gt;=tFre[s[right]]</code>时distance不会再继续加1。</p>
<p>之后轮到左指针前进，它会跳过一些多余的字符以尽可能地缩小区域，它也要剔除重复的字符数，当<code>winFre[s[right]]&gt;tFre[s[right]]</code>时distance不会相减，因此<code>distance</code>的作用可以看做是两边字母的边界值。在左指针遇到不能再继续前进时会比较当前最小的覆盖子串区间是否要更新，最后下一次循环中又要恢复为右区间前进，直到右区间到达t字符串的长度才会退出循环。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    string <span class="token function">minWindow</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> sLen <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> tLen <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span>sLen<span class="token operator">&lt;</span>tLen<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token comment">//特殊情况</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> s<span class="token punctuation">;</span>

        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//左指针</span>
        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//右指针</span>


        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">winFre</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//记录滑动窗口中所包含对照字符串每个字母的个数</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">tFre</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//记录对照字符串中所含有的每个字母的个数</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> i<span class="token operator">:</span>t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token comment">//遍历对照字符串t</span>
            tFre<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">int</span> begin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//记录返回字符串的开始下标位置</span>
        <span class="token keyword">int</span> minLen <span class="token operator">=</span> sLen<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">//记录当前遍历得到的最小覆盖子串长度</span>
        <span class="token keyword">int</span> distance <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//记录滑动窗口中所包含的字母个数和对照字符串所需要的字母个数差距（相同时不加）</span>

        <span class="token keyword">while</span><span class="token punctuation">(</span>right<span class="token operator">&lt;</span>sLen<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//循环结束条件是右指针到达最后一个字符</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>tFre<span class="token punctuation">[</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token comment">//首先是右指针往右走，遇到不是所需要找的字符跳过</span>
                right<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>

            <span class="token keyword">if</span><span class="token punctuation">(</span>winFre<span class="token punctuation">[</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>tFre<span class="token punctuation">[</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                distance<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//滑动窗口遇到不够字母总数时distance加一</span>

            winFre<span class="token punctuation">[</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
            right<span class="token operator">++</span><span class="token punctuation">;</span>

            <span class="token keyword">while</span><span class="token punctuation">(</span>distance <span class="token operator">==</span> tLen<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token comment">//滑动窗口左指针前进</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>tFre<span class="token punctuation">[</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                    left<span class="token operator">++</span><span class="token punctuation">;</span>
                    <span class="token keyword">continue</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>

                <span class="token keyword">if</span><span class="token punctuation">(</span>winFre<span class="token punctuation">[</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> tFre<span class="token punctuation">[</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                    distance<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment">//遇到刚好满足字符数条件时减去distance，以使恢复下一次循环是右指针前进</span>

                <span class="token keyword">int</span> tempWinLen <span class="token operator">=</span> right <span class="token operator">-</span> left<span class="token punctuation">;</span><span class="token comment">//当前滑动窗口的字符长度</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>minLen<span class="token operator">></span>tempWinLen<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                    <span class="token comment">//如果当前记录在内的最小区间没有新的小则替换它</span>
                    minLen <span class="token operator">=</span> tempWinLen<span class="token punctuation">;</span>
                    begin <span class="token operator">=</span> left<span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>                

                winFre<span class="token punctuation">[</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>
                left<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">//cout&lt;&lt;begin&lt;&lt;" "&lt;&lt;minLen;</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span>minLen <span class="token operator">==</span> sLen <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span>minLen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>时间复杂度O(n)，空间复杂度O(k)，k为两个传进来的字符串长度之和</p>
<hr>
<h2 id="524-通过删除字母匹配到字典里最长单词—（中等）"><a href="#524-通过删除字母匹配到字典里最长单词—（中等）" class="headerlink" title="524. 通过删除字母匹配到字典里最长单词—（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/">524. 通过删除字母匹配到字典里最长单词</a>—（中等）</h2><p>给你一个字符串 s 和一个字符串数组 dictionary 作为字典，找出并返回字典中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。</p>
<p>如果答案不止一个，返回长度最长且字典序最小的字符串。如果答案不存在，则返回空字符串。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：s = “abpcplea”, dictionary = [“ale”,”apple”,”monkey”,”plea”]<br>输出：”apple”</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：s = “abpcplea”, dictionary = [“a”,”b”,”c”]<br>输出：”a”</p>
</blockquote>
<p>注意这里的<code>字典序</code>概念：基于字母顺<em>序</em>排列的单词按字母顺<em>序</em>排列的方法，例：abc &lt; bbc，可以用C++中<code>string</code>类自带的成员函数（非static）<code>a.compare(string&amp; b)</code>来比较</p>
<p>这道题刚开始想就是普通地把字典中的字符串每个遍历，并作比较是否为s字符串的子串，比较之后再比较字典序。以为这个方法效率不行，想不到官方解答给出最有效率的就是这个了</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    string <span class="token function">findLongestWord</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> dictionary<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> sLen <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> dSize <span class="token operator">=</span> dictionary<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        string maxStr <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token comment">//记录最后要返回的长度最长且字典序最小的字符串</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> str <span class="token operator">:</span> dictionary<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">IsSubStr</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> maxStr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> maxStr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>maxStr<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    maxStr <span class="token operator">=</span> str<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">return</span> maxStr<span class="token punctuation">;</span>

    <span class="token punctuation">&#125;</span>

    <span class="token keyword">static</span> <span class="token keyword">bool</span> <span class="token function">IsSubStr</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> a<span class="token punctuation">,</span>string<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token comment">//检测b是不是a的子串</span>
        <span class="token keyword">int</span> subSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> bLen <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> ch <span class="token operator">:</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>ch <span class="token operator">==</span> b<span class="token punctuation">[</span>subSize<span class="token punctuation">]</span><span class="token punctuation">)</span>
                <span class="token operator">++</span>subSize<span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>subSize <span class="token operator">==</span> bLen<span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>时间复杂度为<em>O(n·x)<em>其中n是字典数组长度，x是数组中字符串平均长度，</em>O(x)</em></p>
<hr>
<h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><h2 id="154-寻找旋转排序数组中的最小值-II—（困难）"><a href="#154-寻找旋转排序数组中的最小值-II—（困难）" class="headerlink" title="154. 寻找旋转排序数组中的最小值 II—（困难）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值 II</a>—（困难）</h2><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：<br>若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]<br>若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p>
<p>给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：nums = [1,3,5]<br>输出：1</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：nums = [2,2,2,0,1]<br>输出：0</p>
</blockquote>
<p>这道题感觉LeetCode难度分的挺迷的，说是困难其实也没什么难度，也是使用<code>left,mid,right</code>三个指针，只要只要考虑几点就行了</p>
<p>这里有三种情况，分别是：</p>
<p>1、<code>nums[mid]</code>小于<code>nums[right]</code>，证明我们要找的最小值在前半段或者是<code>nums[mid]</code>本身，因此我们把<code>right = mid</code></p>
<p>2、<code>nums[mid]</code>大于<code>nums[right]</code>，证明最小值通过数组旋转给调到有半段去了，而且此时的<code>nums[mid]</code>肯定不是我们要找的数，所以我们将<code>left = mid + 1</code></p>
<p>3、排除上面两种情况之后，就要考虑数组中有重复的数字，而且可能就是当前指针指着的，我们只需要将右指针往前走就行了<code>--right</code>，至于为什么不是左指针往后走，是因为：</p>
<ul>
<li>此操作不会使数组越界：因为迭代条件保证了 right &gt; left &gt;= 0；</li>
<li>此操作不会使最小值丢失：假设<code>nums[right]</code>是最小值，有两种情况：</li>
<li>1）若 <code>nums[right]</code> 是唯一最小值：那就不可能满足判断条件 <code>nums[mid] == nums[right]</code>，因为 <code>mid &lt; right</code>（left != right  且 mid = (left + right) / 2 向下取整）；</li>
<li>2）若 nums[right] 不是唯一最小值，由于<code> mid &lt; right</code> 而 <code>nums[mid] == nums[right]</code>，即还有最小值存在于 <code>[left, right - 1]</code>区间，因此不会丢失最小值。</li>
</ul>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token punctuation">:</span>
    <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">findMin</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name"><span class="token keyword">int</span></span> nLen <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name"><span class="token keyword">int</span></span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword">int</span></span> right <span class="token operator">=</span> nLen <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword">int</span></span> mid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token comment">//前半部分是增序序列</span>
                right <span class="token operator">=</span> mid<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token comment">//后半部分为降序序列</span>
                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
                <span class="token operator">--</span>right<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>   
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>时间复杂度 O(logN)，最坏情况也只到 O(N)，比如给定的数组每个数字都是一样的 {1,1,1,1,1}</p>
<hr>
<h2 id="540-有序数组中的单一元素—（中等）"><a href="#540-有序数组中的单一元素—（中等）" class="headerlink" title="540. 有序数组中的单一元素—（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/">540. 有序数组中的单一元素</a>—（中等）</h2><p>给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: nums = [1,1,2,3,3,4,4,8,8]<br>输出: 2</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: nums =  [3,3,7,7,10,11,11]<br>输出: 10</p>
</blockquote>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>0 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<p>这道题可以观察题意发现，在出现独立数之前，数组的下标都是有规律的，偶数（包含0）对应一对重复数的第一个，奇数对应第二个。一旦独立数出现之后，情况就反过来了</p>
<p>总体上看的话，整个数组肯定是奇数个的，因为其余重复数是偶数个再加上一个独立数就是奇数个</p>
<p>因此可以看下面的例子，当我们把一个数组的中中间的一对元素移除之后，剩下左边的数组全是重复的元素，个数为偶数；而右边含有一个独立数元素，个数为奇数。</p>
<p><img src="https://i.loli.net/2021/07/31/njUaBzt62Sv5OIf.png" alt="1.png"></p>
<p>此时我们就可以通过判断左右子数组含有元素的个数是奇还是偶来进行下一步往哪边判断</p>
<p>下面有几种情况我们可以来分析一下，假设左指针是<code>lo</code>，右指针是<code>hi</code></p>
<p>情况1：</p>
<p>中间元素的同一元素在右边，且被 mid 分成两半的数组为偶数。</p>
<p>我们将右子数组的第一个元素移除后，则右子数组元素个数变成奇数，我们应将 <code>lo</code> 设置为 <code>mid + 2</code></p>
<p><img src="https://i.loli.net/2021/07/31/bnv7lY6X3uTIWw9.png" alt="2.jpg"></p>
<p>情况2：</p>
<p>中间元素的同一元素在右边，且被 <code>mid</code> 分成两半的数组为奇数。</p>
<p>我们将右子数组的第一个元素移除后，则右子数组的元素个数变为偶数，我们应将 <code>hi</code> 设置为 <code>mid - 1</code></p>
<p><img src="https://i.loli.net/2021/07/31/mfnQIPMUGhT5sED.png" alt="3.png"></p>
<p>例子 3：中间元素的同一元素在左边，且被 mid 分成两半的数组为偶数。</p>
<p>我们将左子数组的最后一个元素移除后，则左子数组的元素个数变为奇数，我们应将 hi 设置为 mid - 2。</p>
<p><img src="https://i.loli.net/2021/07/31/25rqAzunOkFvGPU.png" alt="4.png"></p>
<p>例子 4：中间元素的同一元素在左边，且被 mid 分成两半的数组为奇数。</p>
<p>我们将左子数组的最后一个元素移除后，则左子数组的元素个数变为偶数，我们应将 lo 设置为 mid + 1。</p>
<p><img src="https://i.loli.net/2021/07/31/xSkLFir6aE1oIPc.png" alt="5.png"></p>
<p>还有最后一种情况，就是刚好我们的中间指针指向的数和前面后面的数都不相等，就代表这个数就是我们要找的独立数了，这个时候就可以直接return</p>
<p>明白原理之后就可以写代码了</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">singleNonDuplicate</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">//O(log n)时间复杂度方法</span>
        <span class="token keyword">int</span> nLen <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>nLen <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//只有一个数直接返回</span>

        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> right <span class="token operator">=</span> nLen <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token comment">//中间指针的数与前一个数相等</span>
                mid<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment">//中间指针后退以便计算左边子数组的个数</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>mid<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//左边是偶数的话唯一数在右边</span>
                    left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span><span class="token comment">//否则唯一数在左边</span>
                    right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token comment">//中间指针和后面一个数相等的话</span>
                mid<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//中间指针前进一格，以便计算右边子数组的个数</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>right <span class="token operator">-</span> mid<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    right <span class="token operator">=</span> mid <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span>
                    left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
                <span class="token comment">//中间数与前后的数都不相等，代表我们找到了要的那个数</span>
                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>

        <span class="token punctuation">&#125;</span>

        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个算法时间复杂度为O(log n)，空间复杂度为O(1)</p>
<p>在此题目的官方题解中还有第三种解法，<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/solution/you-xu-shu-zu-zhong-de-dan-yi-yuan-su-by-leetcode/"><strong>方法三：仅对偶数索引进行二分搜索</strong></a>，这个解法时间复杂度为O(n/2) = O(n)，比起上面的算法更优雅一些，可以去看一下</p>
<hr>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>排序要懂得常用的那几个排序，同时还要求可以默写出来，此后会有专门的文章来记录各种常用的排序算法的代码，这里暂时跳过，直接看一个基于快速排序的<strong>快速选择算法</strong>题目</p>
<h2 id="215-数组中的第K个最大元素—（中等）"><a href="#215-数组中的第K个最大元素—（中等）" class="headerlink" title="215. 数组中的第K个最大元素—（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a>—（中等）</h2><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>输出: 4</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= nums.length &lt;= 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
</ul>
<p>遇到这种寻找数组中第x个最大（小）元素的题目，我们都可以用快速选择的方法来解决</p>
<p>因为我们只用找某个第x个最大（小）的数，因此并不用对整个数组排序，从而把快速排序的O(n*log n)的平均时间复杂度降到O(n)，但是要注意的是最差情况下还是可能O(n^2)</p>
<p>快速排序是一种分治算法，而快速选择也类似，假设这里有一个数组<strong>a[l…r]<strong>，我们要找到数组</strong>第k大</strong>的数，快速选择可以分为以下步骤：</p>
<ul>
<li><strong>分解</strong>：将数组分为a[l…q-1]，a[q]，a[q+1…r]，其中左半边的子数组a[l…q-1]每一个元素都小于等于a[q]，而对于右半边的子数组，a[q]都会小于等于右半边子数组的每一个元素</li>
<li><strong>解决</strong>：不像快速排序，我们不用把左右两边子数组进行排序，只用处理好a[q]两边子数组满足<code>分解</code>步骤的要求就行了。因为当分解好后，a[q]在数组中的位置就是我们快排后最终它所在的位置，当分解到a[q]的下标q正好是我们要找的下标时就直接return a[q]</li>
</ul>
<p>时间复杂度：</p>
<p>我们知道快速排序的性能和「划分」出的子数组的长度密切相关。直观地理解如果每次规模为 n 的问题我们都划分成 1和 n - 1，每次递归的时候又向 n - 1 的集合中递归，这种情况是最坏的，时间代价是 O(n ^ 2)<br> )。我们可以引入随机化来加速这个过程，它的时间代价的期望是 O(n)，证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">QuickSelect</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> i<span class="token operator">=</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//nums[l]是哨兵数</span>
        <span class="token keyword">int</span> j<span class="token operator">=</span>right<span class="token punctuation">;</span>

        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>right<span class="token operator">></span>i<span class="token operator">&amp;&amp;</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span>
                <span class="token operator">++</span>i<span class="token punctuation">;</span>

            <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">></span>left<span class="token operator">&amp;&amp;</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">>=</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span>
                <span class="token operator">--</span>j<span class="token punctuation">;</span>

            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">>=</span>j<span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> j<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> r <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> traget <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>k<span class="token punctuation">;</span><span class="token comment">//目标</span>

        <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token function">QuickSelect</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>l<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>mid<span class="token operator">==</span>traget<span class="token punctuation">)</span>
                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span><span class="token punctuation">(</span>mid <span class="token operator">&lt;</span> traget<span class="token punctuation">)</span><span class="token comment">//目标在右边子数组</span>
                l<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span><span class="token comment">//目标在左边子数组</span>
                r<span class="token operator">=</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><p>搜索一般分为<strong>深度优先搜索（DFS）</strong>和<strong>广度优先搜索（BFS）</strong>，它们被广泛运用在图和树等结构中</p>
<p><strong>深度优先搜索（depth-first seach， DFS）</strong>：在搜索到一个新的节点时，立即对该新节点进行遍<br>历；因此遍历需要用<strong>先入后出的栈</strong>来实现，也可以通过与栈等价的<strong>递归</strong>来实现。对于树结构而言，<br>由于总是对新节点调用遍历，因此看起来是向着“深”的方向前进。  </p>
<p><strong>深度优先搜索</strong>也可以用来<strong>检测环路</strong>：记录每个遍历过的节点的父节点，若一个节点被再次遍<br>历且父节点不同，则说明有环。我们也可以用之后会讲到的拓扑排序判断是否有环路，若最后存<br>在入度不为零的点，则说明有环。<br>有时我们可能会需要对已经搜索过的节点进行标记，以防止在遍历时重复搜索某个节点，这<br>种做法叫做<strong>状态记录</strong>或<strong>记忆化（memoization）</strong>。  </p>
<p><strong>广度优先搜索（breadth-first search， BFS）</strong>：不同与深度优先搜索，它是一层层进行遍历的，因<br>此需要用<strong>先入先出的队列</strong>而非先入后出的栈进行遍历。由于是按层次进行遍历，广度优先搜索时<br>按照“广”的方向进行遍历的，也常常用来处理最短路径等问题。  </p>
<p>这里要注意，深度优先搜索和广度优先搜索都可以处理<strong>可达性</strong>问题，即从一个节点开始是否<br>能达到另一个节点。因为深度优先搜索可以利用递归快速实现，很多人会习惯使用深度优先搜索<br>刷此类题目。实际软件工程中，很少见到递归的写法，因为一方面难以理解，另一方面可能<br>产生栈溢出的情况；而用栈实现的深度优先搜索和用队列实现的广度优先搜索在写法上并没有太<br>大差异，因此使用哪一种搜索方式需要根据实际的功能需求来判断。  </p>
<h2 id="934-最短的桥—（中等）"><a href="#934-最短的桥—（中等）" class="headerlink" title="934. 最短的桥—（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shortest-bridge/">934. 最短的桥</a>—（中等）</h2><p>在给定的二维二进制数组 A 中，存在两座岛。（岛是由四面相连的 1 形成的一个最大组。）</p>
<p>现在，我们可以将 <code>0</code> 变为 <code>1</code>，以使两座岛连接起来，变成一座岛。</p>
<p>返回必须翻转的 <code>0</code> 的最小数目。（可以保证答案至少是 <code>1 </code>）</p>
<p>示例 1：</p>
<blockquote>
<p>输入：A = [[0,1],[1,0]]<br>输出：1</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：A = [[0,1,0],[0,0,0],[0,0,1]]<br>输出：2</p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入：A = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]<br>输出：1</p>
</blockquote>
<p>示例4：</p>
<blockquote>
<p>输入：<br>[[1,1,1,1,1],<br>[1,0,0,0,1],<br>[1,0,1,0,1],<br>[1,0,0,0,1],<br>[1,1,1,1,1]]<br>输出：1  </p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= A.length == A[0].length &lt;= 100</code></li>
<li><code>A[i][j] == 0</code> 或 <code>A[i][j] == 1</code></li>
</ul>
<p>岛屿问题一般都是与dfs有关系，大多都是套模板</p>
<p>这里有题目得知一共有两个岛屿，其余的都是水，这里用示例4来说</p>
<p>刚开始两座岛屿是隔开的，因此我们可以先遍历其中一个岛屿，并把整个岛屿遍历完，同时边遍历边把这个岛的<code>1</code>改成<code>2</code>作为标记</p>
<p>当把这个岛全部遍历完时，此时地图上有三个部分，分别是：岛屿1、岛屿2和水</p>
<p>紧接着再选择一个岛屿（这里假设选择岛屿1），使用广度搜索层层遍历，当第一次遇到岛屿2时走过的层数就是最短桥</p>
<p>代码有点多，大致分为四个步骤</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> direction<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//方向数组</span>

    <span class="token keyword">int</span> <span class="token function">shortestBridge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> map<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">//步骤1：遍历一个岛，把1改成2作为标记</span>
        <span class="token comment">//dfs</span>
        <span class="token keyword">int</span> findFlag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//记录是否找到岛屿了</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token comment">//第一层</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>map<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token comment">//第二层</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                    <span class="token comment">//找到了岛屿</span>
                    map<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
                    <span class="token function">dfs</span><span class="token punctuation">(</span>map<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//步骤2：深度搜索同时把当前整个大陆涂上2</span>
                    findFlag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">//找到岛屿，标记以便退出循环，因为找到一块其它相连的都会在dfs中涂上2</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//找到后就退出了</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>findFlag<span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// 此时，连通块已涂色，分为三块，0是水，1和2代表两个连通块（岛1和岛2）</span>
        <span class="token comment">//步骤3：再选择一个岛屿（这里选择岛屿1），为广度搜索队列做准备而入列</span>
        <span class="token keyword">int</span> step<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//记录层数，最终返回的答案</span>
        queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">>></span> qMap<span class="token punctuation">;</span><span class="token comment">//选择pair是为了存储坐标</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>map<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//把岛屿1的点坐标全部入列</span>
                    qMap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token comment">//步骤4：广度搜索队列中的岛屿，层层推进向外扩张</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>qMap<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//队列不为空就在循环内</span>
            <span class="token keyword">int</span> size <span class="token operator">=</span> qMap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//当前层要遍历的次数</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> cur <span class="token operator">=</span> qMap<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">int</span> x<span class="token operator">=</span>cur<span class="token punctuation">.</span>first<span class="token punctuation">;</span>
                <span class="token keyword">int</span> y<span class="token operator">=</span>cur<span class="token punctuation">.</span>second<span class="token punctuation">;</span>
                qMap<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>index<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token operator">++</span>index<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                    <span class="token comment">//向四周扩散</span>
                    <span class="token keyword">int</span> x_next<span class="token operator">=</span>x<span class="token operator">+</span>direction<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    <span class="token keyword">int</span> y_next<span class="token operator">=</span>y<span class="token operator">+</span>direction<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span><span class="token punctuation">(</span>x_next<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>y_next<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>x_next<span class="token operator">&lt;</span>map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>y_next<span class="token operator">&lt;</span>map<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                        <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">[</span>x_next<span class="token punctuation">]</span><span class="token punctuation">[</span>y_next<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">//找到岛屿2，可以返回了</span>
                            <span class="token keyword">return</span> step<span class="token punctuation">;</span>
                        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">[</span>x_next<span class="token punctuation">]</span><span class="token punctuation">[</span>y_next<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//遍历的还是当前岛屿的版块，继续搜索</span>
                            <span class="token keyword">continue</span><span class="token punctuation">;</span>
                        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>
                            <span class="token comment">//遍历的是海洋</span>
                            qMap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span>x_next<span class="token punctuation">,</span>y_next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//入队列</span>
                            map<span class="token punctuation">[</span>x_next<span class="token punctuation">]</span><span class="token punctuation">[</span>y_next<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//涂色，防止遍历重复</span>
                        <span class="token punctuation">&#125;</span>

                    <span class="token punctuation">&#125;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
            step<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//遍历一层结束，答案加一</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">//深度搜索，将整块大陆的1改成2</span>
    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> map<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>index<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token operator">++</span>index<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token comment">//往四个方向扩张</span>
            <span class="token keyword">int</span> x_next<span class="token operator">=</span>x<span class="token operator">+</span>direction<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> y_next<span class="token operator">=</span>y<span class="token operator">+</span>direction<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>x_next<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>y_next<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>x_next<span class="token operator">&lt;</span>map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>y_next<span class="token operator">&lt;</span>map<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>map<span class="token punctuation">[</span>x_next<span class="token punctuation">]</span><span class="token punctuation">[</span>y_next<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token comment">//限制条件，所寻找的下一个点没有越界，同时下一个点也是属于陆地</span>
                map<span class="token punctuation">[</span>x_next<span class="token punctuation">]</span><span class="token punctuation">[</span>y_next<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//涂色</span>
                <span class="token function">dfs</span><span class="token punctuation">(</span>map<span class="token punctuation">,</span>x_next<span class="token punctuation">,</span>y_next<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//继续搜索</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>


<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>时间复杂度：O(MN)，其中 M 和 N 分别是数组行数和列数</p>
<p>空间复杂度：O(MN)</p>
<hr>
<h2 id="126-单词接龙-II-—（困难）"><a href="#126-单词接龙-II-—（困难）" class="headerlink" title="126. 单词接龙 II  —（困难）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-ladder-ii/">126. 单词接龙 II</a>  —（困难）</h2><p>按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -&gt; s1 -&gt; s2 -&gt; … -&gt; sk 这样的单词序列，并满足：</p>
<ul>
<li>每对相邻的单词之间仅有单个字母不同。</li>
<li>转换过程中的每个单词 si（1 &lt;= i &lt;= k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词。</li>
<li>sk == endWord</li>
</ul>
<p>给你两个单词 beginWord 和 endWord ，以及一个字典 wordList 。请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列 ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 [beginWord, s1, s2, …, sk] 的形式返回</p>
<p>示例 1：</p>
<blockquote>
<p>输入：beginWord = “hit”, endWord = “cog”, wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br>输出：[[“hit”,”hot”,”dot”,”dog”,”cog”],[“hit”,”hot”,”lot”,”log”,”cog”]]<br>解释：存在 2 种最短的转换序列：<br>“hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”<br>“hit” -&gt; “hot” -&gt; “lot” -&gt; “log” -&gt; “cog”</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：beginWord = “hit”, endWord = “cog”, wordList = [“hot”,”dot”,”dog”,”lot”,”log”]<br>输出：[]<br>解释：endWord “cog” 不在字典 wordList 中，所以不存在符合要求的转换序列。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= beginWord.length &lt;= 7</li>
<li>endWord.length == beginWord.length</li>
<li>1 &lt;= wordList.length &lt;= 5000</li>
<li>wordList[i].length == beginWord.length</li>
<li>beginWord、endWord 和 wordList[i] 由小写英文字母组成</li>
<li>beginWord != endWord</li>
<li>wordList 中的所有单词 <strong>互不相同</strong></li>
</ul>
<p>题目第一眼看上去很复杂，需要多读几遍，注意到示例1中假设有多条最短的转换序列，这些序列都要返回，这个点不能忘记。其次是<code>beginWord</code>可以不在字典内，但是<code>endWord</code>一定要在里边，如果不在的话就要返回空数组</p>
<p>这道题我们把字典里的每个单词看成不同的节点，借用LeetCode官方解答的图就是下面这样</p>
<p><img src="https://i.loli.net/2021/08/02/JtMma8hzRXOT4uS.png"></p>
<p>然后从开始的单词循序渐进到最后一个单词的过程如下</p>
<p><img src="F:\编程\LeetCode刷题笔记\图片\第一期\深度搜索\126\126_fig2.png" alt="126_fig2"></p>
<p>明白这个之后，我们就要思考怎么遍历它们</p>
<p>我们可以把起始字符串、终止字符串、以及单词表里所有的字符串想象成节点。若两个字符<br>串只有一个字符不同，那么它们相连。因为题目需要输出修改次数最少的所有修改方式，因此我<br>们可以使用广度优先搜索，求得起始节点到终止节点的最短距离</p>
<p>为什么不用DFS的原因是DFS需要剪枝，处理起来比较麻烦</p>
<p>一般的BFS模板套路如下</p>
<blockquote>
<p>定义 层节点 容器<br>根节点 压入容器内<br>while (容器非空) {<br>    获取容器内节点的个数（即当前处理层节点个数）<br>    for (当前层节点个数) {<br>        从容器中获取一个节点<br>        按业务逻辑处理单个节点<br>        获取当前节点的 子节点 压入容器内<br>    }<br>}</p>
</blockquote>
<p>这题同样是可以套用这个模版来解决，需要修改的点：</p>
<ul>
<li>需要改一下 单个节点 的 数据结构</li>
<li>处理单个节点的业务逻辑（回溯做业务，HashMap辅助业务逻辑）</li>
</ul>
<p>单个节点的结构使用 <code>vector&lt;string&gt;</code> 类型，也就是自上而下单次 转换序 的累加值。</p>
<pre><code>      hit
         \
         hit,hot
      /          \
  hit,hot,dot    hit,hot,lot
  /                 \
hit,hot,dot,dog     hit,hot,lot,log
   /                      \
hit,hot,dot,dog,cog       hit,hot,lot,log,cog
</code></pre>
<p>而节点内的最后一个 string 元素决定了 下层（也就是树型结构的子节点）节点，也就是 wordList 内的值。<br>在获取到下层节点时，是需要把从 wordList 里面找到的元素给删除，避免 重复转换 进入死循环。</p>
<p>我们也可以双向来搜索，即从起始节点和终止节点分别进行广度优先搜索，每次只延展当前层节点数最少<br>的那一端，这样我们可以减少搜索的总结点数。举例来说，假设最短距离为 4，如果我们只从一<br>端搜索 4 层，总遍历节点数最多是 1 + 2 + 4 + 8 + 16 = 31；而如果我们从两端各搜索两层，总遍<br>历节点数最多只有 2 × (1 + 2 + 4) = 14。  </p>
<p><strong>双向遍历理解起来比较难，不强求一下子就能明白，可以先理解好单向遍历，到时候回来再看看双向的可能就明白了</strong></p>
<p>这里先放单向遍历的代码</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> <span class="token function">findLadders</span><span class="token punctuation">(</span>string beginWord<span class="token punctuation">,</span> string endWord<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> wordList<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">//将字典的每个单词录入哈希表中，方便后面查找</span>
        unordered_set<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">search</span><span class="token punctuation">(</span>wordList<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>wordList<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> res<span class="token punctuation">;</span><span class="token comment">//待返回答案</span>
        deque<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> worker<span class="token punctuation">;</span><span class="token comment">//层节点容器，记录每一层中得到的转换序列</span>
        worker<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>beginWord<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//由第一个字符串开始出发，将他作为根节点</span>

        <span class="token comment">//bfs</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>worker<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token comment">//记录这一层已经转化的点，在这一轮结束时在字典中删除，防止下次再访问</span>
            unordered_set<span class="token operator">&lt;</span>string<span class="token operator">></span> visited<span class="token punctuation">;</span>

            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> worker<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//层遍历，</span>
                <span class="token comment">//（这里换成int i = 0; i &lt; worker.size(); ++i会超时）</span>

                <span class="token comment">//获取节点容器的第一个节点，并pop掉</span>
                vector<span class="token operator">&lt;</span>string<span class="token operator">></span> sub <span class="token operator">=</span> worker<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>worker<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                
                <span class="token comment">//取得这一行转换序列的最后一个字符串，因为它决定下一个要寻找的元素</span>
                string tail <span class="token operator">=</span> sub<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token keyword">if</span><span class="token punctuation">(</span>tail<span class="token operator">==</span>endWord<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//如果取得的是想要的字符串</span>
                    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token comment">//?</span>
                <span class="token punctuation">&#125;</span>

                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>tail<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                    <span class="token comment">//回溯试探，改变不同字符来获取下一个要走的点</span>
                    <span class="token keyword">char</span> temp <span class="token operator">=</span> tail<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//保存原来的字符以便恢复</span>
                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token operator">=</span><span class="token string">'a'</span><span class="token punctuation">;</span>c<span class="token operator">&lt;=</span><span class="token string">'z'</span><span class="token punctuation">;</span><span class="token operator">++</span>c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                        <span class="token keyword">if</span><span class="token punctuation">(</span>c<span class="token operator">==</span>temp<span class="token punctuation">)</span>
                            <span class="token keyword">continue</span><span class="token punctuation">;</span>
                        tail<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>c<span class="token punctuation">;</span>

                        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>search<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span><span class="token punctuation">)</span>
                            <span class="token keyword">continue</span><span class="token punctuation">;</span>
                        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>
                            <span class="token comment">//试探字典中是否包含当前临时字符串</span>
                            <span class="token comment">//如果包含的话</span>
                            visited<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将该字符串记录为已转化的点</span>
                            
                            <span class="token comment">//记录当前层</span>
                            sub<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            worker<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//向容器保存好子节点</span>
                            sub<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//回溯恢复</span>
                        <span class="token punctuation">&#125;</span>
                        
                    <span class="token punctuation">&#125;</span>
                    tail<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span><span class="token comment">//把字符串恢复好，以备下一个字符的试探</span>
                <span class="token punctuation">&#125;</span>

            <span class="token punctuation">&#125;</span>
            
            <span class="token keyword">if</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token comment">//当res的数目大于0就证明找到了所有路径了</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> str<span class="token operator">:</span>visited<span class="token punctuation">)</span>
                search<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除字典中已经用过的单词，防止下次循环继续赋值</span>
        <span class="token punctuation">&#125;</span><span class="token comment">//end while</span>
        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//默认情况返回空</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>时间复杂度：O(n)，n 为 wordList 的个数；忽略 string 的复制带来时间，和 26 个字母遍历的系数。</p>
<p><strong>双向遍历解法这里待补充，只放个代码先，具体讲解可以去看<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-ladder-ii/solution/2chong-jie-fa-jian-ji-dai-ma-qing-xi-jie-3sjt/">这个题解</a></strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> <span class="token function">findLadders</span><span class="token punctuation">(</span>string beginWord<span class="token punctuation">,</span> string endWord<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> wordList<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">//首先需要使用集合保存wordList，因为需要判断某单词是否在单词表中(count方法)</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> result<span class="token punctuation">;</span>
        unordered_set<span class="token operator">&lt;</span>string<span class="token operator">></span> words<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span> str <span class="token operator">:</span> wordList<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            words<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">//判断结束单词是否在单词列表中，如果不在，则直接返回空表</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>words<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>endWord<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> result<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">//创建两个集合，实现双向查找</span>
        unordered_set<span class="token operator">&lt;</span>string<span class="token operator">></span> q1<span class="token punctuation">&#123;</span>beginWord<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> q2<span class="token punctuation">&#123;</span>endWord<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        words<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>beginWord<span class="token punctuation">)</span><span class="token punctuation">;</span>
        words<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>endWord<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//创建map集合保存每个单词中一个字母发生变化并且存在于单词表中的单词列表</span>
        <span class="token comment">//此map用于广度遍历</span>
        unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> next<span class="token punctuation">;</span>
        <span class="token comment">//双集合寻找，标志具体是哪个集合寻找</span>
        <span class="token keyword">bool</span> reversed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">bool</span> find <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

        <span class="token comment">//next数据的搜寻</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token comment">//需要创建新的集合保存一轮遍历下来，每个单词只改变一个字母且在单词表中的单词</span>
            <span class="token comment">//即保存第二层需要遍历的单词</span>
            unordered_set<span class="token operator">&lt;</span>string<span class="token operator">></span> q<span class="token punctuation">;</span>
            <span class="token comment">//遍历q1中的每个单词</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span> w <span class="token operator">:</span> q1<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                string s <span class="token operator">=</span> w<span class="token punctuation">;</span>
                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                    <span class="token comment">//保存改变的字符，在每一轮最后复原单词</span>
                    <span class="token keyword">char</span> ch <span class="token operator">=</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">26</span> <span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                        s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token string">'a'</span><span class="token punctuation">;</span>
                        <span class="token comment">//如果q2集合中有此单词则说明查找成功</span>
                        <span class="token keyword">if</span><span class="token punctuation">(</span>q2<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                            reversed <span class="token operator">?</span> next<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token operator">:</span> next<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            find <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                        <span class="token punctuation">&#125;</span>
                        <span class="token keyword">if</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                            reversed <span class="token operator">?</span> next<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token operator">:</span> next<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            q<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token comment">//words.erase(s);</span>
                        <span class="token punctuation">&#125;</span>
                    <span class="token punctuation">&#125;</span>
                    <span class="token comment">//改回来</span>
                    s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> ch<span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
            
            <span class="token keyword">if</span><span class="token punctuation">(</span>find<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span> s<span class="token operator">:</span> q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                words<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token comment">//q1保存下一趟需要遍历的单词集合</span>
            <span class="token comment">//q2则保存另一个集合</span>
            <span class="token comment">//谁小遍历谁，减小开销</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> q2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                q1 <span class="token operator">=</span> q<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
                q1 <span class="token operator">=</span> q2<span class="token punctuation">;</span>
                q2 <span class="token operator">=</span> q<span class="token punctuation">;</span>
                reversed <span class="token operator">=</span> <span class="token operator">!</span>reversed<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> 
        <span class="token punctuation">&#125;</span>

        <span class="token comment">//现在需要对构造好的next进行查找,并找到所有路径</span>
        vector<span class="token operator">&lt;</span>string<span class="token operator">></span> path<span class="token punctuation">&#123;</span> beginWord <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        <span class="token function">bfs</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> result<span class="token punctuation">,</span> path<span class="token punctuation">,</span> beginWord<span class="token punctuation">,</span> endWord<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">void</span> <span class="token function">bfs</span><span class="token punctuation">(</span>unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span><span class="token operator">&amp;</span> next<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> <span class="token operator">&amp;</span>result<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token operator">&amp;</span>path <span class="token punctuation">,</span> string <span class="token operator">&amp;</span> src<span class="token punctuation">,</span> string <span class="token operator">&amp;</span> des<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>src <span class="token operator">==</span> des<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span> s <span class="token operator">:</span> next<span class="token punctuation">[</span>src<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            path<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">bfs</span><span class="token punctuation">(</span>next <span class="token punctuation">,</span> result <span class="token punctuation">,</span> path <span class="token punctuation">,</span> s <span class="token punctuation">,</span> des<span class="token punctuation">)</span><span class="token punctuation">;</span>
            path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h2 id="130-被围绕的区域-—（中等）"><a href="#130-被围绕的区域-—（中等）" class="headerlink" title="130. 被围绕的区域  —（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域</a>  —（中等）</h2><p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code> ，找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p>
<p>示例1：</p>
<img src="https://i.loli.net/2021/08/03/uURHlsoYcjTyCXt.jpg" style="zoom:80%;" />

<blockquote>
<p>输入：board = [[“X”,”X”,”X”,”X”],[“X”,”O”,”O”,”X”],[“X”,”X”,”O”,”X”],[“X”,”O”,”X”,”X”]]<br>输出：[[“X”,”X”,”X”,”X”],[“X”,”X”,”X”,”X”],[“X”,”X”,”X”,”X”],[“X”,”O”,”X”,”X”]]<br>解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入：board = [[“X”]]<br>输出：[[“X”]]</p>
</blockquote>
<p>提示：</p>
<ul>
<li>m == board.length</li>
<li>n == board[i].length</li>
<li>1 &lt;= m, n &lt;= 200</li>
<li>board[i][j] 为 ‘X’ 或 ‘O’</li>
</ul>
<p>这道题刚开始我就拿来自己做，做法是按顺序扫描，然后做标记等，但是做到后面的用例都会有几个过不了，一直改来改去导致代码臃肿，达到了一百多行，因此只能换种方法</p>
<p>先来分析题干，本题给定的矩阵中有三种元素：  字母 X； 被字母 X 包围的字母 O； 没有被字母 X 包围的字母 O。本题要求将所有被字母 X 包围的字母 O都变为字母 X ，但很难判断哪些 O 是被包围的，哪些 O 不是被包围的。</p>
<p>此题目中要注意的是在<strong>边界</strong>中的 <code>O</code>都不会给填充成<code>X</code>，因此我们可以从这里下手，先探测边界中有<code>O</code>的地方，之后再由此延展到内部，将相连的O都标记为一个值（假设标记为<code>B</code>）</p>
<p>待到全部边界O以及与它相连的O都标记完后，此时的平面上只有三种值，一个是<code>X</code>，一个是<code>O</code>，还有一个是<code>B</code>，这个时候的B都是不可以填充的，因为他们都与边界值相连，不满足条件。因此我们只用把剩下的O填充为X就行了</p>
<p>我们就可以再次按顺序扫描，遇到B回滚为O，遇到O则填充为X，这里不用担心会搞混，因为是按顺序扫描的</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">//全局变量，不用重复计算</span>
    <span class="token keyword">int</span> row <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> col <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> direction<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//方向上、左、下、右</span>

<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        row <span class="token operator">=</span> board<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//行数</span>
        col <span class="token operator">=</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//列数</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>x <span class="token operator">&lt;</span> row<span class="token punctuation">;</span><span class="token operator">++</span>x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token comment">//第一层遍历</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>y <span class="token operator">&lt;</span> col<span class="token punctuation">;</span><span class="token operator">++</span>y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token comment">//第二层遍历</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">==</span><span class="token number">0</span><span class="token operator">||</span>x<span class="token operator">==</span>row<span class="token operator">-</span><span class="token number">1</span><span class="token operator">||</span>y<span class="token operator">==</span><span class="token number">0</span><span class="token operator">||</span>y<span class="token operator">==</span>col<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'O'</span><span class="token punctuation">)</span>
                    <span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span><span class="token comment">//end y</span>
        <span class="token punctuation">&#125;</span><span class="token comment">//end x</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>x <span class="token operator">&lt;</span> row<span class="token punctuation">;</span><span class="token operator">++</span>x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token comment">//第一层遍历</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>y <span class="token operator">&lt;</span> col<span class="token punctuation">;</span><span class="token operator">++</span>y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token comment">//第二层遍历</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'B'</span><span class="token punctuation">)</span>
                    board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'O'</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'O'</span><span class="token punctuation">)</span>
                    board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'X'</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span><span class="token comment">//end y</span>
        <span class="token punctuation">&#125;</span><span class="token comment">//end x</span>

    <span class="token punctuation">&#125;</span>

    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token comment">//是O的话就标记为B</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">||</span>x<span class="token operator">></span>row<span class="token operator">-</span><span class="token number">1</span><span class="token operator">||</span>y<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">||</span>y<span class="token operator">></span>col<span class="token operator">-</span><span class="token number">1</span><span class="token operator">||</span>board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'O'</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        
        <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'O'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'B'</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">//从边界往里面扩展，标记为B</span>
        <span class="token keyword">int</span> x_next<span class="token punctuation">;</span>
        <span class="token keyword">int</span> y_next<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token comment">//往不同方向搜索</span>
            x_next<span class="token operator">=</span>x<span class="token operator">+</span>direction<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            y_next<span class="token operator">=</span>y<span class="token operator">+</span>direction<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

            <span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span>x_next<span class="token punctuation">,</span>y_next<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>时间复杂度为O(M*N)，M为平面行数，N为平面列数，深度优先搜索过程中，每一个点至多只会被标记一次。</p>
<p>空间复杂度为O(M*N)，主要为深度优先搜索的栈的开销。</p>
<hr>
<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><p>顾名思义， 分治问题由“分”（divide）和“治”（conquer）两部分组成，通过把原问题分为子问题，再将子问题进行处理合并，从而实现对原问题的求解。  </p>
<p>归并排序就是典型的分治问题，其中“分”即为把大数组平均分成两个小数组，通过递归实现，最终我们会得到多个长度为 1 的子数组;“治”即为把已经排好序的两个小数组合成为一个排好序的大数组，从长度为 1 的子数组开始，最终合成一个大数组。  </p>
<p>我们也使用数学表达式来表示这个过程。定义 T(n) 表示处理一个长度为 n 的数组的时间复杂度，则归并排序的时间复杂度递推公式为 T(n) = 2T(n/2) + O(n)。其中 2T(n/2) 表示我们分成了两个长度减半的子问题， O(n) 则为合并两个长度为 n/2 数组的时间复杂度。那么怎么利用这个递推公式得到最终的时间复杂度呢？这里我们可以利用著名的主定理（Master theorem）求解：</p>
<p>定理 8.1. 主定理</p>
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210804175401668.png" alt="image-20210804175401668" style="zoom:80%;" />

<p>通过主定理我们可以知道，归并排序属于第二种情况，且时间复杂度为 O(n log n)。其他的分治问题也可以通过主定理求得时间复杂度  </p>
<h2 id="241-为运算表达式设计优先级-—（中等）"><a href="#241-为运算表达式设计优先级-—（中等）" class="headerlink" title="241. 为运算表达式设计优先级  —（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/">241. 为运算表达式设计优先级</a>  —（中等）</h2><p>给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 ×。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: “2-1-1”<br>输出: [0, 2]<br>解释:<br>((2-1)-1) = 0<br>(2-(1-1)) = 2</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: “2×3-4×5”<br>输出: [-34, -14, -10, -10, 10]<br>解释:<br>(2×(3-(4×5))) = -34<br>((2×3)-(4×5)) = -14<br>((2×(3-4))×5) = -10<br>(2×((3-4)×5)) = -10<br>(((2×3)-4)×5) = 10</p>
</blockquote>
<p>此题一看是挺复杂的，但是我们慢慢来分析，由示例的括号可以看出，每次的括号出现都是在符号出现的前后，因此我们可以通过这些符号递归下手，遇到符号就分开两个数，然后进行计算结果，最后层层递归得到最终答案</p>
<p>以 2 * 3 - 4 * 5 为例。</p>
<p>2 和 3 - 4 * 5 两部分，中间是 * 号相连。</p>
<p>2 * 3 和 4 * 5 两部分，中间是 - 号相连。</p>
<p>2 * 3 - 4 和 5 两部分，中间是 * 号相连。</p>
<p>有了两部分的结果，然后再通过中间的符号两两计算加入到最终的结果中即可。</p>
<p>比如第一种情况，2 和 3 - 4 * 5 两部分，中间是 * 号相连。</p>
<p>2 的解就是 [2]，3 - 4 * 5 的解就是 [-5, -17]。</p>
<p>把两部分解通过 * 号计算，最终结果就是 [-10, -34]。</p>
<p>另外两种情况也类似。</p>
<p>然后还需要递归出口。</p>
<p>如果给定的字符串只有数字，没有运算符，那结果就是给定的字符串转为数字，这个就要作为递归出口的条件</p>
<p>比如上边的第一种情况，2 的解就是 [2]。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">diffWaysToCompute</span><span class="token punctuation">(</span>string expression<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> sLen <span class="token operator">=</span> expression<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>sLen<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ways<span class="token punctuation">;</span><span class="token comment">//最终返回的答案</span>
        
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>sLen<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token comment">//从第一位开始遍历</span>
            <span class="token keyword">char</span> currentChar <span class="token operator">=</span> expression<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//当前遍历到的字符串</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>currentChar <span class="token operator">==</span> <span class="token string">'+'</span><span class="token operator">||</span>currentChar <span class="token operator">==</span> <span class="token string">'-'</span><span class="token operator">||</span>currentChar <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token comment">//如果当前字符是有效运算符号的话</span>
                vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> left <span class="token operator">=</span> <span class="token function">diffWaysToCompute</span><span class="token punctuation">(</span>expression<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归符号前面的</span>
                vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> right <span class="token operator">=</span> <span class="token function">diffWaysToCompute</span><span class="token punctuation">(</span>expression<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归符号后边的</span>

                <span class="token comment">//cout&lt;&lt;"size: "&lt;&lt;left.size()&lt;&lt;" "&lt;&lt;right.size()&lt;&lt;endl;</span>

                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> l <span class="token operator">:</span> left<span class="token punctuation">)</span>
                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> r <span class="token operator">:</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                        <span class="token comment">//cout&lt;&lt;"num: "&lt;&lt;l&lt;&lt;" "&lt;&lt;r&lt;&lt;endl;</span>
                        <span class="token keyword">switch</span><span class="token punctuation">(</span>currentChar<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                            <span class="token keyword">case</span> <span class="token string">'+'</span><span class="token operator">:</span>ways<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>
                            <span class="token keyword">case</span> <span class="token string">'-'</span><span class="token operator">:</span>ways<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>l<span class="token operator">-</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>
                            <span class="token keyword">case</span> <span class="token string">'*'</span><span class="token operator">:</span>ways<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>l<span class="token operator">*</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>
                        <span class="token punctuation">&#125;</span>
                    <span class="token punctuation">&#125;</span>

            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span>ways<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            ways<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">stoi</span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> ways<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>写完这个之后可以发现，在递归过程中有许多数据进行了重复计算，这时候就可以加一个记忆表来记录每次计算的结果以便后面直接获得而不是再次计算</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*
动态规划
    首先将字符串中的数字和操作符分别存储下来
    第i个操作符对应的数字是i和i+1，同理第i个数的前面的操作符是i-1，后面的一个是i（i表示在数组中的序号）
    dp[i][j]表示从第i个数字到第j个数字的所有情况
        （1）i==j
            等于数字本身的值
        （2）i != j(j肯定是大于i的) 
            将i-j分成两个式子来看，[i,i]op[i+1,j],[i,i+1]op[i+2,j]...[[i,j-1]]op[j,j]
            将上面的所有情况全部组合起来
            现在需要考虑一个问题是[i,i+k]op[i+k+1,j]的op应该是ops数组里面的哪一个，应该是ops[i+k]
    有了以上，我们就可以写出动态规划了，还有一个需要注意的地方是，（2）情况也就是一个遍历，但是遍历的顺序需要注意，不应该是[0,j]->[j-1,j]而应该是[j-1,j]->[0->j]。如果是从[0,j]开始，你会发现[1,j]..[j-1,j]这些你需要的都还没算
*/</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">diffWaysToCompute</span><span class="token punctuation">(</span>string input<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> ops<span class="token punctuation">;</span>
        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> input<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isOp</span><span class="token punctuation">(</span>input<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                nums<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
                ops<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>input<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span>
                num <span class="token operator">=</span> num <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> input<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        nums<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i<span class="token punctuation">;</span> k <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> r1 <span class="token operator">:</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> r2 <span class="token operator">:</span> dp<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">calculate</span><span class="token punctuation">(</span>r1<span class="token punctuation">,</span>ops<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span>r2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token punctuation">&#125;</span>
                    <span class="token punctuation">&#125;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">bool</span> <span class="token function">isOp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> c <span class="token operator">==</span> <span class="token string">'+'</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token string">'-'</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">int</span> <span class="token function">calculate</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> num1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> op<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> num2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>op <span class="token operator">==</span> <span class="token string">'+'</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> num1 <span class="token operator">+</span> num2<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>op <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> num1 <span class="token operator">-</span> num2<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token keyword">return</span> num1 <span class="token operator">*</span> num2<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h1 id="数学问题"><a href="#数学问题" class="headerlink" title="数学问题"></a>数学问题</h1><h2 id="最大公因数和最小公倍数公式"><a href="#最大公因数和最小公倍数公式" class="headerlink" title="最大公因数和最小公倍数公式"></a>最大公因数和最小公倍数公式</h2><p>利用辗转相除法，我们可以很方便地求得两个数的最大公因数（greatest common divisor， gcd）</p>
<p>将两个数相乘再除以最大公因数即可得到最小公倍数（least common multiple, lcm）  </p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">gcd</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> b <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> a <span class="token operator">:</span> <span class="token function">gcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a<span class="token operator">%</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">lcm</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> a <span class="token operator">*</span> b <span class="token operator">/</span> <span class="token function">gcd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>进一步地，我们也可以通过扩展欧几里得算法（extended gcd）在求得 a 和 b 最大公因数的同时，也得到它们的系数 x 和 y，从而使 ax + by = gcd(a, b)  </p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">xGCD</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> a<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">int</span> x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> gcd <span class="token operator">=</span> <span class="token function">xGCD</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a <span class="token operator">%</span> b<span class="token punctuation">,</span> x1<span class="token punctuation">,</span> y1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    x <span class="token operator">=</span> y1<span class="token punctuation">,</span> y <span class="token operator">=</span> x1 <span class="token operator">-</span> <span class="token punctuation">(</span>a <span class="token operator">/</span> b<span class="token punctuation">)</span> <span class="token operator">*</span> y1<span class="token punctuation">;</span>
    <span class="token keyword">return</span> gcd<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="204-计数质数-—（简单）"><a href="#204-计数质数-—（简单）" class="headerlink" title="204. 计数质数  —（简单）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-primes/">204. 计数质数</a>  —（简单）</h2><p>统计所有小于非负整数 <em><code>n</code></em> 的质数的数量。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：n = 10<br>输出：4<br>解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：n = 0<br>输出：0</p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入：n = 1<br>输出：0</p>
</blockquote>
<p>提示：</p>
<p><code>0 &lt;= n &lt;= 5 * 10^6</code></p>
<p>这道题主要是要知道埃拉托斯特尼筛法（Sieve of Eratosthenes，简称埃氏筛法） ，其原理是从 1 到 n 遍历，假设当前遍历到m，则把所有小于 n 的、且是 m 的倍数的整数标为和数；遍历完成后，没有被标为和数的数字即为质数   </p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">countPrimes</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">isPrime</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>isPrime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token operator">++</span>count<span class="token punctuation">;</span>
                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">;</span> i<span class="token operator">*</span>j <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                    isPrime<span class="token punctuation">[</span>i<span class="token operator">*</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> count<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们利用质数的一些性质还可以将算法优化，跳过不必要的偶数，减少时间复杂度</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">countPrimes</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">//利用质数的一些性质，我们可以进一步优化该算法。</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">prime</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> sqrtn <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> count <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//偶数一定不是质数</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> sqrtn<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//最小质因子一定小于等于开方数</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">*</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j <span class="token operator">+=</span> <span class="token number">2</span> <span class="token operator">*</span> i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">// 避免偶数和重复遍历</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                    <span class="token operator">--</span>count<span class="token punctuation">;</span>
                    prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">do</span><span class="token punctuation">&#123;</span>
                i <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> sqrtn <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>prime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 避免偶数和重复遍历</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> count<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h2 id="264-丑数-II-—（中等）"><a href="#264-丑数-II-—（中等）" class="headerlink" title="264. 丑数 II  —（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ugly-number-ii/">264. 丑数 II</a>  —（中等）</h2><p>给你一个整数 <code>n</code> ，请你找出并返回第 <code>n</code> 个 <strong>丑数</strong> 。</p>
<p><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和/或 <code>5</code> 的正整数。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：n = 10<br>输出：12<br>解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：n = 1<br>输出：1<br>解释：1 通常被视为丑数。</p>
</blockquote>
<p>提示：</p>
<p><code>1 &lt;= n &lt;= 1690</code></p>
<p>这道题主要是理解丑数是什么概念，如果从1开始自底向上计算，丑数则是一个特定的序列，每个数要么是2的倍数，要么是3的倍数或者要么是5的倍数，例如6、8都是丑数，但7、14不是，因为它们包含<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%B4%A8%E5%9B%A0%E5%AD%90/10720836">质因子</a>7。 习惯上我们把1当做是第一个丑数。</p>
<p>又例如前20个丑数为：1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36</p>
<p>理解好之后，我们就可以来看题目了，题目要求我们输出第n个丑数，n是外界传进来的参数，这里我们可以使用自底向上的方法来推算出第n个丑数</p>
<p>这里给了两种方法，一个是最小堆法，另一个则是三指针方法</p>
<h3 id="最小堆法"><a href="#最小堆法" class="headerlink" title="最小堆法"></a>最小堆法</h3><p>比较简单的解法是使用优先队列来实现最小堆：</p>
<ol>
<li>起始先将最小丑数 1 放入队列</li>
<li>每次从队列取出最小值 x，即<code>top()</code>值，然后再分别将x与2、3、5相乘得出来的答案入队</li>
<li>对步骤 2 循环多次，第 n 次出队的值即是答案</li>
</ol>
<p>同时为了防止多个相同的数入队导致索引错乱，这里另外用了个<code>set</code>来判断一个数是否入队过，如果没有则入队列</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">nthUglyNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        set<span class="token operator">&lt;</span><span class="token keyword">long</span><span class="token operator">></span> s<span class="token punctuation">;</span><span class="token comment">//集合，判断一个数是否入队过</span>
        priority_queue<span class="token operator">&lt;</span><span class="token keyword">long</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">long</span><span class="token operator">></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span><span class="token keyword">long</span><span class="token operator">>></span> q<span class="token punctuation">;</span><span class="token comment">//最小堆</span>
        
        <span class="token comment">//将1作为第一个丑数</span>
        s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">long</span> x <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> n<span class="token punctuation">)</span><span class="token comment">//推算到第n个丑数直接返回</span>
                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>x<span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> num <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> num<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span>
                <span class="token comment">//将x值分别与2,3,5相乘</span>
                <span class="token keyword">long</span> t <span class="token operator">=</span> nums<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">*</span> x<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//判断当前的数是否入队过，如果已存在则跳过</span>
                <span class="token punctuation">&#123;</span>
                    s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>时间复杂度为：O(n log n)，其中往优先队列中添加元素花费O(log n)时间</p>
<p>空间复杂度为：O(n)</p>
<h3 id="三指针法"><a href="#三指针法" class="headerlink" title="三指针法"></a>三指针法</h3><p>由于丑数序列可以自底向上推算，我们可以写出来它的推算公式</p>
<p>由质因数2推算：1×2、 2×2、3×2、4×2、5×2、6×2、8×2 ……</p>
<p>由质因数3推算：1×3、 2×3、3×3、4×3、5×3、6×3、8×3 ……</p>
<p>由质因数5推算：1×5、 2×5、3×5、4×5、5×5、6×5、8×5 ……</p>
<p>鉴于上面的公式因此我们可以用三个指针（例如：<code>p2,p3,p5</code>）分别指向质因数2、3、5它们自己的公式列</p>
<p>然后每次都将它们所指的数乘上对应的2、3或5（<code>p2 × 2</code>、<code>p3 × 3</code>、<code>p5 × 5</code>），得出的三个结果再取出最小的结果</p>
<p>之后再判断这个结果是哪几个指针乘出来的，并将该指针往前进（这一步就是为了从小到大排序，自底向上推算）</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//三指针方法</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">nthUglyNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span><span class="token operator">*</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//建立推演数组，arr[0]不用</span>
        arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//1作为第一个丑数</span>

        <span class="token keyword">int</span> p2<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>p3<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>p5<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//三指针初始化</span>
        <span class="token keyword">int</span> index<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//索引值</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>index<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span><span class="token operator">++</span>index<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> a<span class="token operator">=</span>arr<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">,</span>b<span class="token operator">=</span>arr<span class="token punctuation">[</span>p3<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">,</span>c<span class="token operator">=</span>arr<span class="token punctuation">[</span>p5<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> minNum <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token function">min</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//取三个数乘出来最小的数值</span>

            <span class="token comment">//这里不能用else if</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>minNum<span class="token operator">==</span>a<span class="token punctuation">)</span> <span class="token operator">++</span>p2<span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>minNum<span class="token operator">==</span>b<span class="token punctuation">)</span> <span class="token operator">++</span>p3<span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>minNum<span class="token operator">==</span>c<span class="token punctuation">)</span> <span class="token operator">++</span>p5<span class="token punctuation">;</span>

            arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">=</span>minNum<span class="token punctuation">;</span><span class="token comment">//赋值，这样就可以按顺序从小到大推演</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">int</span> res<span class="token operator">=</span>arr<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span>arr<span class="token punctuation">;</span>
        
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>时间复杂度为：O(n)</p>
<p>空间复杂度为：O(n)</p>
<hr>
<h2 id="313-超级丑数-—（中等）"><a href="#313-超级丑数-—（中等）" class="headerlink" title="313. 超级丑数  —（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/super-ugly-number/">313. 超级丑数</a>  —（中等）</h2><p>超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。</p>
<p>给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。</p>
<p>题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：n = 12, primes = [2,7,13,19]<br>输出：32<br>解释：给定长度为 4 的质数数组 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：n = 1, primes = [2,3,5]<br>输出：1<br>解释：1 不含质因数，因此它的所有质因数都在质数数组 primes = [2,3,5] 中。</p>
</blockquote>
<p>提示：</p>
<ul>
<li>1 &lt;= n &lt;= 106</li>
<li>1 &lt;= primes.length &lt;= 100</li>
<li>2 &lt;= primes[i] &lt;= 1000</li>
<li>题目数据 保证 primes[i] 是一个质数</li>
<li>primes 中的所有值都 互不相同 ，且按 递增顺序 排列</li>
</ul>
<p>这一题和上一题唯一不同的地方就是在于给定的质因数不固定，这一题的质因数是由外界提供的，我们仍然可以用多指针的方法来解决</p>
<p>因为给的质因数不确定，我们就用一个数组专门保存质因数指针<code>(pointers)</code>，同时用一个数组保存每一回合循环求出来的新丑数序列<code>(newUglyNum)</code>，再将它们最小的放在推算数组中，而这个推算数组实际上是动态规划，因此这里代码命名为<code>dp</code></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//思路： 1. 第 n 个超级丑数是基于 前面某一个超级丑数乘以某一个 primes[i] 得到的，基于这一递推关系，</span>
<span class="token comment">//          可以使用「动态规划」。</span>
<span class="token comment">//       2. </span>
<span class="token comment">// 时间 O（n * m） ，空间 O （n + m）</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">nthSuperUglyNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> primes<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//dp</span>
        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//第一个丑数为1</span>

        <span class="token keyword">int</span> pLen<span class="token operator">=</span>primes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//质因数序列长度</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">pointers</span><span class="token punctuation">(</span>pLen<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//记录质因数对应的指针指向</span>

        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">newUglyNum</span><span class="token punctuation">(</span>pLen<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//临时记录当前新的丑数序列</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> minNum <span class="token operator">=</span> INT_MAX<span class="token punctuation">;</span><span class="token comment">//这回合循环所求得的丑数序列中的最小值</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>pLen<span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                newUglyNum<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>pointers<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">*</span>primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//新的丑数序列=旧序列*对应的质因数</span>
                minNum <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>minNum<span class="token punctuation">,</span>newUglyNum<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>

            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> minNum<span class="token punctuation">;</span><span class="token comment">//更新dp</span>

            <span class="token comment">//更新指针序列</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>pLen<span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>newUglyNum<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>minNum<span class="token punctuation">)</span>
                    <span class="token operator">++</span>pointers<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>时间复杂度为： O（n * m），m是质因数数组长度</p>
<p>空间复杂度为：O （n + m），m是质因数数组长度</p>
<hr>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="384-打乱数组-洗牌算法-—（中等）"><a href="#384-打乱数组-洗牌算法-—（中等）" class="headerlink" title="384. 打乱数组(洗牌算法)  —（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shuffle-an-array/">384. 打乱数组</a>(洗牌算法)  —（中等）</h2><p>给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。</p>
<p>实现 Solution class:</p>
<ul>
<li>Solution(int[] nums) 使用整数数组 nums 初始化对象</li>
<li>int[] reset() 重设数组到它的初始状态并返回</li>
<li>int[] shuffle() 返回数组随机打乱后的结果</li>
</ul>
<p>示例：</p>
<blockquote>
<p>输入</p>
<p>[“Solution”, “shuffle”, “reset”, “shuffle”]<br>[[[1, 2, 3]], [], [], []]<br>输出<br>[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]</p>
<p>解释</p>
<p>Solution solution = new Solution([1, 2, 3]);<br>solution.shuffle();    // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2]<br>solution.reset();      // 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3]<br>solution.shuffle();    // 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2]</p>
</blockquote>
<p>提示：</p>
<ul>
<li>1 &lt;= nums.length &lt;= 200</li>
<li>-106 &lt;= nums[i] &lt;= 106</li>
<li>nums 中的所有元素都是 唯一的</li>
<li>最多可以调用 5 * 104 次 reset 和 shuffle</li>
</ul>
<p>这一题主要是了解一个经典的算法——<strong>Fisher-Yates 洗牌算法</strong>，其原理就像我们平时打牌时洗牌方法一样，通过随机交换位置来实现随机打乱，同时该算法又有正向和反向区分</p>
<p>我这里用的是反向洗牌，简单来说就是从数组最后一个元素开始往前洗牌，每一次将当前遍历到的元素与前面随机一个元素交换，直到遍历完就是反向洗牌了</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> myVec<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Solution</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token operator">-></span>myVec<span class="token operator">=</span>nums<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token comment">/** Resets the array to its original configuration and return it. */</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> myVec<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token comment">/** Returns a random shuffling of the array. */</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">shuffle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">arr</span><span class="token punctuation">(</span>myVec<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 可以使用反向或者正向洗牌， 效果相同。</span>
        <span class="token comment">// 反向洗牌：</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>myVec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// 正向洗牌：</span>
        <span class="token comment">// for (int i = 0; i &lt; n; ++i) &#123;</span>
        <span class="token comment">// int pos = rand() % (n - i);</span>
        <span class="token comment">// swap(shuffled[i], shuffled[i+pos]);</span>
        <span class="token comment">// &#125;</span>
        
        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Your Solution object will be instantiated and called as such:
 * Solution* obj = new Solution(nums);
 * vector&lt;int> param_1 = obj->reset();
 * vector&lt;int> param_2 = obj->shuffle();
 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>时间复杂度为：O(N)</p>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Sakura.</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://sakura-pub.ltd/LeetCode/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%9C%9F/">http://sakura-pub.ltd/LeetCode/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%9C%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/LeetCode/">LeetCode</a></div><div class="post_share"><div class="social-share" data-image="https://p6-tt.byteimg.com/origin/pgc-image/2082d6b2afed4da6a0720e50564c352d.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/UnityNotes/Unity%E7%AC%94%E8%AE%B012-%E5%AE%9E%E7%8E%B0%E6%94%BB%E5%87%BB%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"><img class="prev-cover" src="https://p5-tt.byteimg.com/origin/pgc-image/88440939f5104b9f99a1e0240b00314e.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Unity笔记12-实现攻击数值计算</div></div></a></div><div class="next-post pull-right"><a href="/UnityNotes/Unity%E7%AC%94%E8%AE%B011-%E6%B7%BB%E5%8A%A0%E6%94%BB%E5%87%BB%E5%B1%9E%E6%80%A7/"><img class="next-cover" src="https://p26-tt.byteimg.com/origin/pgc-image/d1773cbd3a0d45688d6eda5b6dcf8f7a.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Unity笔记11-添加攻击属性</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/LeetCode/周赛笔记/LeetCode周赛254场/" title="LeetCode周赛254场"><img class="cover" src="https://i.loli.net/2021/08/02/tsEZIWeKMPnbULx.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-15</div><div class="title">LeetCode周赛254场</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://p6-tt.byteimg.com/origin/pgc-image/bef029045c8e4b85a41b875bfa6aaad5.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Sakura.</div><div class="author-info__description">升起的烟花,从下面看?还是从侧面看?</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">33</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">4</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/KiritoZz6"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/KiritoZz6" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/sakura_zz@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">欢迎来到我的个人博客！如果对文章有问题或者发现错误可以发邮件给我，Email：sakura_zz@163.com</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%9C%9F"><span class="toc-number">1.</span> <span class="toc-text">LeetCode刷题笔记第一期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83"><span class="toc-number">2.</span> <span class="toc-text">贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83"><span class="toc-number">2.1.</span> <span class="toc-text">452.用最少数量的箭引爆气球</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4"><span class="toc-number">2.2.</span> <span class="toc-text">763. 划分字母区间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">3.</span> <span class="toc-text">双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E2%80%94%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">88. 合并两个有序数组—（简单）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II%E2%80%94%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">142. 环形链表 II—（中等）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2%E2%80%94%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">76. 最小覆盖子串—（困难）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#524-%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D%E2%80%94%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="toc-number">3.4.</span> <span class="toc-text">524. 通过删除字母匹配到字典里最长单词—（中等）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">二分法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#154-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-II%E2%80%94%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">154. 寻找旋转排序数组中的最小值 II—（困难）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#540-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0%E2%80%94%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">540. 有序数组中的单一元素—（中等）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%E2%80%94%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">215. 数组中的第K个最大元素—（中等）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2"><span class="toc-number">6.</span> <span class="toc-text">搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#934-%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5%E2%80%94%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="toc-number">6.1.</span> <span class="toc-text">934. 最短的桥—（中等）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#126-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-II-%E2%80%94%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">126. 单词接龙 II  —（困难）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F-%E2%80%94%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">130. 被围绕的区域  —（中等）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">分治法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#241-%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7-%E2%80%94%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="toc-number">7.1.</span> <span class="toc-text">241. 为运算表达式设计优先级  —（中等）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98"><span class="toc-number">8.</span> <span class="toc-text">数学问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%E5%85%AC%E5%BC%8F"><span class="toc-number">8.1.</span> <span class="toc-text">最大公因数和最小公倍数公式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0-%E2%80%94%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="toc-number">8.2.</span> <span class="toc-text">204. 计数质数  —（简单）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#264-%E4%B8%91%E6%95%B0-II-%E2%80%94%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="toc-number">8.3.</span> <span class="toc-text">264. 丑数 II  —（中等）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%A0%86%E6%B3%95"><span class="toc-number">8.3.1.</span> <span class="toc-text">最小堆法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%8C%87%E9%92%88%E6%B3%95"><span class="toc-number">8.3.2.</span> <span class="toc-text">三指针法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#313-%E8%B6%85%E7%BA%A7%E4%B8%91%E6%95%B0-%E2%80%94%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="toc-number">8.4.</span> <span class="toc-text">313. 超级丑数  —（中等）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">8.4.0.1.</span> <span class="toc-text"></span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#384-%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84-%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95-%E2%80%94%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="toc-number">8.5.</span> <span class="toc-text">384. 打乱数组(洗牌算法)  —（中等）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/LeetCode/%E5%91%A8%E8%B5%9B%E7%AC%94%E8%AE%B0/LeetCode%E5%91%A8%E8%B5%9B254%E5%9C%BA/" title="LeetCode周赛254场">LeetCode周赛254场</a><time datetime="2021-08-15T15:51:40.000Z" title="Created 2021-08-15 23:51:40">2021-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/UnityNotes/Unity%E7%AC%94%E8%AE%B030-%E6%B8%90%E5%85%A5%E6%B8%90%E5%87%BA%E6%95%88%E6%9E%9C/" title="Unity笔记30-渐入渐出效果"><img src="https://i.loli.net/2021/08/06/xCTZtRhKYlkzDFB.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity笔记30-渐入渐出效果"/></a><div class="content"><a class="title" href="/UnityNotes/Unity%E7%AC%94%E8%AE%B030-%E6%B8%90%E5%85%A5%E6%B8%90%E5%87%BA%E6%95%88%E6%9E%9C/" title="Unity笔记30-渐入渐出效果">Unity笔记30-渐入渐出效果</a><time datetime="2021-08-06T00:43:07.000Z" title="Created 2021-08-06 08:43:07">2021-08-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/UnityNotes/Unity%E7%AC%94%E8%AE%B029-%E5%88%B6%E4%BD%9C%E4%B8%BB%E8%8F%9C%E5%8D%95%E7%95%8C%E9%9D%A2/" title="Unity笔记29-制作主菜单界面"><img src="https://i.loli.net/2021/08/05/jJ7nGsCeUh4EFig.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity笔记29-制作主菜单界面"/></a><div class="content"><a class="title" href="/UnityNotes/Unity%E7%AC%94%E8%AE%B029-%E5%88%B6%E4%BD%9C%E4%B8%BB%E8%8F%9C%E5%8D%95%E7%95%8C%E9%9D%A2/" title="Unity笔记29-制作主菜单界面">Unity笔记29-制作主菜单界面</a><time datetime="2021-08-05T01:15:59.000Z" title="Created 2021-08-05 09:15:59">2021-08-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/UnityNotes/Unity%E7%AC%94%E8%AE%B028-%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE/" title="Unity笔记28-保存数据"><img src="https://i.loli.net/2021/08/04/CvksVunfJhgyqWz.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity笔记28-保存数据"/></a><div class="content"><a class="title" href="/UnityNotes/Unity%E7%AC%94%E8%AE%B028-%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE/" title="Unity笔记28-保存数据">Unity笔记28-保存数据</a><time datetime="2021-08-04T01:32:04.000Z" title="Created 2021-08-04 09:32:04">2021-08-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/UnityNotes/Unity%E7%AC%94%E8%AE%B027-%E4%B8%8D%E5%90%8C%E5%9C%BA%E6%99%AF%E7%9A%84%E4%BC%A0%E9%80%81/" title="Unity笔记27-不同场景的传送"><img src="https://i.loli.net/2021/08/03/gwjJXfpr3KmW9DQ.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity笔记27-不同场景的传送"/></a><div class="content"><a class="title" href="/UnityNotes/Unity%E7%AC%94%E8%AE%B027-%E4%B8%8D%E5%90%8C%E5%9C%BA%E6%99%AF%E7%9A%84%E4%BC%A0%E9%80%81/" title="Unity笔记27-不同场景的传送">Unity笔记27-不同场景的传送</a><time datetime="2021-08-03T01:05:23.000Z" title="Created 2021-08-03 09:05:23">2021-08-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Sakura.</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'uoCtAtvANzWpqnPNGCNRPK7g-gzGzoHsz',
      appKey: 'NIjj8lYmojE9cbwXtTlGUh6F',
      placeholder: '记得留下你的昵称和邮箱....可以快速收到回复',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer src="/live2d-widget/autoload.js"></script><script src="/cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>