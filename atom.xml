<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>🌸樱花酒吧🍻</title>
  
  <subtitle>🌸Sakura-Pub🍻</subtitle>
  <link href="http://sakura-pub.ltd/atom.xml" rel="self"/>
  
  <link href="http://sakura-pub.ltd/"/>
  <updated>2021-06-22T13:55:39.247Z</updated>
  <id>http://sakura-pub.ltd/</id>
  
  <author>
    <name>Sakura.</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unity笔记7--修改相机移动视角以及进一步完善敌人</title>
    <link href="http://sakura-pub.ltd/UnityNotes/Unity%E7%AC%94%E8%AE%B07-%E4%BF%AE%E6%94%B9%E7%9B%B8%E6%9C%BA%E7%A7%BB%E5%8A%A8%E8%A7%86%E8%A7%92%E4%BB%A5%E5%8F%8A%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%AE%8C%E5%96%84%E6%95%8C%E4%BA%BA/"/>
    <id>http://sakura-pub.ltd/UnityNotes/Unity%E7%AC%94%E8%AE%B07-%E4%BF%AE%E6%94%B9%E7%9B%B8%E6%9C%BA%E7%A7%BB%E5%8A%A8%E8%A7%86%E8%A7%92%E4%BB%A5%E5%8F%8A%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%AE%8C%E5%96%84%E6%95%8C%E4%BA%BA/</id>
    <published>2021-06-22T05:06:02.000Z</published>
    <updated>2021-06-22T13:55:39.247Z</updated>
    
    <content type="html"><![CDATA[<p>​    这一章我们将对项目做一些调整，包括：设置自由移动视角的相机、检测人物是否到达敌人附近、切换到追击模式等。以后我们可能会多次在项目开发途中停下来做一些小小的优化之类的，这些都是很有必要的。</p><h1 id="将相机改成可自由移动视角"><a href="#将相机改成可自由移动视角" class="headerlink" title="将相机改成可自由移动视角"></a>将相机改成可自由移动视角</h1><p>​    到目前为止我们的相机虽然都是可以跟随人物移动的，但是它视角是固定的，不能自由地去移动视角。如果你想更改成自由视角的相机的话，那么就现在来实现吧！</p><p>​    这里最主要的就是将<code>Cinemachine</code>插件中的<code>Virtual Camera</code>换成<code>FreeLook Camera</code></p><p>​    因此我们选择原来创建的<code>Virtual Camera</code>，然后将它关闭（如果你已经决定不想使用可以直接删除），具体关闭方法就是取消下图所示的勾勾</p><img src="https://p5.toutiaoimg.com/origin/pgc-image/be709270a95a408ca723e83e24f0df33.png" alt="1.png" style="zoom:80%;" /><p>​    凡是关闭后的对象在列表中都会变成淡灰色的</p><img src="https://p26.toutiaoimg.com/origin/pgc-image/076433cd57354d968359194bacc2c638.png" alt="2.png" style="zoom:80%;" /><p>​    之后我们再选中主摄像机，<code>Main Camera</code>，在Unity上方菜单中选择<code>Cinemachine</code>插件列表菜单项👉之后再选择如图第二个选项<code>FreeLook Camera</code></p><img src="https://p3.toutiaoimg.com/origin/pgc-image/487625f3bdce4f8db3115e37d2e53046.png" alt="3.png" style="zoom:80%;" /><p>​    创建完毕后，我们将新的相机和旧的相机都命名一下，防止搞混。</p><p>​    我们同样要来选择一下相机的跟踪对象和观察对象，我们把控制人物<code>Player</code>拖进去</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/586146b0a6ab4820958b1903848901a8.png" alt="4.png" style="zoom:80%;" /><p>​    我们在窗口中可以看到摄像机旁边有上中下三个红色圈圈，同时还有一条弧线包裹住它们，这是代表着我们相机可以在这三个维度里面自由旋转切换摄像机角度，同时可以进行上下角度的切换，我们可以根据喜好来调整这几个圈圈</p><img src="https://p26.toutiaoimg.com/origin/pgc-image/7dacd6ce8f324399aa660d3d593e8e2c.png" alt="5.png" style="zoom:80%;" /><p>​    然后就是如何来控制摄像机移动了，我们在<code>FreeLook Camera</code>的属性面板中可以看到有个<code>Axis Control</code>的项，在这里我们可以看到控制Y轴移动的是<code>Mouse Y</code>，控制X轴移动的是<code>Mouse X</code>，即默认情况是鼠标移动来控制，我们可以在此修改它</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/d5c98a365df147d79a90ce4fa823e67e.png" alt="6.png" style="zoom:80%;" /><p>​    我们打开<code>Project Setting...</code>，里面有个<code>Input Manager</code>，在这里就可以修改具体关于<code>Axis</code>按键的设置</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/3d0286059bc547ccabd4c79efcf82bef.png" alt="7.png" style="zoom:80%;" /><p>​    在Mouse Y下面有一个<code>Mouse ScrollWheel</code>，这个就是鼠标的滚轮，可以利用这个来进行视角的拉远和拉近</p><p>​    还有一个<code>Horizontal</code>的选项，这个可以来控制视角左右移动，并且它可以利用我们提供的自定义按键，如：A和D，只需要在<code>Negative Button</code>和<code>Positive Button</code>分别填入你想要的按键</p><img src="https://p5.toutiaoimg.com/origin/pgc-image/20c6e5d985d34974b7e52ecdafb2ff24.png" alt="8.png" style="zoom:80%;" /><p>​    自定义好按键之后，我们要把具体的<code>Axes</code>名称复制到摄像机属性面板中，如果测试的时候发现视角移动是反向的可以把<code>Invert</code>可选框的勾勾去掉，转向速度太慢可以修改<code>Speed</code>里的数值</p><p>​    🎈在调试之前可以把<code>Save During Play</code>选上，这样便可以点<code>Game</code>游玩时边玩边调整，并且修改的数据可以保存下来</p><img src="https://p26.toutiaoimg.com/origin/pgc-image/1dd06a7a2f0e49d39f3622ffa4bead06.png" alt="9.png" style="zoom:80%;" /><p>​    这样，我们的摄像机视角控制就自定义好了</p><p>​    如果发现摄像机离人物太近，我们可以修改以下的参数</p><p>​    <code>Orbits</code>项分别有三个<code>Rig</code>的修改参数框，我们可以在这修改</p><img src="https://p3.toutiaoimg.com/origin/pgc-image/54045622e4a64873846e612a7e679804.png" alt="10.png" style="zoom:80%;" /><p>​    这里我的参数修改如下</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/eeb5b826c51240e3bcf20c7f1ae81ac3.png" alt="11.png" style="zoom:80%;" /><p>​    到这我们的自由视角相机就设置好了</p><h1 id="检测人物是否在敌人附近"><a href="#检测人物是否在敌人附近" class="headerlink" title="检测人物是否在敌人附近"></a>检测人物是否在敌人附近</h1><p>​    接下来我们来实现让敌人检测人物是否在它自身的附近</p><p>​    我们打开之前已经写了一点框架的<code>EnemyController.cs</code>代码文件，先修改一下前面声明的<code>enemyStates</code>，将其改为<code>private</code>，因为这个敌人状态是靠后面代码自动改变的，不需要手动来弄，没有必要设成public</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">private</span> <span class="token class-name">EnemyStates</span> enemyStates<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    </p><p>​    然后我们可以弄一个变量，表示敌人的可视范围</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Header</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">"Basic Settings"</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span><span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">float</span></span> sightRadius<span class="token punctuation">;</span><span class="token comment">//敌人的可视范围</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    这里我用了一个<code>[Header(&quot;Basic Settings&quot;)]</code>，这样做可以在对象的属性面板有一个划分的作用，以后我们都可以这样来划分一些代码公开给外界的设置项👇</p><img src="https://p26.toutiaoimg.com/origin/pgc-image/6c60b7836bf74b1fb0671f9c2af7253f.png" alt="12.png" style="zoom:80%;" /><p>​    然后就到了我们关键的一个部分，写一个检测敌人附近是否有人物的函数，这里是利用了 <a href="https://docs.unity3d.com/ScriptReference/Physics.OverlapSphere.html">Physics.OverlapSphere</a> 的方法，这个函数检测了一个球体范围内是否有碰撞体，因此我们可以为人物添加一个碰撞体再结合这个方法来实现</p><p>​    我们先来写实现代码</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token return-type class-name"><span class="token keyword">bool</span></span> <span class="token function">FoundPlayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">Collider<span class="token punctuation">[</span><span class="token punctuation">]</span></span> colliders <span class="token operator">=</span> Physics<span class="token punctuation">.</span><span class="token function">OverlapSphere</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">,</span>sightRadius<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//接受一个圆点，一个半径的参数，返回的是碰撞体数组</span>        <span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token class-name">Collider</span> target <span class="token keyword">in</span> colliders<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//循环碰撞体数组，逐个查找</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">CompareTag</span><span class="token punctuation">(</span><span class="token string">"Player"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//当前循环到的碰撞体的标签为Player就代表找到人物了</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    因为<code>OverlapSphere</code>返回的是碰撞体数组，我们之后只要在这数组中遍历查找是否有标签为<code>Player</code>的对象就行了</p><p>​    然后修改一下之前的<code>SwitchEnemyStates</code>函数</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SwitchEnemyStates</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//如果发现player 切换到CHASE</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">FoundPlayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            enemyStates <span class="token operator">=</span> EnemyStates<span class="token punctuation">.</span>CHASE<span class="token punctuation">;</span>            Debug<span class="token punctuation">.</span><span class="token function">LogFormat</span><span class="token punctuation">(</span><span class="token string">"敌人&#123;0&#125;发现了玩家"</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//测试代码</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">switch</span><span class="token punctuation">(</span>enemyStates<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">case</span> EnemyStates<span class="token punctuation">.</span>GUARD<span class="token punctuation">:</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> EnemyStates<span class="token punctuation">.</span>PATROL<span class="token punctuation">:</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> EnemyStates<span class="token punctuation">.</span>CHASE<span class="token punctuation">:</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> EnemyStates<span class="token punctuation">.</span>DEAD<span class="token punctuation">:</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    写完代码后别忘了我们要为人物添加一个碰撞体，这里我选用的就是胶囊碰撞体<code>Capsule Collider</code>，然后调整一下胶囊的大小</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/31bf56dfd4ae4f998acbbc3320e577de.png" alt="13.png" style="zoom:80%;" /><img src="https://p3.toutiaoimg.com/origin/pgc-image/12273ccf82704bbdb3a69d8ff64a940c.png" alt="15.png" style="zoom:80%;" /><p>​    最后再把人物的标签设为<code>Player</code>，然后把之前设的公开变量<code>Sight Radius</code>视野范围赋予一个值</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/5fa32863fb39401ba974cd2e18443420.png" alt="14.png" style="zoom:80%;" /><img src="https://p3.toutiaoimg.com/origin/pgc-image/3892abc4f74f4700b0078adcbe3aa7ac.png" alt="16.png" style="zoom:80%;" /><p>​    这样我们就完成了敌人范围检测人物的功能了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​    这一章我们将对项目做一些调整，包括：设置自由移动视角的相机、检测人物是否到达敌人附近、切换到追击模式等。以后我们可能会多次在项目开发途中停下来做一些小小的优化之类的，这些都是很有必要的。&lt;/p&gt;
&lt;h1 id=&quot;将相机改成可自由移动视角&quot;&gt;&lt;a href=&quot;#将相</summary>
      
    
    
    
    <category term="Unity学习笔记" scheme="http://sakura-pub.ltd/categories/Unity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Unity" scheme="http://sakura-pub.ltd/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity笔记6-创建敌人</title>
    <link href="http://sakura-pub.ltd/UnityNotes/Unity%E7%AC%94%E8%AE%B06-%E5%88%9B%E5%BB%BA%E6%95%8C%E4%BA%BA/"/>
    <id>http://sakura-pub.ltd/UnityNotes/Unity%E7%AC%94%E8%AE%B06-%E5%88%9B%E5%BB%BA%E6%95%8C%E4%BA%BA/</id>
    <published>2021-06-15T13:02:24.000Z</published>
    <updated>2021-06-20T08:54:00.425Z</updated>
    
    <content type="html"><![CDATA[<p>​     在本章节中，我们来学习如何创建我们的第一个敌人并添加一些关于移向敌人的代码和攻击动画，从而使我们的游戏更加完善</p><h1 id="下载并安装敌人素材"><a href="#下载并安装敌人素材" class="headerlink" title="下载并安装敌人素材"></a>下载并安装敌人素材</h1><p>​    我们今天要下载的敌人素材名字是<strong>RPG Monster Duo PBR Polyart</strong>，大家可以去 Assert Store 上下载下来</p><img src="https://p26.toutiaoimg.com/origin/pgc-image/06c4964d32aa45fa89ebb17df55275cf.jpg" alt="1.1.jpg" style="zoom:80%;" /><p>​    同样的，下载完后我们选择 <code>Import</code> 加载进我们的项目里，再把新素材的文件夹分类放好</p><p>​    我们可以预览一下刚下好的素材，但是发现是没有贴图的，这是因为我们还没把素材升级到URP，我们将素材升级一下就可以显示正常了，还记得如何将素材升级URP吗？不记得的话可以翻看前面的文章哦</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/9190e65818cf49a5ba851b0aabec2db9.png" alt="2.png" style="zoom:80%;" /><h1 id="布置并设置敌人的基本属性和状态"><a href="#布置并设置敌人的基本属性和状态" class="headerlink" title="布置并设置敌人的基本属性和状态"></a>布置并设置敌人的基本属性和状态</h1><h2 id="使用代码约束的方式来添加组件"><a href="#使用代码约束的方式来添加组件" class="headerlink" title="使用代码约束的方式来添加组件"></a>使用代码约束的方式来添加组件</h2><p>安装好敌人素材后，我们就可以把敌人拖到地图中了，将它放到你喜欢的位置之后，就可以着手来修改一下它的基本属性了</p><p>​    从这里开始我们要长远考虑，我们以后需要添加的敌人会有很多，而这些敌人都需要挂载一些相同的组件，我们需要有一种更好的方法来为以后敌人一键添加这些组件，而不是一个一个来添加，那么我们就开始吧</p><p>​    首先在下图的<code>Scripts👉Charcters</code>文件夹位置新建一个 C# 代码文件，可以命名为 <strong>EnemyController</strong>，然后打开编辑</p><img src="https://p5.toutiaoimg.com/origin/pgc-image/30321fb536f94b068f6b998b8e2b663e.png" alt="3.png" style="zoom:80%;" /><p>​    这个时候我们就可以来想一下，我们一般敌人需要哪些组件呢？首先想到的是智能导航 <code>NavMeshAgent</code>，那我们要确保它敌人对象肯定挂载这个组件的话，我们可以使用以下代码来约束它</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">using</span> <span class="token namespace">UnityEngine<span class="token punctuation">.</span>AI</span><span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">RequireComponent</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">NavMeshAgent</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    把<code>[RequireComponent()]</code>这一个约束句子放在代码文件开头的位置，就可以实现当你把代码作为一个组件添加到敌人或其它Unity对象中时，自动添加给约束的组件了</p><p>​    按上面代码来举栗子，当我把包含上面代码的文件作为组件添加到我们的敌人中时，会自动附带一个<code>NavMeshAgent</code>组件了</p><img src="https://p3.toutiaoimg.com/origin/pgc-image/ff7fb226a3524c7e8aec1e566b2a0e43.png" alt="4.png" style="zoom:80%;" /><p>​    而且当你试图删除<code>NavMeshAgent</code>组件时Unity还会发出警告提示不能删除</p><img src="https://p9.toutiaoimg.com/origin/pgc-image/85dda0a8a4a2418cb95ff0402e2a5292.png" alt="5.png" style="zoom:80%;" /><p>​    所以当你的代码需要用到一定的组件在多个物体上，你就可以运用这种方式来确保你的物体包含了这些组件，以致于你的代码能够正常运行</p><p>​    到这里，我们就可以在<code>Awake()</code>函数里面获取我们的组件了</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">using</span> <span class="token namespace">UnityEngine</span><span class="token punctuation">;</span><span class="token keyword">using</span> <span class="token namespace">UnityEngine<span class="token punctuation">.</span>AI</span><span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">RequireComponent</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">NavMeshAgent</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnemyController</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MonoBehaviour</span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">NavMeshAgent</span> agent<span class="token punctuation">;</span>    <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Awake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        agent <span class="token operator">=</span> <span class="token generic-method"><span class="token function">GetComponent</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>NavMeshAgent<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    </p><h2 id="设置敌人基本属性"><a href="#设置敌人基本属性" class="headerlink" title="设置敌人基本属性"></a>设置敌人基本属性</h2><p>​    接下来我们设置一下敌人的基本属性，先来看看<code>NavMeshAgent</code>的信息</p><img src="https://p9.toutiaoimg.com/origin/pgc-image/8c5a62e350ad41d689b6fd0a38cfd104.png" alt="6.png" style="zoom:80%;" /><p>​    这里我修改了一下这个敌人的速度<code>Speed</code>，因为速度太快会导致我们的主角无法摆脱战斗；同样修改了的还有转角速度<code>Angular Speed</code>和高度<code>Height</code>，这些都可以自己尝试来调整到自己喜欢的数值</p><p>​    其次，我们还要来添加一个碰撞体组件<code>Collider</code>，我们要借用这个碰撞体来判断我们鼠标的射线是否点击到了我们的敌人，如果没有碰撞体我们是没有办法来判断是否击中的。</p><p>​    我们可以根据自己喜好和需求来添加不同的碰撞体组件，我这里为了简单就使用<code>BoxCollider</code></p><img src="https://p3.toutiaoimg.com/origin/pgc-image/11640e3d6b6048f282feb4622684ece2.png" alt="7.png" style="zoom:80%;" /><p>​    添加好调整一下方体的位置，使方框刚好包含敌人</p><img src="https://p26.toutiaoimg.com/origin/pgc-image/3f63124e04c9414a94edbdfc62310fb5.png" alt="8.png" style="zoom:80%;" /><p>​    其次，我们还要调整一下我们敌人的图层，以防被其它东西挡住了看不见。</p><p>​    和之前剔除人物遮挡一样步骤，我们只需要添加一个图层并在<code>URP</code>文件中的<code>Layer Mask</code>下拉列表（可以多选）勾选我们的新图层就行了</p><img src="https://p3.toutiaoimg.com/origin/pgc-image/eb0776b3a1324e76919f62b6201061ca.png" alt="10.png" style="zoom:80%;" /><img src="https://p5.toutiaoimg.com/origin/pgc-image/c1efe22bdbce4eeb839e358479ad7702.png" alt="11.png" style="zoom:80%;" /><p>​    图层加了之后也别忘了也要新建一个<code>Enemy</code>的标签</p><h2 id="编写敌人的状态"><a href="#编写敌人的状态" class="headerlink" title="编写敌人的状态"></a>编写敌人的状态</h2><p>​    首先我们要思考一下敌人会有多少种状态呢？这里我可以先想到有：警戒、巡逻、追击主角、死亡 这四种状态，当然你也可以根据你所喜好的状态去设计</p><p>​    我们在<code>EnemyController.cs</code>代码文件中添加下面这一行枚举代码，<u>注意是打在类的外边作为全局形式</u></p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">EnemyStates</span><span class="token punctuation">&#123;</span>GUARD<span class="token punctuation">,</span>PATROL<span class="token punctuation">,</span>CHASE<span class="token punctuation">,</span>DEAD<span class="token punctuation">&#125;</span><span class="token comment">//敌人的四种状态，警戒、巡逻、追击、死亡</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    然后我们再在类中声明变量</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token class-name">EnemyStates</span> enemyStates<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    这个时候我们返回Unity中就可以在敌人对象中代码组件部分看到多了个<code>Enemy States</code>的下拉菜单了</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/09d6536220f44ff2919ed22b29442031.png" alt="9.png" style="zoom:80%;" /><p>​    这里我们可以利用较为简单的状态切换方式—Switch切换，当然还可以选择复杂点的状态机切换方式，这里暂时不使用先，打开我们的<code>EnemyController.cs</code>代码文件，写一个基本的Switch判断框架</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">SwitchEnemyStates</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SwitchEnemyStates</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span>enemyStates<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> EnemyStates<span class="token punctuation">.</span>GUARD<span class="token punctuation">:</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> EnemyStates<span class="token punctuation">.</span>PATROL<span class="token punctuation">:</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> EnemyStates<span class="token punctuation">.</span>CHASE<span class="token punctuation">:</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> EnemyStates<span class="token punctuation">.</span>DEAD<span class="token punctuation">:</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    以上的框架编写好后我们先放一边到时候再来补充</p><h1 id="添加人物移动到敌人的方法"><a href="#添加人物移动到敌人的方法" class="headerlink" title="添加人物移动到敌人的方法"></a>添加人物移动到敌人的方法</h1><h2 id="添加事件"><a href="#添加事件" class="headerlink" title="添加事件"></a>添加事件</h2><p>​    接下来又要回到我们的<code>MouseManager.cs</code>代码文件中，我们要添加一个新的事件，来代表当我们鼠标点击敌人时的事件</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">event</span> <span class="token class-name">Action<span class="token punctuation">&lt;</span>GameObject<span class="token punctuation">></span></span> OnEnemyClicked<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    这样我们事件发生的时候传递的就是<code>GameObject</code>类型，也就是我们鼠标点击的敌人了，这样做我们就可以获得更多的敌人相关信息，比如坐标、名字等</p><p>​    然后我们再把当前代码文件下的<code>MouseControl</code>函数修改一下，添加一些代码</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">MouseControl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>Input<span class="token punctuation">.</span><span class="token function">GetMouseButtonDown</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> hitInfo<span class="token punctuation">.</span>collider <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>hitInfo<span class="token punctuation">.</span>collider<span class="token punctuation">.</span><span class="token function">CompareTag</span><span class="token punctuation">(</span><span class="token string">"Ground"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            OnMouseClicked<span class="token punctuation">?.</span><span class="token function">Invoke</span><span class="token punctuation">(</span>hitInfo<span class="token punctuation">.</span>point<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>hitInfo<span class="token punctuation">.</span>collider<span class="token punctuation">.</span><span class="token function">CompareTag</span><span class="token punctuation">(</span><span class="token string">"Enemy"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            OnEnemyClicked<span class="token punctuation">?.</span><span class="token function">Invoke</span><span class="token punctuation">(</span>hitInfo<span class="token punctuation">.</span>collider<span class="token punctuation">.</span>gameObject<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//这里传递的是射线碰撞到的对象，也就是敌人了</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    接下来转到<code>PlayerController.cs</code>代码文件来配置一下角色点击到敌人的反应</p><p>​    我们在代码文件的类下添加下面的代码</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PlayerController</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MonoBehaviour</span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">GameObject</span> attactTarget<span class="token punctuation">;</span><span class="token comment">//为了编写点击敌人函数方便而声明的变量</span>    <span class="token keyword">private</span> <span class="token class-name"><span class="token keyword">float</span></span> lastAttactTime<span class="token punctuation">;</span><span class="token comment">//一个关于上一次攻击时间的变量，简单的计时器，一旦超过所给的CD时间就可以再攻击一次</span>    <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        MouseManager<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>OnMouseClicked<span class="token operator">+=</span>MoveToTarget<span class="token punctuation">;</span><span class="token comment">//普通移动</span>        MouseManager<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>OnEnemyClicked<span class="token operator">+=</span>EventAttact<span class="token punctuation">;</span><span class="token comment">//我们点击了攻击目标，即敌人</span>    <span class="token punctuation">&#125;</span>    <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">EventAttact</span><span class="token punctuation">(</span><span class="token class-name">GameObject</span> obj<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//这里就可以填写点击敌人后需要的操作了</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    </p><h2 id="利用协程的方式来写人物移向敌人"><a href="#利用协程的方式来写人物移向敌人" class="headerlink" title="利用协程的方式来写人物移向敌人"></a>利用协程的方式来写人物移向敌人</h2><p>​    那么我们就要来思考<code>EventAttact</code>在函数里要实现什么了</p><p>​    首先我们来实现小人跑到敌人的面前，这里就要判断小人是否到了可以攻击敌人的射程，如果没有到的话就要继续移动，而这就要用到<code>协程</code>的方式来实现，具体关于什么是协程大家可以自行搜寻资料</p><p>​    我们在上面代码的基础下，再写一个关于协程的函数</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Collections</span><span class="token punctuation">;</span><span class="token return-type class-name">IEnumerator</span> <span class="token function">MoveToAttackTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//这里用到的IEnumerator就是一个协程</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​    同时因为我们即将要用到上面声明过的<code>attactTarget（GameObject类型）</code>我们还要对原先的函数进行一些修改</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">EventAttact</span><span class="token punctuation">(</span><span class="token class-name">GameObject</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//如果鼠标点击的目标不为空，或者点击的敌人不是属于死亡状态</span>        attact <span class="token operator">=</span> target<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    现在我们就可以正式来编写<code>MoveToAttackTarget</code>函数了</p><p>​    因为要实现小人跑到敌人面前，那么就先要实现小人会转向我们的目标，这样我们就可以用下面这行代码</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token return-type class-name">IEnumerator</span> <span class="token function">MoveToAttackTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>transform<span class="token punctuation">.</span><span class="token function">LookAt</span><span class="token punctuation">(</span>attactTarget<span class="token punctuation">.</span>transform<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//因为这个代码文件是作为组件安在小人对象上的，因此前面this.transform获取的是小人的transform</span>    <span class="token comment">//transform自带的LookAt()函数就可以实现小人的转向</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    接着，我们可以写一个循环，当小人与敌人的距离大于所给定的<code>攻击距离</code>（这里暂时定为1，到时候可以更改，甚至可以根据武器种类不同而给定不同的值）时，小人就不断地向敌人靠近（之所以要不断循环判断，是因为敌人可能处在巡逻的状态，每一帧的位置都不一样，因此要不断更新目的地）</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token return-type class-name">IEnumerator</span> <span class="token function">MoveToAttackTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    agent<span class="token punctuation">.</span>isStopped <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//取消人物的停止状态</span>    transform<span class="token punctuation">.</span><span class="token function">LookAt</span><span class="token punctuation">(</span>attactTarget<span class="token punctuation">.</span>transform<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>Vector3<span class="token punctuation">.</span><span class="token function">Distance</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">,</span>attactTarget<span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//比较人物和敌人的距离是否大于0攻击距离，Distance()可以比较两个Vector3距离</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>agent<span class="token punctuation">.</span>destination <span class="token operator">=</span> attactTarget<span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">;</span><span class="token comment">//小人的目的地是敌人</span>        <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">//下一帧再执行循环判断</span>    <span class="token punctuation">&#125;</span>    agent<span class="token punctuation">.</span>isStopped <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">//人物到达敌人面前停下来</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    这个方法在while循环前后都用到了<code>agent.isStopped</code>，当它为<code>true</code>能够让人物停止，而<code>false</code>时代表没停止</p><p>​    打完上面的代码，我们还要回到<code>EventAttact</code>添加一句代码从而调用协程</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">EventAttact</span><span class="token punctuation">(</span><span class="token class-name">GameObject</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//如果鼠标点击的目标不为空，或者点击的敌人不是属于死亡状态</span>        attactTarget <span class="token operator">=</span> target<span class="token punctuation">;</span>        <span class="token function">StartCoroutine</span><span class="token punctuation">(</span><span class="token function">MoveToAttackTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    这样我们就可以初步实现小人向敌人移动，并在移动的时候不停地来判断是否到达攻击距离了</p><h2 id="最后的修改"><a href="#最后的修改" class="headerlink" title="最后的修改"></a>最后的修改</h2><p>​    但是我们会发现一个Bug，就是在往敌人方向移动的过程中我们是无法取消移动或移向新的目标地点的，这是因为我们在协程代码的循环并没有判断到停止指令，因此我们来完善一下</p><p>​    我们可以在移动方法<code>MoveToTarget</code>中添加代码</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">MoveToTarget</span><span class="token punctuation">(</span><span class="token class-name">Vector3</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        agent<span class="token punctuation">.</span>isStopped <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//解决攻击完后无法移动</span>        <span class="token function">StopAllCoroutines</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//停止所有的协程</span>        agent<span class="token punctuation">.</span>destination <span class="token operator">=</span> target<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    这个<code>StopAllCoroutines()</code>方法可以将所有进行中的协程停止，就可以实现当我们在移向敌人的过程中，点击了其它位置就能中断移向敌人并移动到新的目的地了</p><p>​    同时上面还有一行<code>agent.isStopped = false</code>，这是为了防止我们攻击完敌人后处于人物停止状态而导致无法移动</p><h1 id="添加一下攻击动画和攻击冷却时间"><a href="#添加一下攻击动画和攻击冷却时间" class="headerlink" title="添加一下攻击动画和攻击冷却时间"></a>添加一下攻击动画和攻击冷却时间</h1><h2 id="添加攻击敌人的动画"><a href="#添加攻击敌人的动画" class="headerlink" title="添加攻击敌人的动画"></a>添加攻击敌人的动画</h2><p>​    我们来添加一下人物攻击敌人的动画吧，打开我们人物<code>Player</code>的动画<code>Animation</code>修改动画</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/895243b835bf4d71a0f6c9eb1e871794.png" alt="12.png" style="zoom:80%;" /><p>​    先新建一个<code>Trigger</code>类型的变量，命名为<code>Attack</code></p><img src="https://p9.toutiaoimg.com/origin/pgc-image/c3199d9921284b15b414308b04f3e837.png" alt="13.png" style="zoom:80%;" /><p>​    然后我们从人物素材包中找到攻击动画，再把该动画拖出来（这里我用的是<code>Attack01</code>）</p><img src="https://p26.toutiaoimg.com/origin/pgc-image/171d1f9a693d4ce090172252c58f7825.png" alt="14.png" style="zoom:80%;" /><p>​    拖出来后我们将其重命名节点为<code>Attack Base</code>，然后与普通动作节点建立来回两条切换的线路</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/4251a0aadfe145dd8e29234f9c0cb7f4.png" alt="15.png" style="zoom:80%;" /><p>​    紧接着，我们设置一下普通动画切换到攻击动画的设置，由于我们是当<code>Attack</code>变量触发就会进入攻击动画的，因此不需要退出时间</p><img src="https://p3.toutiaoimg.com/origin/pgc-image/d09bbe1e30774774a22d75da1fa8c35d.png" alt="16.png" style="zoom:80%;" /><p>​    同时还要注意切换条件是变量<code>Attack</code>给触发就进行切换</p><img src="https://p9.toutiaoimg.com/origin/pgc-image/9e975d5f4a0140aaa81400ea62bfd6c6.png" alt="16.5.png" style="zoom:80%;" /><p>​    然后是攻击动画切换回普通动画的设置，这里我们想攻击动画播放完再切换回去，因此退出动画可以设置为1，同时过渡动画可以按自己喜好自行设置</p><img src="https://p3.toutiaoimg.com/origin/pgc-image/d09bbe1e30774774a22d75da1fa8c35d.png" alt="16.png" style="zoom:80%;" /><p>​    动画建立好后，我们的动画触发跟着冷却时间一起设置</p><h2 id="添加攻击冷却时间"><a href="#添加攻击冷却时间" class="headerlink" title="添加攻击冷却时间"></a>添加攻击冷却时间</h2><p>​    还记得前面声明的<code>lastAttactTime</code>变量吗？这里就是用到它的时候，延续着上边协程函数，我们的冷却时间代码和动画触发代码都在这里编写</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token comment">//当人物到达可以攻击敌人的距离后</span><span class="token keyword">if</span><span class="token punctuation">(</span>lastAttactTime<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    animator<span class="token punctuation">.</span><span class="token function">SetTrigger</span><span class="token punctuation">(</span><span class="token string">"Attack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//触发攻击动画</span>    lastAttactTime <span class="token operator">=</span> <span class="token number">0.5f</span><span class="token punctuation">;</span><span class="token comment">//重置冷却时间</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    把这一段代码放在原来的协程函数就变成</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token return-type class-name">IEnumerator</span> <span class="token function">MoveToAttackTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    agent<span class="token punctuation">.</span>isStopped <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    transform<span class="token punctuation">.</span><span class="token function">LookAt</span><span class="token punctuation">(</span>attactTarget<span class="token punctuation">.</span>transform<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>Vector3<span class="token punctuation">.</span><span class="token function">Distance</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">,</span>attactTarget<span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//比较人物和敌人的距离是否大于0攻击距离，Distance()可以比较两个Vector3距离</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>agent<span class="token punctuation">.</span>destination <span class="token operator">=</span> attactTarget<span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">;</span>        <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    agent<span class="token punctuation">.</span>isStopped <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment">//攻击动画和CD都在下面</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>lastAttactTime<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        animator<span class="token punctuation">.</span><span class="token function">SetTrigger</span><span class="token punctuation">(</span><span class="token string">"Attack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//触发攻击动画</span>        lastAttactTime <span class="token operator">=</span> <span class="token number">0.5f</span><span class="token punctuation">;</span><span class="token comment">//重置冷却时间</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    我们这里写到了重置冷却时间，但这个时间肯定要有一个递减的过程的，那我们就要找个地方来让它递减，这里<code>Update</code>是一个不错的选择</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">SwitchPlyerAnimation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lastAttactTime <span class="token operator">-=</span> Time<span class="token punctuation">.</span>deltaTime<span class="token punctuation">;</span><span class="token comment">//递减去每一帧之间的时间</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​    这样，一个冷却时间的效果还有攻击动画就完成啦！</p><p>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​     在本章节中，我们来学习如何创建我们的第一个敌人并添加一些关于移向敌人的代码和攻击动画，从而使我们的游戏更加完善&lt;/p&gt;
&lt;h1 id=&quot;下载并安装敌人素材&quot;&gt;&lt;a href=&quot;#下载并安装敌人素材&quot; class=&quot;headerlink&quot; title=&quot;下载并安装</summary>
      
    
    
    
    <category term="Unity学习笔记" scheme="http://sakura-pub.ltd/categories/Unity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Unity" scheme="http://sakura-pub.ltd/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity笔记5--剔除人物的遮挡</title>
    <link href="http://sakura-pub.ltd/UnityNotes/Unity%E7%AC%94%E8%AE%B05-%E5%89%94%E9%99%A4%E4%BA%BA%E7%89%A9%E7%9A%84%E9%81%AE%E6%8C%A1/"/>
    <id>http://sakura-pub.ltd/UnityNotes/Unity%E7%AC%94%E8%AE%B05-%E5%89%94%E9%99%A4%E4%BA%BA%E7%89%A9%E7%9A%84%E9%81%AE%E6%8C%A1/</id>
    <published>2021-06-12T07:35:19.000Z</published>
    <updated>2021-06-12T11:31:01.149Z</updated>
    
    <content type="html"><![CDATA[<p>​    我们发现在移动到一些物体（比如说树）后面的时候，人物就会给遮挡住了，那么有什么办法可以剔除掉这个遮挡呢？可以参考一些游戏，大部分游戏在移动到遮挡物后面时会把人物的轮廓显示出来，这个章节我们就来实现这种效果。</p><h1 id="利用-Shader-Graph（着色器可视化编辑器）剔除遮挡"><a href="#利用-Shader-Graph（着色器可视化编辑器）剔除遮挡" class="headerlink" title="利用 Shader Graph（着色器可视化编辑器）剔除遮挡"></a>利用 Shader Graph（着色器可视化编辑器）剔除遮挡</h1><h2 id="创建一个Shader"><a href="#创建一个Shader" class="headerlink" title="创建一个Shader"></a>创建一个Shader</h2><p>​    首先为了以后的操作方便，我们在 Materials 文件夹下再新建一个 <strong>Shader Graph 文件夹</strong>，我们就在这个文件夹目录下新建一个 Shader Graph （Create —&gt; Shader —&gt; Universal Render Pipeline —&gt; Unlit Shader Graph）并将它命名为 <strong>Occlusion Shader</strong> （遮挡着色器）。</p><p>​    同时选中该 Shader 右键新建一个 Material 材质，命名为 <strong>Occlusion</strong> ，将它拖到上级目录 Materials ，完成后如下图所示</p><img src="https://p9.toutiaoimg.com/origin/pgc-image/bda871c8cfc34794a0f19650681d08c2.jpg" alt="1.jpg" style="zoom:80%;" /><img src="https://p6.toutiaoimg.com/origin/pgc-image/7e8acbcfdcb349588d889a38ea6b699d.jpg" alt="2.jpg" style="zoom:67%;" /><p>​    </p><p>​    做好这些分类工作后，我们双击打开 Occlusion Shader 打开着色器编辑器窗口，看到如下界面，我们可以先在右上角的 Graph Settings 选项卡中<strong>勾选 Alpha Clip</strong> 打开透明通道，勾选了这个之后我们就可以在 Fragment 节点中修改透明值了</p><img src="https://p26.toutiaoimg.com/origin/pgc-image/6d0dd303bf884583b5bf7803d0f5998a.jpg" alt="3.jpg" style="zoom:80%;" /><p>​    然后我们在空白的地方右键新建一个节点，搜索添加  <strong>Fresnel Effect</strong> （菲涅尔效应），我们到时候可以将人物应用这个 Shader 来实现透明化的效果</p><img src="https://p26.toutiaoimg.com/origin/pgc-image/ef52362a31bb45228a82e169ee052644.jpg" alt="4.jpg" style="zoom:80%;" /><p>​    但是我们看这个光圈有点单调，我们可以给它来上点颜色</p><h2 id="添加颜色"><a href="#添加颜色" class="headerlink" title="添加颜色"></a>添加颜色</h2><p>​    要添加颜色，首先就要在左上角新建一个 <strong>Color类型</strong> 的参数（这些新建出来的参数之后都可以直接材质对象的属性界面板修改它们），然后给这个参数设置一个默认颜色值</p><img src="https://p26.toutiaoimg.com/origin/pgc-image/afff800563c946299acfd483a3bb2f67.jpg" alt="5.jpg" style="zoom:80%;" /><p>​    有了颜色值，我们想应用到上面的 Fresnel Effect 节点的话，有个方法就是将它们相乘，这样颜色就可以与之混合：拖拽 Fresnel Effect 节点窗口的 Out 然后点击空白处，在弹出的搜索框中搜索 Multiply（乘），这时候就多了一个节点窗口，A值由原来的 Fresnel Effect 节点输入进来，而剩下一个B值就是留给我们颜色的</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/ca8248f9b6e046ae959697d41e8da5d8.jpg" alt="6.jpg" style="zoom:80%;" /><p>​    此时我们再将左上角的 Color 拖拽出来，并传给B值，这样颜色就混合进去Fresnel Effect 节点了</p><img src="https://p3.toutiaoimg.com/origin/pgc-image/278510f8f57e4f57a093c66168a16cd7.jpg" alt="7.jpg" style="zoom:80%;" /><p>​    将 Multiply 节点输出 Out 值拖入到 Fragment 节点的 Base Color 项中，可以看到右下角的预览窗口就是我们材质的最终效果了</p><img src="https://p9.toutiaoimg.com/origin/pgc-image/7dc333ce40314957b7ed649b5b9fa013.jpg" alt="8.jpg" style="zoom:80%;" /><p>​    当然我们还可以更完善一下，添加一些额外的东西</p><h2 id="添加噪点"><a href="#添加噪点" class="headerlink" title="添加噪点"></a>添加噪点</h2><p>​    我们可以添加一些噪点填充我们的材质</p><p>​    右键创建一个 <strong>Dither</strong> 节点窗口，改变X的值可以看到噪点渐变的效果</p><img src="https://p26.toutiaoimg.com/origin/pgc-image/5253d92200c34098b2989374df8573da.jpg" alt="9.jpg" style="zoom:80%;" /><p>​    由于这个X值是一个 Float 类型，我们可以创建一个<strong>float类型参数</strong>来供外界改变它，我们就把这个参数命名为 <strong>DitherCount</strong> ，默认值可以暂时设为1</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/3554a59477874c29b9730008f8d6207c.jpg" alt="10.jpg" style="zoom:80%;" /><p>​    最后将输出 Out 值传给 Fragment 节点中的 Alpha 即可</p><img src="https://p3.toutiaoimg.com/origin/pgc-image/52e712db91204e3b869a6f13a4876508.jpg" alt="11.jpg" style="zoom:80%;" /><p>​    </p><h2 id="保存Shader并生成为材质"><a href="#保存Shader并生成为材质" class="headerlink" title="保存Shader并生成为材质"></a>保存Shader并生成为材质</h2><p>​    最后的最后我们可以再添加一个控制 Alpha Clip Threshold （Alpha阈值）的参数值，当然它也是 float类型的，命名为 AlphaThreshold</p><img src="https://p3.toutiaoimg.com/origin/pgc-image/891aa0b188d44acc835c192ca99c33de.jpg" alt="12.jpg" style="zoom:80%;" /><p>​    </p><p>​    点击保存，我们就可以在最开始创建的 Occlusion 材质看到效果了，可以看到它的属性面板中有了三个参数，这三个参数就是我们在 Shader 编辑器中创建的三个变量值</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/a2f1c9f63ad443778b5f1cc23c69996a.jpg" alt="13.jpg" style="zoom:80%;" /><h1 id="将材质应用到人物中"><a href="#将材质应用到人物中" class="headerlink" title="将材质应用到人物中"></a>将材质应用到人物中</h1><h2 id="创建一个Render-Objects"><a href="#创建一个Render-Objects" class="headerlink" title="创建一个Render Objects"></a>创建一个Render Objects</h2><p>​    在上面创建好了材质后，我们就可以尝试把它应用到我们的人物里了，我们想要的是当人物移动到树等物体后面给遮挡时应用这个材质，这样就等同于显示人物的轮廓了，那就让我们开始吧！</p><p>​    我们找到我们的 Pipeline Setting 文件夹，选中 <strong>UniversalRenderPipelineAsset_Renderer</strong> ，在右边的属性面板中点击 <strong>Add Renderer Feature</strong> 按钮，新建一个 <strong>Render Objects</strong></p><p>​    因为我们要区分人物在遮挡物前面和在遮挡物后面的情况，所以可以先将这个 Render Object 命名为 <strong>CharcterBehind</strong> ，而判断是否在遮挡物后面的条件就是根据 深度（Depth）来判断，所以我们要勾选 <strong>Depth</strong> 选项，并按下图来设置</p><img src="https://p5.toutiaoimg.com/origin/pgc-image/3a0b69da1498450b9896af76a181e118.jpg" alt="14.jpg" style="zoom:80%;" /><p>​    图中的 Material 选项则是选择我们前面创建的材质 Occlusion，这样当人物在判断成功的条件下就会给渲染出这个材质效果了</p><h2 id="设置过滤图层"><a href="#设置过滤图层" class="headerlink" title="设置过滤图层"></a>设置过滤图层</h2><p>​    做完了上面这些还不够，我们还要考虑 <strong>Filters（过滤）</strong>哪一些东西，我们可以在上方的 <strong>Layer Mask</strong> 中选择我们要过滤的图层，因为我们这里遮挡只涉及到人物，因此我们只用过滤人物图层就行了</p><p>​    但是问题在于 Layer Mask 默认自带的选项并没有我们的人物图层，那我们就自创一个：找到我们的人物对象（我这里的名字是Player），然后点击属性面板中的 <strong>Layer —&gt; Add Layer…</strong></p><img src="https://p6.toutiaoimg.com/origin/pgc-image/88e43d5e10e6489eaaf3de4128e87533.jpg" alt="15.jpg" style="zoom:80%;" /><p>​    然后为了方便记忆，可以将这个新图层命名为 Player</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/e0c625c03a9d422681ba030f982dbe7f.jpg" alt="16.jpg" style="zoom:80%;" /><p>​    新建好后不要忘了回到人物属性中选择我们的新图层，这时候弹出一个对话框，我们选择下图第一个选项，将子物体也一起更改为新图层</p><img src="https://p5.toutiaoimg.com/origin/pgc-image/b156a4461b024c348d80d8b760201cde.jpg" alt="17.jpg" style="zoom:80%;" /><h2 id="最后的调整"><a href="#最后的调整" class="headerlink" title="最后的调整"></a>最后的调整</h2><p>​    这个时候我们人物已经有了一些变化了，把它放在树后面可以看到渲染出来的是轮廓了，但是还有一些问题需要调整：当我们不是在遮挡物后面时，人物的一些部件也会有遮挡效果，我们就要来解决它</p><img src="https://p9.toutiaoimg.com/origin/pgc-image/0130ed394a4c479b8b5d210748ed8dd8.jpg" alt="18.jpg" style="zoom:80%;" /><p>​    我们只需要再新建一个 <strong>Render Objects</strong> ，并命名为 <strong>CharcterInFront</strong> 代表是人物在遮挡物前面的时候（与上一个 Render Object 相反情况），然后只需要改变 Layer Mask 为我们新建的 Player 图层，人物就恢复正常了</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/43099fd6b674481abab6aebe7a902607.jpg" alt="19.jpg" style="zoom:80%;" /><img src="https://p9.toutiaoimg.com/origin/pgc-image/cd173ce71bc44957a77546101663df92.jpg" alt="20.jpg" style="zoom:80%;" /><p>​    因为这样设置就代表着人物在被其它物体遮挡了会应用透明化的材质（第一个 CharcterBehind Render Object），在没有被遮挡的情况下就什么都不变（第二个 CharcterInFront Render Object）</p><p>​    到这里，我们就完成了剔除人物遮挡效果啦！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​    我们发现在移动到一些物体（比如说树）后面的时候，人物就会给遮挡住了，那么有什么办法可以剔除掉这个遮挡呢？可以参考一些游戏，大部分游戏在移动到遮挡物后面时会把人物的轮廓显示出来，这个章节我们就来实现这种效果。&lt;/p&gt;
&lt;h1 id=&quot;利用-Shader-Graph（</summary>
      
    
    
    
    <category term="Unity学习笔记" scheme="http://sakura-pub.ltd/categories/Unity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Unity" scheme="http://sakura-pub.ltd/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity笔记4--设置人物的动画</title>
    <link href="http://sakura-pub.ltd/UnityNotes/Unity%E7%AC%94%E8%AE%B04-%E8%AE%BE%E7%BD%AE%E4%BA%BA%E7%89%A9%E7%9A%84%E5%8A%A8%E7%94%BB/"/>
    <id>http://sakura-pub.ltd/UnityNotes/Unity%E7%AC%94%E8%AE%B04-%E8%AE%BE%E7%BD%AE%E4%BA%BA%E7%89%A9%E7%9A%84%E5%8A%A8%E7%94%BB/</id>
    <published>2021-06-10T02:45:45.000Z</published>
    <updated>2021-06-11T16:04:50.324Z</updated>
    
    <content type="html"><![CDATA[<p>​    在前面两个章节我们成功地让我们的人物在地图上走了起来，但是我们发现小人的动作是素材下载下来时默认的状态，需要我们来进行调整，那么这一章节就来修改一下小人的动作吧！</p><h1 id="查看素材小人自带的动作动画"><a href="#查看素材小人自带的动作动画" class="headerlink" title="查看素材小人自带的动作动画"></a>查看素材小人自带的动作动画</h1><p>​    我们之前下载下来的人物是有自带的动作的，我们先来查看一下它们是怎样的</p><p>​    打开如下目录（ <strong>Assets Packs —&gt; DogKnight —&gt; Animations</strong> ），找到图片中的这些文件，这一些文件就是我们小人自带的动作了，而在右边有个小窗口可以预览播放动作动画，但是我们发现预览窗口中的人是紫色的，怎样可以调成我们人物的样例呢？</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/d855bb2c3cb24ba0b1e5b351658616e1.jpg" alt="1.jpg" style="zoom:80%;" /><p>​        我们只需要点一下预览窗口上方一个按钮就可以导入一个人物样例用在这个动画上了</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/994679f9c4704258b10a25ab51ad1273.jpg" alt="2.jpg" style="zoom:80%;" /><p>​    点击绿色小人按钮，然后选择 **Other…**，我们就可以在新出来的窗口 <strong>Select GameObject</strong> 中选择我们要用的样例了，这里我选择的是 DogPBR ，也就是我们游戏中要用到的小狗</p><p>​    知道了动作动画在哪里以及怎么预览动作之后，我们就可以着手来实现更改角色的动作了</p><h1 id="使用动作控制器修改人物动作"><a href="#使用动作控制器修改人物动作" class="headerlink" title="使用动作控制器修改人物动作"></a>使用动作控制器修改人物动作</h1><p>​    首先我们新建一个目录来专门存放一个动作控制器文件的文件夹，可以参考下图目录</p><img src="https://p3.toutiaoimg.com/origin/pgc-image/2d3c92a24b084da1825b3632a043a377.jpg" alt="3.jpg" style="zoom:80%;" /><p>​    <strong>Animators</strong> 文件夹中我们右键 <strong>Create</strong> 一个 <strong>Animator Controller</strong> 文件，并可以将它命名为 Player ，这个文件就是用来控制我们人物动作的控制器文件</p><img src="https://p26.toutiaoimg.com/origin/pgc-image/805493fbe75d4f3db98752c50dde6af4.jpg" alt="4.jpg" style="zoom:80%;" /><p>​    新建好动作控制器文件后，我们双击打开它，可以看到如下图一个默认的界面</p><img src="https://p5.toutiaoimg.com/origin/pgc-image/b9f85f9d22ab4bae8e8d5b7eec6983ec.jpg" alt="5.jpg" style="zoom:80%;" /><p>​    我们在中间视图右键然后新建一个 <strong>Blend Tree</strong> （即混合树，用来解决多个动画之间的混合，经常用于移动动画之间的混合），新建好后命名为：Locomotion，并双击打开这个 Blend Tree</p><img src="https://p3.toutiaoimg.com/origin/pgc-image/7922cd39288d461b8746c05bd0e315b2.jpg" alt="6.jpg" style="zoom:80%;" /><p>​    打开后我们首先要做的事就是把左上方 <strong>Parameters（参数）</strong> 选项卡中默认的 Blend 参数删除，并自己新建一个 **Float 类型 **的参数，这个参数是用来参考要哪一个数值来切换我们的动作，这里理所应当是看移动时人物的速度是多少从而来切换不同的动作，因此我们这个 Float 类型的参数就命名为 <strong>“ Speed ”</strong>，到时候我们在代码中就要用到这个值</p><p>​    了解参数之后，我们右键中间的 Blend Tree ，选择 <strong>Add Motion</strong> 添加动作，这里我们可以考虑一下总共要多少个动作：一个是人物没有移动的时候是 <strong>站立不动</strong>，一个是移动速度较慢，属于 <strong>慢走状态</strong>，还有一个速度较快，变为了 <strong>快跑</strong>，这样我们就有了三个动作。因此在这里就要添加三次 Motion 了</p><p>​    <img src="https://p6.toutiaoimg.com/origin/pgc-image/f5ad228bf45040e393dd2e88d27c040a.jpg" alt="7.jpg" style="zoom:80%;" /></p><p>​    添加好 Motion 后我们在右边的 Inspector 视图中便可以看到多了三个空的 Motion ，这个时候要注意<u>先把 Parameter（参数）选择为刚刚创建的 Speed</u> 先，然后就分别把 站立、行走、奔跑 三个动作拖入到三个空 Motion 框中（动作在文章前面可以找到路径），完成后如下图所示</p><img src="https://p5.toutiaoimg.com/origin/pgc-image/58ff789af1ab4b3eb11464c2de7469df.jpg" alt="8.jpg" style="zoom:80%;" /><p>​    弄好上面这些东西后，剩下的就要交给代码来解决了，也是我们应用 Speed 参数的时候了，这次的代码打在了之前创建过的 <strong>PlayerController</strong> 代码文件中，下面贴出这次要用到的代码👇👇👇</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">using</span> <span class="token namespace">UnityEngine</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PlayerController</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MonoBehaviour</span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">NavMeshAgent</span> agent<span class="token punctuation">;</span><span class="token comment">//导航控制，之前用到的</span>    <span class="token keyword">private</span> <span class="token class-name">Animator</span> animator<span class="token punctuation">;</span><span class="token comment">//动作控制</span>        <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Awake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//获取当前组件并赋值给上面声明的变量</span>         agent <span class="token operator">=</span> <span class="token generic-method"><span class="token function">GetComponent</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>NavMeshAgent<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>animator<span class="token operator">=</span><span class="token generic-method"><span class="token function">GetComponent</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>Animator<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//实时更新动作动画</span><span class="token function">SwitchPlyerAnimation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SwitchPlyerAnimation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//切换人物角色的动作动画</span><span class="token comment">//弄好后整个函数放进Update里</span>        animator<span class="token punctuation">.</span><span class="token function">SetFloat</span><span class="token punctuation">(</span><span class="token string">"Speed"</span><span class="token punctuation">,</span>agent<span class="token punctuation">.</span>velocity<span class="token punctuation">.</span>sqrMagnitude<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置一个Float值，参数2为要设置的值</span>        <span class="token comment">//API解释</span>                <span class="token comment">//velocity -- 获取 NavMeshAgent 组件的当前速度，或者设置一个速度来手动控制代理。</span>        <span class="token comment">//API网址：https://docs.unity.cn/cn/2020.3/ScriptReference/AI.NavMeshAgent-velocity.html</span>                <span class="token comment">//sqrMagnitude -- 属于 Vector3 的方法，返回这个向量的长度的平方（只读），计算长度的平方而不是magnitude是非常快的</span>        <span class="token comment">//API网址：http://docs.manew.com/Script/Vector3.sqrMagnitude.html</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    打完代码后，再把 Animator Controller 文件 <strong>Player</strong> 拖到人物属性面板中的 <strong>Animator — Controller</strong> 框框中就大功告成啦！进入游戏看看你的人物是否在移动时会变换指定的动作吧！</p><img src="https://p9.toutiaoimg.com/origin/pgc-image/5b9d38d06a01422394b2959ab214244c.jpg" alt="9.jpg" style="zoom:80%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​    在前面两个章节我们成功地让我们的人物在地图上走了起来，但是我们发现小人的动作是素材下载下来时默认的状态，需要我们来进行调整，那么这一章节就来修改一下小人的动作吧！&lt;/p&gt;
&lt;h1 id=&quot;查看素材小人自带的动作动画&quot;&gt;&lt;a href=&quot;#查看素材小人自带的动作动画</summary>
      
    
    
    
    <category term="Unity学习笔记" scheme="http://sakura-pub.ltd/categories/Unity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Unity" scheme="http://sakura-pub.ltd/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity笔记3--摄像机跟踪处理</title>
    <link href="http://sakura-pub.ltd/UnityNotes/Unity%E7%AC%94%E8%AE%B03-%E6%91%84%E5%83%8F%E6%9C%BA%E8%B7%9F%E8%B8%AA%E5%A4%84%E7%90%86/"/>
    <id>http://sakura-pub.ltd/UnityNotes/Unity%E7%AC%94%E8%AE%B03-%E6%91%84%E5%83%8F%E6%9C%BA%E8%B7%9F%E8%B8%AA%E5%A4%84%E7%90%86/</id>
    <published>2021-06-09T08:13:39.000Z</published>
    <updated>2021-06-09T13:31:41.489Z</updated>
    
    <content type="html"><![CDATA[<p>​    在上一章节，我们第一次在Unity上使用代码来实现了我们人物的移动。但是我们发现镜头并不会跟着人物移动，因此在这一章节我们就来实现如何让摄像机跟着我们小人走。</p><p>​    同样我们也要安装一个插件，叫做 <strong>Cinemachine</strong> ，安装完后我们可以在Unity界面上方的菜单栏看见它的功能条</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/2edd56f142984d5ca500ad9372783225.jpg" alt="1.jpg" style="zoom: 67%;" /><img src="https://p6.toutiaoimg.com/origin/pgc-image/a9788d8d88904631b6965ad7b0f5b286.jpg" alt="2.jpg" style="zoom:80%;" /><center>首先安装好Cinemachine</center><p>​    在这里我们用到的选项是第一个，先选中我们的主摄像机 Main Camera（我这里对主摄像机的命名），在菜单栏中找到 <strong>GameObject—&gt;Align View to Selected</strong>（这一步操作是把我们的视角调到和摄像机的视角一样的角度），然后再在刚刚的 <strong>Cinemachine</strong> 菜单栏中点击<strong>创建一个 Virtual Camera</strong> </p><img src="https://p9.toutiaoimg.com/origin/pgc-image/a2106f307e6d4818b7bfa9ade25435ad.jpg" alt="3.jpg" style="zoom: 75%;" /><p>​    创建好后，我们的 Virtual Camera（虚拟摄像机） 就会顶替了我们的主摄像机，我们找到刚刚创建好的虚拟摄像机对象，在属性栏中进行一些调整：</p><p>​    1）首先在 Body 选择为 <strong>Framing Transposer</strong> ，这样相机就会跟随着我们人物了，这里简单介绍一些其他几个选项的作用</p><img src="https://p26.toutiaoimg.com/origin/pgc-image/f9ab6d9da189491187c26eb6b7f47249.jpg" alt="4.jpg" style="zoom:80%;" /><ul><li><p>Do Nothing：不移动虚拟相机 </p></li><li><p>Framing Transposer：跟随目标移动，并在屏幕空间保持相机和跟随目标的相对位置。 </p></li><li><p>Hard Lock to Target：虚拟相机和跟随目标使用相同位置。</p></li><li><p> Orbital Transposer：相机和跟随目标的相对位置是可变的，还能接收用户的输入。常见于玩家控制的相机。</p></li><li><p> Tracked Dolly：相机沿着预先设置的轨道移动。 </p></li><li><p>Transposer：跟随目标移动，并在世界空间保持相机和跟随目标的相对位置固定。</p><p>2）在 Aim 选项中选择 <strong>Do Nothing</strong> （这里对其它几个选项感兴趣的可以自己去试一下，选择POV的时候视野会跟着鼠标转动，一般可用于第一人称的游戏）</p><img src="https://p26.toutiaoimg.com/origin/pgc-image/2d597d7729c044f4a771b53cde8b0077.jpg" alt="5.jpg" style="zoom:80%;" /><p>3）将你的人物对象拖入 Follow 的框框中（这里其实本质是相机跟随一个像素点，如果想调整跟随的点可以自己调整，也可以新建一个人物子类Empty对象，然后调整这个空对象的位置，再让相机跟随这个对象）</p><img src="https://p5.toutiaoimg.com/origin/pgc-image/edb5d7890a4441ff965a759adb6de889.jpg" alt="6.jpg" style="zoom:80%;" /></li></ul><p>​    到这里，你的摄像机就会跟随着人物移动而转变视角了，当然还可以更进一步，调整一下缓冲区域（就是让相机不要跟随着太紧，让人物走那么一点点距离再相机跟随）：我们可以通过调整下图几个参数而调整，预览屏幕的框框可以看到你的缓冲区大小</p><img src="https://p3.toutiaoimg.com/origin/pgc-image/b17d8f6eca6e4c1494f6b28ede1ecec3.jpg" alt="7.jpg" style="zoom:80%;" /><img src="https://p5.toutiaoimg.com/origin/pgc-image/4242f83084d54044bdb5ecedf8ad588a.jpg" alt="8.jpg" style="zoom:80%;" /><p>​    当然感兴趣的话还可以去查找更多的设置方法去调整你的摄像机，从而让你的视野移动更完美。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​    在上一章节，我们第一次在Unity上使用代码来实现了我们人物的移动。但是我们发现镜头并不会跟着人物移动，因此在这一章节我们就来实现如何让摄像机跟着我们小人走。&lt;/p&gt;
&lt;p&gt;​    同样我们也要安装一个插件，叫做 &lt;strong&gt;Cinemachine&lt;/str</summary>
      
    
    
    
    <category term="Unity学习笔记" scheme="http://sakura-pub.ltd/categories/Unity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Unity" scheme="http://sakura-pub.ltd/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity笔记2--智能导航的烘焙和鼠标控制人物移动</title>
    <link href="http://sakura-pub.ltd/UnityNotes/Unity%E7%AC%94%E8%AE%B02-%E6%99%BA%E8%83%BD%E5%AF%BC%E8%88%AA%E7%9A%84%E7%83%98%E7%84%99%E5%92%8C%E9%BC%A0%E6%A0%87%E6%8E%A7%E5%88%B6%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8/"/>
    <id>http://sakura-pub.ltd/UnityNotes/Unity%E7%AC%94%E8%AE%B02-%E6%99%BA%E8%83%BD%E5%AF%BC%E8%88%AA%E7%9A%84%E7%83%98%E7%84%99%E5%92%8C%E9%BC%A0%E6%A0%87%E6%8E%A7%E5%88%B6%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8/</id>
    <published>2021-06-05T07:06:59.000Z</published>
    <updated>2021-06-08T11:17:51.512Z</updated>
    
    <content type="html"><![CDATA[<p>​    这一次我们来实现人物在地图上走动，在实现之前我们有一些准备工作要做，首先就是我们的地图烘焙了。</p><h1 id="智能导航地图的烘焙"><a href="#智能导航地图的烘焙" class="headerlink" title="智能导航地图的烘焙"></a>智能导航地图的烘焙</h1><p>​    地图的烘焙就是标记我们场景哪些区域是可以供人物移动的，而哪一些是障碍物或不可走区域，只有规划好了之后我们才可以更好的去实现人物移动，不然可以想一下因为一些粗心失误使得一些障碍物没有设置成功，从而导致人物移动穿模了就不妙了。</p><p>​    那么我们来开始吧！</p><p>​    首先还是要安装一个插件叫做 — <strong>Navigation</strong> ，安装步骤就不再过多介绍了</p><p>​    安装好了之后我们打开界面如下图，我们来看一下怎么烘焙吧</p><img src="https://p6-tt.byteimg.com/origin/pgc-image/148f5c914e914e808596ffa68e51d87d.jpg" alt="1.jpg" style="zoom: 80%;" /><p>​    </p><p>​    首先我们在场景中<strong>选择一个地面</strong>，然后再在 Navigation 插件里点击 <strong>Object选项卡</strong>，可以有个 <strong>Navigation Static</strong> 的选项，我们把这个选项 ✅ 勾上，因为只有设为 static 之后才可以进行烘焙。</p><p>​    ⚠有时候选择了 static 之后会弹出一个对话框，询问是否将该对象所包含的子对象（例如在地板对象中还包含了树木和石头等对象）都设为 static ，这个我们看自己情况选择。</p><p>​    选择 static 后，下面的 <strong>Navigation Area</strong> 就可以选择当前区域为可移动还是不可移动区域了</p><img src="https://p5-tt.byteimg.com/origin/pgc-image/4074b3afad1f40a1b0fc3ea55c186842.jpg" alt="2.jpg" style="zoom:80%;" /><p>​    回到 Bake 选项卡，我们看到可以设置地面在哪些情况下可以走，如 <strong>Max Slope</strong> 代表着可行坡度，就好像我所调的35°，这代表着我们小人最多可以走35角度的坡，如果大于35°的话我们小人是无法到达的</p><p>​    而图中的蓝色圆柱体以代表着你的人物身高和半径，我们修改这些属性也会影响到我们地图上可行区域</p><img src="https://p6-tt.byteimg.com/origin/pgc-image/1400e1a2f3784cb2ac84e3f87c22a959.jpg" alt="3.jpg" style="zoom:80%;" /><p>​    设置完这一切之后我们就可以点击下方的 <strong>Bake</strong> 按钮来烘焙啦，我们也可以在地图上看到颜色的变化，有颜色标记的区域是可以走的，而没有颜色则代表是无法到达的区域</p><p>​    </p><p>​    除了像上面那样直接使用 Navigation 插件进行障碍物等设置方法，我们还可以直接在物件的 <strong>Inspector</strong> 视图中添加一个 <strong>Navigation</strong> 的 <strong>Component</strong></p><p>​                             <img src="https://p6-tt.byteimg.com/origin/pgc-image/290b93d207ca4b5386932a8dcbef0407.jpg" alt="4.jpg" style="zoom:80%;" />                    <img src="https://p26-tt.byteimg.com/origin/pgc-image/e250b8ffcaf84d4f9eb2ef4e009069be.jpg" alt="5.jpg" style="zoom:80%;" /></p><p>​    添加完之后我们可以设置是可移动区域还是障碍区域，最后再进行 <strong>Bake</strong> ，用这种方式实现的地图烘焙有一个优点就是在你移动物体时，所设置的可行或不可行区域也会跟随物体移动，例如：我设置了一个石头为障碍物，在我移动石头时，该障碍物区域也会跟随着移动。</p><p>​    不止地面可以烘焙，我们地面上的树木石头都可以烘焙，具体操作也是先选中这些对象（鉴于可能物体较多，我们可以在Hierarchy视图上多选），然后设为 static ，再接着设置圆柱体范围等可行区域最后再烘焙就大功告成啦</p><h1 id="实现鼠标控制人物移动"><a href="#实现鼠标控制人物移动" class="headerlink" title="实现鼠标控制人物移动"></a>实现鼠标控制人物移动</h1><p>​    在烘焙好地图区域后，我们就可以着手来实现鼠标控制人物移动啦</p><p>​    因为这部分需要涉及到打代码，我们新建一个 <strong>Scripts</strong> 文件夹专门存放我们的代码</p><p>​    新建一个 <strong>C#</strong> 代码文件，一个 <strong>Unity Empty对象</strong>，把它们都命名为 <strong>MouseManager</strong> ，并把代码文件拖拽到 Unity Empty对象中</p><p>​               <img src="https://p3-tt.byteimg.com/origin/pgc-image/21776254d90d48bca1cf31c28f6c402e.jpg" alt="6.jpg" style="zoom:80%;" />                                        <img src="https://p5-tt.byteimg.com/origin/pgc-image/b54f60e1cb4146ff84a3922d31e64f57.jpg" alt="7.jpg" style="zoom:80%;" /></p><p>​    接下来就是编写代码了，由于这里展示的是单例模式，我们还要新建一个名为： <strong>PlayerController</strong> 的C#文件拖拽到要控制的人物上，下面分别是两个C#文件的代码</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token comment">//MouseManager.cs</span><span class="token comment">//这里只展示重要的部分并附上注释</span><span class="token keyword">using</span> <span class="token namespace">UnityEngine</span><span class="token punctuation">;</span><span class="token comment">//for Vector3,RaycastHit,Ray</span><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span><span class="token comment">//for Action</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MouseManager</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MonoBehaviour</span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">event</span> <span class="token class-name">Action<span class="token punctuation">&lt;</span>Vector3<span class="token punctuation">></span></span> OnMouseClicked<span class="token punctuation">;</span><span class="token comment">//声明一个事件，用于当鼠标点击时进行操作</span>    <span class="token class-name">RaycastHit</span> hitInfo<span class="token punctuation">;</span><span class="token comment">//用来存储射线Ray返回的坐标点消息</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">MouseManager</span> Instance<span class="token punctuation">;</span><span class="token comment">//MouseManager类的唯一实例（单例模式用）</span>        <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SetCursorTexture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//发射一条射线，起点是主相机（MainCamera）</span>        <span class="token comment">//射线另一端点则是鼠标点击的坐标（Input.mousePosition）</span>        <span class="token class-name">Ray</span> ray <span class="token operator">=</span> Camera<span class="token punctuation">.</span>main<span class="token punctuation">.</span><span class="token function">ScreenPointToRay</span><span class="token punctuation">(</span>Input<span class="token punctuation">.</span>mousePosition<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>Physics<span class="token punctuation">.</span><span class="token function">Raycast</span><span class="token punctuation">(</span>ray<span class="token punctuation">,</span><span class="token keyword">out</span> hitInfo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//上面的Raycast函数里将射线点信息返回到了out属性的hitInfo变量里</span>            <span class="token comment">//TODO</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>             <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">MouseControl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         <span class="token comment">//如果鼠标点击了一个地方并且hitInfo坐标点不为空的话</span><span class="token keyword">if</span><span class="token punctuation">(</span>Input<span class="token punctuation">.</span><span class="token function">GetMouseButtonDown</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> hitInfo<span class="token punctuation">.</span>collider <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//所点击的物体标签是“Ground”（地面）的话，（注意要把你的地面添加为Ground标签）</span><span class="token keyword">if</span><span class="token punctuation">(</span>hitInfo<span class="token punctuation">.</span>collider<span class="token punctuation">.</span><span class="token function">CompareTag</span><span class="token punctuation">(</span><span class="token string">"Ground"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">//判断OnMouseClicked事件是否为空，不为空的话则传递坐标点</span>OnMouseClicked<span class="token punctuation">?.</span><span class="token function">Invoke</span><span class="token punctuation">(</span>hitInfo<span class="token punctuation">.</span>point<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//DeBug Info</span><span class="token class-name">Vector3</span> point <span class="token operator">=</span> hitInfo<span class="token punctuation">.</span>point<span class="token punctuation">;</span>Debug<span class="token punctuation">.</span><span class="token function">LogFormat</span><span class="token punctuation">(</span><span class="token string">"鼠标左键单击了&#123;0&#125;! X:&#123;1&#125;,Y:&#123;2&#125;,Z:&#123;3&#125;"</span><span class="token punctuation">,</span>hitInfo<span class="token punctuation">.</span>collider<span class="token punctuation">.</span>name<span class="token punctuation">,</span>point<span class="token punctuation">.</span>x<span class="token punctuation">,</span>point<span class="token punctuation">.</span>y<span class="token punctuation">,</span>point<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Debug显示鼠标点击的坐标</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>        <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Awake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">//在Unity的脚本C#代码文件中，Awake()是在脚本对象实例化时被调用的，也就是在这个类被创建的时候就进行操作</span><span class="token keyword">if</span><span class="token punctuation">(</span>Instance <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">Destroy</span><span class="token punctuation">(</span>gameObject<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Instance <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>        <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//将上面两个主要的函数放进Update里</span><span class="token function">SetCursorTexture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">MouseControl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//class MouseManager</span><span class="token comment">//PlayerController.cs</span><span class="token comment">//把这个文件拖入到你要控制的人物中</span><span class="token keyword">using</span> <span class="token namespace">UnityEngine</span><span class="token punctuation">;</span><span class="token comment">//for Component.GetComponent&lt;></span><span class="token keyword">using</span> <span class="token namespace">UnityEngine<span class="token punctuation">.</span>AI</span><span class="token punctuation">;</span><span class="token comment">//for CLASS NavMeshAgent;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PlayerController</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MonoBehaviour</span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">NavMeshAgent</span> agent<span class="token punctuation">;</span><span class="token comment">//导航控制</span>        <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Awake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//GetComponent为获取组件</span>        <span class="token comment">//我们在人物添加过一个NavMeshAgent的Component，这里获取的就是它</span>        agent <span class="token operator">=</span> <span class="token generic-method"><span class="token function">GetComponent</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>NavMeshAgent<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">MoveToTarget</span><span class="token punctuation">(</span><span class="token class-name">Vector3</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//从事件中获得的坐标点赋值给人物移动的目标点</span>agent<span class="token punctuation">.</span>destination <span class="token operator">=</span> target<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>        <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//将函数方法注册到事件中</span>MouseManager<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>OnMouseClicked<span class="token operator">+=</span>MoveToTarget<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    到此，人物移动的核心部分就实现了，快去实验一下你的小人能不能移动吧！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​    这一次我们来实现人物在地图上走动，在实现之前我们有一些准备工作要做，首先就是我们的地图烘焙了。&lt;/p&gt;
&lt;h1 id=&quot;智能导航地图的烘焙&quot;&gt;&lt;a href=&quot;#智能导航地图的烘焙&quot; class=&quot;headerlink&quot; title=&quot;智能导航地图的烘焙&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Unity学习笔记" scheme="http://sakura-pub.ltd/categories/Unity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Unity" scheme="http://sakura-pub.ltd/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity笔记1--熟悉Unity界面以及构建场景</title>
    <link href="http://sakura-pub.ltd/UnityNotes/Unity%E7%AC%94%E8%AE%B01-%E7%86%9F%E6%82%89Unity%E7%95%8C%E9%9D%A2%E4%BB%A5%E5%8F%8A%E6%9E%84%E5%BB%BA%E5%9C%BA%E6%99%AF/"/>
    <id>http://sakura-pub.ltd/UnityNotes/Unity%E7%AC%94%E8%AE%B01-%E7%86%9F%E6%82%89Unity%E7%95%8C%E9%9D%A2%E4%BB%A5%E5%8F%8A%E6%9E%84%E5%BB%BA%E5%9C%BA%E6%99%AF/</id>
    <published>2021-06-01T06:10:51.000Z</published>
    <updated>2021-06-03T15:19:41.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="熟悉Unity界面"><a href="#熟悉Unity界面" class="headerlink" title="熟悉Unity界面"></a>熟悉Unity界面</h1><p>​    首先在开始之前说一下我所使用的Unity版本，我目前所安装的Unity是2020.3版本，具体版本号如下图所示：</p><p><img src="https://p6-tt.byteimg.com/origin/pgc-image/39050d7c97954612bc110e85d4b0d84e.jpg" alt="1.jpg"></p><p>​    同时这个版本也是稳定版本（LTS）</p><p>​    安装完Unity，我们就要开始创建项目，这里我们直接创建一个普通3D项目，项目名为：3DRPG ，进去之后我们按自己喜好调整一下界面布局，具体每个界面的作用这里作简单的介绍，随着我们不断推进项目我们也可以比较快地熟悉各个窗口的作用。</p><p><img src="https://p5-tt.byteimg.com/origin/pgc-image/aa00a709e4fe479aa99a5b3040a5a298.jpg" alt="2.jpg"></p><p>​    👆我们来看一下上面的图，这个界面是我在进行了几个章节之后截的图，一般我们都有几个主要的窗口界面：</p><ul><li><p><strong>Scene</strong>  这个是我们Unity的可视化场景管理窗口，简单来说就是我们可以直接将我们的人物、小物件等东西在Scene窗口上进行操作，这可以极大的方便我们进行场景的布置工作。</p></li><li><p><strong>Hierarchy</strong> 也就是上图靠中间上边的视图，在这个视图中我们可以看到在Scene视图中摆放了哪些物件对象，包括你的小人，花草树木甚至你的Camera(摄像机🎥)和光照对象都会在Hierarchy视图上显示出来。</p></li><li><p><strong>Project</strong> 这个视图里我们可以管理当前项目的文档文件，比如C#代码文件或其它配置文件等都可以在这里直接访问。</p></li><li><p><strong>Inspector</strong> 在这个视图里我们可以查看并修改当前选中对象的属性值，例如我可以在Scene视图或Hierarchy视图选中我的小人，然后修改它的高度、位置等等许多属性。</p></li><li><p><strong>Console</strong> 还有一个视图就是我们的输出控制台啦，在这个控制台里我们可以查看代码错误或者代码输出等信息，在往后我们的C#代码文件中可以利用Debug来输出特定的信息👉👉👉<code>Debug.LogFormat(&quot;调试信息&#123;0&#125;&quot;,xxxx);</code></p><h1 id="安装URP渲染管线"><a href="#安装URP渲染管线" class="headerlink" title="安装URP渲染管线"></a>安装URP渲染管线</h1><p>​    熟悉完界面后，我们就可以开始安装<strong>URP(Universal Render Pipeline)渲染管线</strong>了，首先我们在上边的菜单栏找到Window–Package Manager </p><img src="https://p6-tt.byteimg.com/origin/pgc-image/63fdcf0caf734225823ae387e05ea777.jpg" alt="3.jpg" style="zoom: 67%;" /><p>​    在 Package Manager 中我们可以管理当前项目使用的Unity插件，以后也会经常用到，之后在Package Manager 窗口中左上角我们选择 Pcakages 为<strong>Unity Registry</strong>，随后在右上角搜索<em>Universal RP</em>找到我们要的URP渲染管线并点击安装</p><img src="https://p9-tt.byteimg.com/origin/pgc-image/0c5d7ad152214e88b346851f86c86726.jpg" alt="4.jpg" style="zoom:67%;" /><p>​    我这里安装的URP版本号为 10.4.0 ，该版本已经在Unity 2020.3 中得到了认证。</p><p>​    安装完后我们就要开始配置工作了，首先我们在Project视图点那个+号，然后找到 Rendering -&gt; Universal Render Pipeline -&gt; Pipeline Asset (Forward Renderer) ，如下图👇</p><img src="https://p9-tt.byteimg.com/origin/pgc-image/d659c489af584a5ca3c337957af35a19.jpg" alt="5.jpg" style="zoom:67%;" /><p>​    点击之后我们看到Unity为我们创建了两个文件（下图的第二第三个），当然为了以后更好的管理各种杂七杂八的文件，我们要养成分类的好习惯，所以我们弄个文件夹把它们放在一起，这里我文件夹起名 Pipeline Setting</p><img src="https://p3-tt.byteimg.com/origin/pgc-image/fd12dcde3ace40bf9a60e5db6307675a.jpg" alt="6.jpg" style="zoom: 67%;" /><p>​    下一步我们打开菜单栏中的 Edit—ProjectSettings…</p><img src="https://p5-tt.byteimg.com/origin/pgc-image/35de350f60d04bf7a21461765e3c9f11.jpg" alt="7.jpg" style="zoom: 60%;" /><p>​    在新打开的窗口中我们可以对我们当前的项目进行一些设置操作，这里我们要设置默认的渲染管线为刚刚创建的URP渲染管线，我们分别在左侧栏中选择 Graphics 和 Quality ，再按照下图标蓝色框位置选择我们的URP渲染管线</p><img src="https://p6-tt.byteimg.com/origin/pgc-image/5dac041ae0e14100a36c7ed5e7fa1991.jpg" alt="8.jpg" style="zoom:70%;" /><center>Graphics界面设置URP</center><img src="https://p6-tt.byteimg.com/origin/pgc-image/78eb8e07811a40a08c3f1e084e204cbc.jpg" alt="9.jpg" style="zoom:70%;" /></li></ul><center>Quality界面设置URP</center><p>​    至此，我们的URP渲染管线安装配置就暂时到这了，接下来我们便可以开始导入素材测试渲染效果了。</p><h1 id="导入素材并构建场景"><a href="#导入素材并构建场景" class="headerlink" title="导入素材并构建场景"></a>导入素材并构建场景</h1><h2 id="使用Unity素材商店导入素材"><a href="#使用Unity素材商店导入素材" class="headerlink" title="使用Unity素材商店导入素材"></a>使用Unity素材商店导入素材</h2><p>​    我们可以通过Unity自带的官方商店里面寻找我们喜欢的素材，我们可以点击这个<a href="https://assetstore.unity.com/">链接</a>进入素材商店，也可以在Unity内的 Window—Asset Store 内打开</p><img src="https://p5-tt.byteimg.com/origin/pgc-image/150853385a5e42e282a36d8e1e651371.jpg" alt="10.jpg" style="zoom:60%;" /><p>​    值得注意的是，从Unity2020版开始取消了内置商店的窗口，如果你是2020版或之后的版本的话，打开Asset Store会得到一个无法访问的界面，我们需要再点击 Search Online 按钮按钮来打开网页版商店</p><img src="https://p6-tt.byteimg.com/origin/pgc-image/da99be76548c4ff18c4954eb06ad1d62.jpg" alt="11.jpg" style="zoom:65%;" /><p>​    </p><p>​    我们目前可以先找两个免费素材，如下图所示，一个是场景素材，一个是人物素材，可以供我们前期暂时学习使用了，这里我们点击蓝色的按钮并根据操作添加到你的Unity账户里，就可以在Unity里面下载下来了</p><p><img src="https://p5-tt.byteimg.com/origin/pgc-image/63fc0f40f92a4af181788740c7f975bc.jpg" alt="12.jpg"></p><p>​    在挑选素材时要注意一点就是要看好素材是否支持我们所选择的渲染管线，一般在素材商店界面都会有说明</p><p>​    素材添加到账户之后，我们打开 Package Manager，并在左上角的 Packages 选择为 My Assets，就可以看到在Unity商店添加的素材了，选中素材点击下载并Import就可以添加到项目中啦</p><img src="https://p3-tt.byteimg.com/origin/pgc-image/20d6062a1db34a62a9182d0aa5943889.jpg" alt="13.jpg" style="zoom:70%;" /><p>​    将我们小人拖到Scene视图中，可能会出现小人一身粉色还没渲染外观出来，这时我们就要将素材升级到我们的渲染管线，具体操作是 Edit -&gt; Render Pipeline -&gt; Universal Render Pipeline -&gt; 此时我们可以看到有出来两个选项，第☝个选项是将我们项目里的所以素材都升级为URP；第✌个选项是将当前选中的材质升级为URP，这里我们可以选择第一个。点击升级URP后小人就可以正常显示了</p><img src="https://p5-tt.byteimg.com/origin/pgc-image/29036628920f45c09b47e29ad9a2eaf0.jpg" alt="14.jpg" style="zoom:80%;" /><p>​    </p><h2 id="构建场景"><a href="#构建场景" class="headerlink" title="构建场景"></a>构建场景</h2><p>​    搭建场景部分我们可以先从调整天空样式开始，因为默认的天空样式灰溜溜的并不好看😐，那么我们就开始吧！</p><h3 id="天空"><a href="#天空" class="headerlink" title="天空"></a>天空</h3><p>​    首先调整天空可以先去下个天空盒子（Skybox）素材，这里我下载的是下图所示的Skybox：<a href="https://assetstore.unity.com/packages/vfx/shaders/free-skybox-extended-shader-107400">FREE Skybox Extended Shader</a></p><p><img src="https://p9-tt.byteimg.com/origin/pgc-image/e72308b7966b47368c2cc814dcf5dca4.jpg" alt="15.jpg"></p><p>​    添加好资源后回到Unity内下载并 Import（注意将文件夹分好类），我们可以在素材目录下看到有Demo样例</p><img src="https://p3-tt.byteimg.com/origin/pgc-image/0b812466543d478b9211e068a949438f.jpg" alt="16.jpg" style="zoom:80%;" /><p>​    那么如何来使用这个Skybox呢？</p><p>​    首先我们要在菜单栏打开 Window -&gt; Rendering -&gt; Lighting 窗口</p><img src="https://p6-tt.byteimg.com/origin/pgc-image/448dfc0867b14cea8a884b1da2cd1cc8.jpg" alt="17.jpg" style="zoom:70%;" /><p>​    然后我们在新打开的 Lighting 窗口点击 Environment 选项卡，在Skybox Material 那一栏中就可以选择自己喜欢的Skybox素材了</p><img src="https://p6-tt.byteimg.com/origin/pgc-image/e489644b78364fab8c4b97e49a5f69d3.jpg" alt="18.jpg" style="zoom:80%;" /><p>​    另外，我们在Scene选项卡中可以先点击一下New Lighting Settings按钮来新建一个光照配置文件并将它分类摆好，这个配置文件我们后面可以用来配置场景环境光</p><img src="https://p3-tt.byteimg.com/origin/pgc-image/07234fec87af42b8a7db9fbd227478b5.jpg" alt="19.jpg" style="zoom:80%;" /><p><img src="https://p9-tt.byteimg.com/origin/pgc-image/042dbd7860774728a5a7a00969f383e9.jpg" alt="20.jpg"></p><center>将这个配置文件分类摆在Pipeline Setting文件夹下</center><p>​    </p><p>​    现在我们就把刚刚下载下来的Skybox适用到场景中了，如果想要调整参数的话，我们可以到素材目录下找到刚刚选择的Skybox素材对象，并在 Inspector 视图窗口中调整这些参数</p><img src="https://p26-tt.byteimg.com/origin/pgc-image/e3033b1ee0d947b4b315b4a1c17afbf2.jpg" alt="21.jpg" style="zoom:80%;" /><center>我们可以看到右边的Inspector视图内可以修改Skybox的属性</center><p>​    </p><p>​    至此，天空场景就这样搭建好了，接下来我们来搭建地面的元素吧！</p><h3 id="地面"><a href="#地面" class="headerlink" title="地面"></a>地面</h3><p>​    如果想在Unity中自己来绘制场景地面的话，我们可以利用两个插件 — <strong>Poly Brush</strong> 和 <strong>ProBuilder</strong> 来自己建模。</p><h4 id="Poly-Brush"><a href="#Poly-Brush" class="headerlink" title="Poly Brush"></a>Poly Brush</h4><p>​    我们还是打开 Package Manager，左上角的 Packages 选择为 <strong>Unity Registry</strong> 然后我们在搜索框查找 <strong>Poly Brush</strong> 然后下载下来安装。安装好 Poly Brush 不要着急关闭 Package Manager 窗口，我们还要点开 Samples 导入属于我们URP的 Shader Examples ，即下图中的<strong>第二个选项</strong></p><img src="https://p6-tt.byteimg.com/origin/pgc-image/0a1867154c2045d2ada819d40e319961.jpg" alt="22.jpg" style="zoom:80%;" /><center>如果我们使用URP的话选择的是第二个选项</center><p>​    当然如果你是使用普通的Unity项目而没有使用URP渲染管线的话就选择<strong>第一个选项</strong></p><p>​    安装好后我们的 Project 视图里就会多出了一个 Polybrush 插件的文件夹，由于之后我们还要安装一些插件，所以我们可以新建一个文件夹命名为 <strong>Addons</strong> 来专门存放这些插件的文件（要养成分类的好习惯）</p><p>​    弄好这些东西后，我们回到Unity主界面，我们通过上方菜单栏的 <strong>Tools-&gt;Polybrush-&gt;Polybrush Window</strong> 来打开Polybrush窗口</p><img src="https://p26-tt.byteimg.com/origin/pgc-image/c58b3d98cab54de79fac9e3d9a0eaac6.jpg" alt="23.jpg" style="zoom:80%;" /><center>打开 Polybrush 窗口</center><p>​    打开 Polybrush 窗口后我们了解一下这些按钮的功能</p><img src="https://p6-tt.byteimg.com/origin/pgc-image/d8e4a421ebcb42719f15c86813a7e131.jpg" alt="24.jpg" style="zoom:80%;" /><ul><li><p>第一个按钮是调整地面的高度，选中该按钮然后在地面上拖拽鼠标即可将地面升高，按住 Ctrl 并拖拽鼠标便是下降。我们看到下面面板中还有一些参数供我们调整：</p><p><strong>OuterRadius</strong> 可以选择外角大小</p><p><strong>InnerRadius</strong> 则修改内角大小。按住 shift 键滑动鼠标滚轮可以调整内圈大小，按住 Ctrl 键滑动滚轮调整外圈。</p><p><strong>Strength</strong>可以修改强度</p><p><strong>Direction</strong> 可以选择地形改变的方向，默认为normal，下拉可以进行修改。</p><p><strong>BrushMirroring</strong>可以复制笔刷，沿着选中的的x,y,z镜像同时修改地形</p></li><li><p>第二个按钮是柔化按钮，羽化功能可以将地图较为僵硬的顶点进行柔化</p></li><li><p>第三个按钮是颜色刷，可以使我们很方便地将我们的地板涂上我们想要的颜色</p></li><li><p>第四个按钮是将预设的物体涂到地板上，我们可以在面板中勾选要刷的物体以及密度（即概率）</p></li><li><p>第五个是贴图刷，和预制体刷子的功能一样，它是将一些texture刷到场景中，可以把图片素材可以引用在场景中选中的物体上。</p></li></ul><h4 id="ProBuilder"><a href="#ProBuilder" class="headerlink" title="ProBuilder"></a>ProBuilder</h4><p>​    上面的Poly Brush插件是用来绘制修改地面的，那么我们如何来创建自己的地面呢？这下就要用到我们的另一个插件 — <strong>ProBuilder</strong> 了</p><p>​    同样地，我们通过 Package Manager 来安装此插件，下载下来后同样把插件文件夹分好类，然后打开窗口</p><img src="https://p5-tt.byteimg.com/origin/pgc-image/9e16aa320d6e461a9fc6a22752440486.jpg" alt="25.jpg" style="zoom:80%;" /><center>ProBuilder界面</center><p>​    我们可以按住 <strong>左Shift</strong> 并鼠标指到图形按钮来查看这些按钮的功能，我们看到有些按钮右上角有个小齿轮，这代表着我们可以进一步来设置，只用按住 Alt 并点击他们就可以进一步地来设置，拿第一个按钮（功能是<strong>创建几何体</strong>）来说</p><img src="https://p6-tt.byteimg.com/origin/pgc-image/bacf417b80d14ac18301bb95e8fb9034.jpg" alt="26.jpg" style="zoom:80%;" /><p>​    按住 Alt 并点击第一个按钮我们打开如上图所示的窗口，这里我们可以选择要创建的物体是什么，这里我选择的是 Plane （平面），下面可以设置该几何体的的轴的朝向、宽度、长度以及顶点数（如上图顶点数是30x30）</p><p>​    具体的功能我们可以自己去尝试，配合 Polybrush 我们就可以轻松地来创建我们的场景并绘制他们啦！</p><p>​    要注意的是我们如果要使用 <em>Low Poly</em> 风格的场景的话，我们要设置地图网格呈三角形，这里可以通过上面 ProBuilder 图中的 <strong>第二排第五个</strong> 按钮来实现，选中我们的地面几何体，然后点击该按钮便可以设置成功。</p><p>​    </p><p>​    到这里，我们就可以自己去尝试一下构建属于自己的场景了。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>​    在这一章节中，我们开始第一次接触Unity并尝试了解它，了解如何导入素材并构建、绘制我们的场景，我们只有多去尝试使用这些工具，才可以变得熟悉。所以，我们先可以发挥自己创意来构建一个场景，以便后面来操作吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;熟悉Unity界面&quot;&gt;&lt;a href=&quot;#熟悉Unity界面&quot; class=&quot;headerlink&quot; title=&quot;熟悉Unity界面&quot;&gt;&lt;/a&gt;熟悉Unity界面&lt;/h1&gt;&lt;p&gt;​    首先在开始之前说一下我所使用的Unity版本，我目前所安装的Unity是2</summary>
      
    
    
    
    <category term="Unity学习笔记" scheme="http://sakura-pub.ltd/categories/Unity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Unity" scheme="http://sakura-pub.ltd/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>关于我</title>
    <link href="http://sakura-pub.ltd/%E8%AE%B0%E4%BA%8B/%E5%85%B3%E4%BA%8E%E6%88%91/"/>
    <id>http://sakura-pub.ltd/%E8%AE%B0%E4%BA%8B/%E5%85%B3%E4%BA%8E%E6%88%91/</id>
    <published>2021-05-31T12:28:23.000Z</published>
    <updated>2021-06-02T08:02:05.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于这个博客的一些事🍥"><a href="#关于这个博客的一些事🍥" class="headerlink" title="关于这个博客的一些事🍥"></a>关于这个博客的一些事🍥</h1><p>​    当初创建这个博客的目的是想着记录自己在大学生活中遇到的一些问题或者学习笔记等，平时也看了不少别人的个人博客，于是心血来潮就想自己也创一个属于自己的个人博客。</p><p>​    刚开始我便去查找有什么博客平台，因为我喜欢自己自定义界面的方式，便找到了可以利用GitHub来做一个博客方式，即：<a href="https://hexo.io/zh-cn/">hexo</a> 。之后我便跟着教程开始搭建，也发现了一些很好看的主题，我现在用的这个主题是<a href="https://butterfly.js.org/">butterfly</a>（<a href="https://github.com/jerryc127/hexo-theme-butterfly/tree/dev">GitHub地址</a>）。之后研究美化界面又花了好一些时间，不过在弄这些东西的时候我都觉得很满足，看着属于自己的博客慢慢开始搭建起来，一股成就感就上来了，而且在其中也接触到了许多之前没有遇到过的知识。</p><p>​    弄好博客的基本框架后，才是真正的开始，希望有一个博客之后，能够对我自己有更好的帮助，可以更好地去总结知识点，也希望可以分享一些知识给观看博客的你😀。</p><h1 id="关于我的一些事"><a href="#关于我的一些事" class="headerlink" title="关于我的一些事"></a>关于我的一些事</h1><p>​    待更新…….💨</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于这个博客的一些事🍥&quot;&gt;&lt;a href=&quot;#关于这个博客的一些事🍥&quot; class=&quot;headerlink&quot; title=&quot;关于这个博客的一些事🍥&quot;&gt;&lt;/a&gt;关于这个博客的一些事🍥&lt;/h1&gt;&lt;p&gt;​    当初创建这个博客的目的是想着记录自己在大学生活中遇</summary>
      
    
    
    
    <category term="记事" scheme="http://sakura-pub.ltd/categories/%E8%AE%B0%E4%BA%8B/"/>
    
    
    <category term="记事" scheme="http://sakura-pub.ltd/tags/%E8%AE%B0%E4%BA%8B/"/>
    
    <category term="Markdown" scheme="http://sakura-pub.ltd/tags/Markdown/"/>
    
  </entry>
  
</feed>
