<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Unity笔记13-敌人的守卫状态和死亡状态</title>
      <link href="UnityNotes/Unity%E7%AC%94%E8%AE%B013-%E6%95%8C%E4%BA%BA%E7%9A%84%E5%AE%88%E5%8D%AB%E7%8A%B6%E6%80%81%E5%92%8C%E6%AD%BB%E4%BA%A1%E7%8A%B6%E6%80%81/"/>
      <url>UnityNotes/Unity%E7%AC%94%E8%AE%B013-%E6%95%8C%E4%BA%BA%E7%9A%84%E5%AE%88%E5%8D%AB%E7%8A%B6%E6%80%81%E5%92%8C%E6%AD%BB%E4%BA%A1%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p> 这一章节我们来制作敌人的守卫状态和死亡状态</p><h1 id="敌人的守卫状态（Guard）"><a href="#敌人的守卫状态（Guard）" class="headerlink" title="敌人的守卫状态（Guard）"></a>敌人的守卫状态（Guard）</h1><p>打开<code>EnemyController.cs</code></p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">private</span> <span class="token class-name">Quaternion</span> guardRotation<span class="token punctuation">;</span><span class="token comment">//记录敌人最初的旋转角度，用于脱离追击回去守卫点砖头转头</span><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Awake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//...</span>    guardRotation <span class="token operator">=</span> transform<span class="token punctuation">.</span>rotation<span class="token punctuation">;</span><span class="token comment">//获得最初旋转角度</span><span class="token punctuation">&#125;</span><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SwitchEnemyStates</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//...</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span>enemyStates<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> EnemyStates<span class="token punctuation">.</span>GUARD<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>守卫状态            isChase <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//脱离追击状态</span>            <span class="token comment">//如果在追击主角时回到守卫状态，就要跑回守卫点</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>transform<span class="token punctuation">.</span>position <span class="token operator">!=</span> guardPos<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                isWalk <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">//播放走路动画</span>                agent<span class="token punctuation">.</span>isStopped <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token comment">//导航回最初守卫点</span>                agent<span class="token punctuation">.</span>destination <span class="token operator">=</span> guardPos<span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>Vector3<span class="token punctuation">.</span><span class="token function">SqrMagnitude</span><span class="token punctuation">(</span>guardPos <span class="token operator">-</span> transform<span class="token punctuation">.</span>position<span class="token punctuation">)</span><span class="token operator">&lt;=</span>agent<span class="token punctuation">.</span>stoppingDistance<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token comment">//SqrMagnitude也是可以用于比较距离的方法，比起Distance稍微快一些</span>                    <span class="token comment">//这里是判断是否到达最初守卫点可以停止范围</span>                    isWalk <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token comment">//慢慢转头。第三个参数越接近1转得越快</span>                    transform<span class="token punctuation">.</span>rotation <span class="token operator">=</span> Quaternion<span class="token punctuation">.</span><span class="token function">Lerp</span><span class="token punctuation">(</span>transform<span class="token punctuation">.</span>rotation<span class="token punctuation">,</span>guardRotation<span class="token punctuation">,</span><span class="token number">0.01f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们就写好了守卫状态的代码，其中<code>SqrMagnitude()</code>作用和<code>Distance()</code>一样都是比较两个点的距离，然后我们还加了慢慢转头的效果，否则敌人回到守卫点是不会转头的</p><h1 id="死亡状态"><a href="#死亡状态" class="headerlink" title="死亡状态"></a>死亡状态</h1><p>我们希望当敌人血量为0时播放死亡动画并且尸体消失掉</p><h2 id="设置死亡动画"><a href="#设置死亡动画" class="headerlink" title="设置死亡动画"></a>设置死亡动画</h2><p>打开动画控制器，我们新建一个<code>Death Layer</code>，不要忘了权重设为1</p><img src="https://p5-tt.byteimg.com/origin/pgc-image/32be87ac0205413280a7f42a61d7296e.png" alt="1.png" style="zoom:80%;" /><p>这里有个<code>GetHit</code>是用来做暴击伤害受伤效果的，它有左边的<code>Hit</code>触发，而我们的死亡动画<code>Die</code>连着<code>Any State</code>表示任何状态都能转移过来，由布尔值<code>Death</code>控制</p><p><strong>特别要注意的地方：</strong>关于死亡动画的设置<code>Can Transition To</code>一定不能勾选，不然会发生鬼畜</p><img src="https://p6-tt.byteimg.com/origin/pgc-image/497e554f53c24b17be551acb0694058c.png" alt="2.png" style="zoom:80%;" /><p>接下来主角的动画也是如此设置</p><img src="https://p6-tt.byteimg.com/origin/pgc-image/66e702dd2c644d058b5e628fbcf052c6.png" alt="3.png" style="zoom:80%;" /><h2 id="编写动画状态转移代码"><a href="#编写动画状态转移代码" class="headerlink" title="编写动画状态转移代码"></a>编写动画状态转移代码</h2><p>回到我们的<code>EnemyController.cs</code>中</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">private</span> <span class="token class-name">Collider</span> collider<span class="token punctuation">;</span><span class="token comment">//碰撞体组件</span><span class="token keyword">private</span> <span class="token class-name"><span class="token keyword">bool</span></span> isDead<span class="token punctuation">;</span><span class="token comment">//死亡状态控制</span><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Awake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//...</span>    collider <span class="token operator">=</span> <span class="token generic-method"><span class="token function">GetComponent</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>Collider<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>charcterStates<span class="token punctuation">.</span>currentHealth <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        isDead <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">//血量变0则死亡状态为真</span>    <span class="token comment">//...</span><span class="token punctuation">&#125;</span><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SwitchAnimation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//...</span>    anim<span class="token punctuation">.</span><span class="token function">SetBool</span><span class="token punctuation">(</span><span class="token string">"Death"</span><span class="token punctuation">,</span>isDead<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//是否播放死亡动画</span><span class="token punctuation">&#125;</span><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SwitchEnemyStates</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//第一个判断是否为死亡</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>isDead<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        enemyStates <span class="token operator">=</span> EnemyStates<span class="token punctuation">.</span>DEAD<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">FoundPlayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//如果发现player 切换到CHASE</span>        enemyStates <span class="token operator">=</span> EnemyStates<span class="token punctuation">.</span>CHASE<span class="token punctuation">;</span>        <span class="token comment">//Debug.LogFormat("敌人&#123;0&#125;发现了玩家",this.name);//测试代码</span>    <span class="token punctuation">&#125;</span>            <span class="token keyword">case</span> EnemyStates<span class="token punctuation">.</span>DEAD<span class="token punctuation">:</span>    collider<span class="token punctuation">.</span>enabled <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//防止时候开业再次攻击</span>    agent<span class="token punctuation">.</span>enabled <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//直接关闭导航组件</span>    <span class="token function">Destroy</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>gameObject<span class="token punctuation">,</span><span class="token number">2f</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//销毁游戏对象，延迟为2秒</span>    <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们设置了<code>Death</code>的动画状态，注意开头<code>if(isDead)</code>的下一个是<code>else if</code>，而<code>Hit</code>的状态可以去到<code>CharcterStates.cs</code>中设置</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">TakeDamage</span><span class="token punctuation">(</span><span class="token class-name">CharcterStates</span> attacker<span class="token punctuation">,</span><span class="token class-name">CharcterStates</span> defener<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//计算伤害数值</span>    <span class="token comment">//当前攻击力减去目标的防御力，如果防御力过高就是0伤害</span>    <span class="token class-name"><span class="token keyword">int</span></span> damage <span class="token operator">=</span> Mathf<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span>attacker<span class="token punctuation">.</span><span class="token function">CurrentDamage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>defener<span class="token punctuation">.</span>currentDefence<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    currentHealth <span class="token operator">=</span> Mathf<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span>currentHealth<span class="token operator">-</span>damage<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//血量也是最小值锁在0</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>isCritical<span class="token punctuation">)</span><span class="token comment">//判断被打者是否受到暴击并且播放受伤动画</span>        defener<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">GetComponent</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>Animator<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">SetTrigger</span><span class="token punctuation">(</span><span class="token string">"Hit"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//将来要做的事情</span>    <span class="token comment">//TODO:血量条UI</span>    <span class="token comment">//TODO:打死怪后加经验</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在中间我们打了一行代码，用来获取被打者的Animator并设置动画<code>Hit</code>状态，这样就可以集中管理暴击受伤动画了</p><p>最后对于主角我们也用相同的办法来写这些代码就大功告成了</p>]]></content>
      
      
      <categories>
          
          <category> Unity学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity笔记12-实现攻击数值计算</title>
      <link href="UnityNotes/Unity%E7%AC%94%E8%AE%B012-%E5%AE%9E%E7%8E%B0%E6%94%BB%E5%87%BB%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"/>
      <url>UnityNotes/Unity%E7%AC%94%E8%AE%B012-%E5%AE%9E%E7%8E%B0%E6%94%BB%E5%87%BB%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p> 这一章节中我们来实现攻击伤害的计算，给予人物或敌人真实的攻击伤害</p><h1 id="补充人物攻击动画"><a href="#补充人物攻击动画" class="headerlink" title="补充人物攻击动画"></a>补充人物攻击动画</h1><p>在之前我们要给人物添加一下暴击动画，和上一章节设置敌人动画类似，注意要设置动画切换效果</p><img src="https://p6-tt.byteimg.com/origin/pgc-image/db2c7f3914614d4ea5ec93211e2b47a7.png" alt="1.png" style="zoom:80%;" /><p>打开<code>PlayerController.cs</code>，修改一下</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token return-type class-name">IEnumerator</span> <span class="token function">MoveToAttackTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    agent<span class="token punctuation">.</span>isStopped <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    transform<span class="token punctuation">.</span><span class="token function">LookAt</span><span class="token punctuation">(</span>attactTarget<span class="token punctuation">.</span>transform<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>Vector3<span class="token punctuation">.</span><span class="token function">Distance</span><span class="token punctuation">(</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">,</span>attactTarget<span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">)</span><span class="token operator">></span>          charcterStates<span class="token punctuation">.</span>attackData<span class="token punctuation">.</span>attackRange<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//比较人物和敌人的距离是否大于0攻击距离，Distance()可以比较两个Vector3距离</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>agent<span class="token punctuation">.</span>destination <span class="token operator">=</span> attactTarget<span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">;</span>        <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    agent<span class="token punctuation">.</span>isStopped <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment">//攻击动画和CD都在下面</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>lastAttactTime<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//CD冷却完成可执行攻击</span>        animator<span class="token punctuation">.</span><span class="token function">SetBool</span><span class="token punctuation">(</span><span class="token string">"Critical"</span><span class="token punctuation">,</span>charcterStates<span class="token punctuation">.</span>isCritical<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//增加了传递是否暴击</span>        animator<span class="token punctuation">.</span><span class="token function">SetTrigger</span><span class="token punctuation">(</span><span class="token string">"Attack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//普通攻击</span>        lastAttactTime <span class="token operator">=</span> charcterStates<span class="token punctuation">.</span>attackData<span class="token punctuation">.</span>coolDown<span class="token punctuation">;</span><span class="token comment">//修改了这里的CD时间</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们修改了两个地方，一个是增加了暴击判断，另一个是修改了CD时间判断</p><h1 id="增加攻击数值计算"><a href="#增加攻击数值计算" class="headerlink" title="增加攻击数值计算"></a>增加攻击数值计算</h1><p>前面补充完成后，我们就可以正式来写攻击伤害的数值计算了</p><p>打开<code>CharcterStates.cs</code>，我们在最下面加上我们的伤害计算代码</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">EventAttact</span><span class="token punctuation">(</span><span class="token class-name">GameObject</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//如果鼠标点击的目标不为空，或者点击的敌人不是属于死亡状态</span>        attactTarget <span class="token operator">=</span> target<span class="token punctuation">;</span>        <span class="token comment">//随机暴击率语句</span>        charcterStates<span class="token punctuation">.</span>isCritical <span class="token operator">=</span> Random<span class="token punctuation">.</span><span class="token keyword">value</span> <span class="token operator">&lt;</span> charcterStates<span class="token punctuation">.</span>attackData<span class="token punctuation">.</span>criticalChance<span class="token punctuation">;</span>        <span class="token function">StartCoroutine</span><span class="token punctuation">(</span><span class="token function">MoveToAttackTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//伤害计算区</span><span class="token preprocessor property">#<span class="token directive keyword">region</span> Charcter Combat</span>    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">TakeDamage</span><span class="token punctuation">(</span><span class="token class-name">CharcterStates</span> attacker<span class="token punctuation">,</span><span class="token class-name">CharcterStates</span> defener<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//计算伤害数值</span>    <span class="token comment">//当前攻击力减去目标的防御力，如果防御力过高就是0伤害</span>    <span class="token class-name"><span class="token keyword">int</span></span> damage <span class="token operator">=</span> Mathf<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span>attacker<span class="token punctuation">.</span><span class="token function">CurrentDamage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>defener<span class="token punctuation">.</span>currentDefence<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    currentHealth <span class="token operator">=</span> Mathf<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span>currentHealth<span class="token operator">-</span>damage<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//血量也是最小值锁在0</span>    <span class="token comment">//将来要做的事情</span>    <span class="token comment">//TODO:血量条UI</span>    <span class="token comment">//TODO:打死怪后加经验</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">CurrentDamage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//在攻击力范围内取随机数返回一个随机攻击力</span>    <span class="token class-name"><span class="token keyword">float</span></span> coreDamage <span class="token operator">=</span> Random<span class="token punctuation">.</span><span class="token function">Range</span><span class="token punctuation">(</span>attackData<span class="token punctuation">.</span>minDamage<span class="token punctuation">,</span>attackData<span class="token punctuation">.</span>maxDamage<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>isCritical<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//如果暴击的话还要计算上暴击率</span>        coreDamage <span class="token operator">*=</span>attackData<span class="token punctuation">.</span>criticalMultiplier<span class="token punctuation">;</span><span class="token comment">//乘等于</span>        Debug<span class="token punctuation">.</span><span class="token function">LogFormat</span><span class="token punctuation">(</span><span class="token string">"暴击了！伤害为（不算目标防御力）：&#123;0&#125;"</span><span class="token punctuation">,</span>coreDamage<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>coreDamage<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token preprocessor property">#<span class="token directive keyword">endregion</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="调用伤害计算方法"><a href="#调用伤害计算方法" class="headerlink" title="调用伤害计算方法"></a>调用伤害计算方法</h1><p>伤害计算代码写好后，我们就要去想如何调用它，在哪里调用它了</p><p>参考一些RPG游戏，一般都是当你的武器挥出去后接触到敌人那一瞬间计算伤害，我们也可以按照这样来做</p><h2 id="在人物身上调用"><a href="#在人物身上调用" class="headerlink" title="在人物身上调用"></a>在人物身上调用</h2><p>首先要调出<code>Animation</code>窗口</p><img src="https://p26-tt.byteimg.com/origin/pgc-image/42623310028b4fbcafc6c49ce9fbc6a6.png" alt="2.png" style="zoom:80%;" /><p>然后窗口左上角选择上我们的攻击动画<code>Attack01</code>，我们就可以在攻击动画里面的某个特定帧添加事件了</p><p>我们再次编辑一下<code>PlayerController.cs</code>代码加一个用来调用的方法</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token comment">//Animation Event</span><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Hit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name"><span class="token keyword">var</span></span> targetStates <span class="token operator">=</span> attactTarget<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">GetComponent</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>CharcterStates<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//计算伤害</span>    targetStates<span class="token punctuation">.</span><span class="token function">TakeDamage</span><span class="token punctuation">(</span>charcterStates<span class="token punctuation">,</span>targetStates<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回到<code>Animation</code>窗口，将它添加为事件</p><img src="https://p5-tt.byteimg.com/origin/pgc-image/3ebdba5a85864a339407b9a8d21a740f.png" alt="4.png" style="zoom:80%;" /><p><strong>注意：同样的暴击动画也要加上</strong></p><h2 id="在敌人身上调用"><a href="#在敌人身上调用" class="headerlink" title="在敌人身上调用"></a>在敌人身上调用</h2><p>然后在敌人身上我们也要进行同样的操作，打开<code>EnemyController.cs</code></p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token comment">//EnemyController.cs</span><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Hit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//由于在敌人追主角的过程中主角可能会跑开，这时候如果攻击的话目标就丢失了</span>    <span class="token comment">//所以我们在攻击前判断目标是否为空，以防报错</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>attackTarget <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name"><span class="token keyword">var</span></span> targetStates <span class="token operator">=</span> attackTarget<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">GetComponent</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>CharcterStates<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        targetStates<span class="token punctuation">.</span><span class="token function">TakeDamage</span><span class="token punctuation">(</span>charcterStates<span class="token punctuation">,</span>targetStates<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在为<code>Animation</code>添加动画时我们发现当前史莱姆的动画是<code>只读</code>属性的，对于这种情况我们可以把动画单独复制到其它地方，再将复制出来的动画替换原来的，就可以进行事件添加了</p><p>如图对着动画文件按<code>Ctrl+D</code>可以快速复制</p><img src="https://p9-tt.byteimg.com/origin/pgc-image/3831ed71b8dc46cc8d7ce464438e15b3.png" alt="5.png" style="zoom:80%;" /><p>然后我们将复制出来的动画（这里有两个）分类放好</p><img src="https://p26-tt.byteimg.com/origin/pgc-image/cded851a377744a2a2c53f78e2573698.png" alt="6.png" style="zoom:80%;" /><p>然后进行动画替换</p><img src="https://p26-tt.byteimg.com/origin/pgc-image/99667e3e7b754c4f8b286410045bac15.png" alt="7.png" style="zoom:80%;" /><p>最后再进行动画帧事件添加操作就行了</p><p>到这我们就把伤害计算代码和效果都写出来了，下一章节中我们还会去补充如果敌人或人物血量到0了时候的状态</p>]]></content>
      
      
      <categories>
          
          <category> Unity学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记第一期</title>
      <link href="LeetCode/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%9C%9F/"/>
      <url>LeetCode/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode刷题笔记第一期"><a href="#LeetCode刷题笔记第一期" class="headerlink" title="LeetCode刷题笔记第一期"></a>LeetCode刷题笔记第一期</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前一直想在刷题的时候把想要记下的笔记记下来，但是没有找到很好的地方，但是现在有了博客之后就可以写在这的</p><p>写这个刷题笔记一个是想时不时回来巩固一下算法，另一个是想记录下自己的算法能力成长的过程，同时也是想为实习做准备</p><p>写这个笔记是大二暑假时期，之前也有一些算法基础，参加过的算法相关竞赛只有一次蓝桥杯，只拿到省赛二等奖，也希望能够通过刷题和做笔记能够有所长进</p><p>本人算法能力不是很强，一般都要想好一阵子，所以一般写出来的答案不是很好，望大佬们轻喷</p><p>✨注：我写算法的语言主打C++</p><p>那么，就开始吧！</p><hr><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452.用最少数量的箭引爆气球"></a>452.<a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">用最少数量的箭引爆气球</a></h2><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p><p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 <code>xstart</code>，<code>xend</code>， 且满足  <code>xstart</code> ≤ x ≤ <code>xend</code>，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p><p>示例：</p><blockquote><p>输入：points = [[10,16],[2,8],[1,6],[7,12]]<br>输出：2<br>解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</p></blockquote><p>这一题拿到题目时看了好几次都看不懂题目，看了一下别人画的图才明白题的意思，和另外题 <code>435. 无重叠区间</code>有点相似</p><p>我们可以在每一次射击箭的时候尽量往用少一点的方向去想，当气球重叠时便一起射，这是局部最优，然后每次局部最优所造成的就是全局最优，射完全部气球所用的弓箭是最少，这便可以用贪心算法来求解</p><p>借用官方解答所给的图来解释</p><p><img src="https://assets.leetcode-cn.com/solution-static/452/1.png"></p><p>当把弓箭挪到右区间最小的时候（如第三个图的蓝色）就可以一箭四雕，因为题目所给的条件<code>xstart</code> ≤ x ≤ <code>xend</code>时气球就会给射爆，这里包含了边界值条件，所以在闭区间位置也满足</p><p>因此我就有了基本思路，先把这些气球排列，然后从第二个气球遍历，每次与前一个气球作比较，如果两个气球区间相交，那就可以略过当前气球进入下一次比较（做个标记，代表可以在这一个弓箭射完），具体如何略过看代码；如果气球不相交了，那就证明要用多一发弓箭了，此时弓箭数要加一，然后继续往下比较</p><p>下面是自己参考别人解答后写出来的代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">bool</span> <span class="token function">VecSort</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">findMinArrowShots</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> points<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> points<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>size<span class="token punctuation">)</span><span class="token comment">//数组为空</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>points<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>points<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>VecSort<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//按气球起点进行从小到大排序</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//返回结果，不为空至少需要一只箭</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//从前往后遍历气球</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">></span>points<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">//当前气球与前一个气球不重叠</span>                res<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token comment">//重叠则跳过当前气球</span>                <span class="token comment">//（利用闭区间最右位置可以射到的规则让其长度变短，以达到可跳过的当前气球目的）</span>                points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>std<span class="token operator">::</span><span class="token function">min</span><span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>points<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样做出来之后时间复杂度为<em>O(nlogn)<em>因为用了个快排，空间复杂度为</em>O(1)</em></p><img src="https://p6-tt.byteimg.com/origin/pgc-image/3af7d43845b04870bda4754ca1805c0e.jpg" alt="452.jpg" style="zoom:80%;" /><hr><h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a href="https://leetcode-cn.com/problems/partition-labels/">763. 划分字母区间</a></h2><p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p><p>示例：</p><blockquote><p>输入：S = “ababcbacadefegdehijhklij”<br>输出：[9,7,8]<br>解释：<br>划分结果为 “ababcbaca”, “defegde”, “hijhklij”。<br>每个字母最多出现在一个片段中。<br>像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。</p></blockquote><p>这种题型第一次见，不怎么会，因为尽可能地要划分多个区域，从而达到某个或多个字母只出现在这片区域中，那么就可以先记录下每个字母最后出现的位置</p><p>然后再次遍历字符串，不断更新标识符<code>end</code>，该标识符指向的是当前遍历过的字母中，最持久的字符最后出现的位置，也相当于是这片区域最后的位置，所以我们只用找出这个标识符最终的位置就能够划分一个区域出来了</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">partitionLabels</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> str_size <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>str_size<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>str_size <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>res<span class="token punctuation">;</span>        <span class="token keyword">int</span> map<span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//记录每个字母最后出现的位置</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>str_size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            map<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> start<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> end<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//记录分割数据的开头和结尾位置</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>str_size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            end <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">max</span><span class="token punctuation">(</span>end<span class="token punctuation">,</span>map<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//贪心策略地方，尽可能找到字母最后出现的位置从而划分区域</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> end<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">//如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>end<span class="token operator">-</span>start<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                start <span class="token operator">=</span> end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度<em>O(n)<em>，空间复杂度</em>O(1)</em></p><img src="https://p5-tt.byteimg.com/origin/pgc-image/c6d28e63caa845aba5e8479b6f016d58.jpg" alt="763.jpg" style="zoom:80%;" /><hr><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="88-合并两个有序数组—（简单）"><a href="#88-合并两个有序数组—（简单）" class="headerlink" title="88. 合并两个有序数组—（简单）"></a><a href="https://leetcode-cn.com/problems/merge-sorted-array/">88. 合并两个有序数组</a>—（简单）</h2><p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</p><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。</p><p>示例1：</p><blockquote><p>输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br>输出：[1,2,2,3,5,6]</p></blockquote><p>示例2：</p><blockquote><p>输入：nums1 = [1], m = 1, nums2 = [], n = 0<br>输出：[1]</p></blockquote><p>这道题是多指针中的一种题型，但是它需要的是逆向指针，知道原理后比较简单</p><p>因为这两个数组已经排好序，我们可以把两个指针分别放在两个数组的末尾，即 nums1 的m - 1 位和 nums2 的 n - 1 位每次将较大的那个数字复制到 nums1 的后边，然后向前移动一位。因为我们也要定位 nums1 的末尾，所以我们还需要第三个指针，以便复制。<br>在以下的代码里，我们直接利用 m 和 n 当作两个数组的指针，再额外创立一个 pos 指针，起始位置为 m + n - 1。每次向前移动 m 或 n 的时候，也要向前移动 pos。这里需要注意，如果 nums1的数字已经复制完，不要忘记把 nums2 的数字继续复制；如果 nums2 的数字已经复制完，剩余nums1 的数字不需要改变，因为它们已经被排好序。  </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> size1 <span class="token operator">=</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> size2 <span class="token operator">=</span> nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>size2<span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token comment">//需要三个指针，分别是m-1,n-1和m+n-1，前两个可以用m n 代替</span>        <span class="token keyword">int</span> pos <span class="token operator">=</span> m<span class="token operator">+</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        n<span class="token operator">--</span><span class="token punctuation">;</span>m<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> m<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            nums1<span class="token punctuation">[</span>pos<span class="token operator">--</span><span class="token punctuation">]</span><span class="token operator">=</span>nums1<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token operator">></span>nums2<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">?</span>nums1<span class="token punctuation">[</span>m<span class="token operator">--</span><span class="token punctuation">]</span><span class="token operator">:</span>nums2<span class="token punctuation">[</span>n<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            nums1<span class="token punctuation">[</span>pos<span class="token operator">--</span><span class="token punctuation">]</span><span class="token operator">=</span>nums2<span class="token punctuation">[</span>n<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度<em>O(m+n)<em>，因为指针最多遍历m+n个数，空间复杂度</em>O(1)</em></p><hr><h2 id="142-环形链表-II—（中等）"><a href="#142-环形链表-II—（中等）" class="headerlink" title="142. 环形链表 II—（中等）"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a>—（中等）</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p>说明：不允许修改给定的链表。</p><p><em>进阶：</em></p><p><em>你是否可以使用 O(1) 空间解决此题？</em></p><blockquote><p>示例：</p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="1" style="zoom:80%;" /><p>输入：head = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。</p></blockquote><p>本题第一次做稍微有难度，所使用的是快慢指针，两个指针都是从头结点开始，快指针每次走两格，慢指针每次走一格，如果他们可以相遇，就代表链表是有环的，因为快指针每次走的比慢指针多<code>1</code>格，只要是有环路肯定能相遇</p><p>其次，在第一次相遇后，我们将快指针重置为头结点位置，之后快慢指针<code>同时走</code>，每次都是走<code>1</code>步，直到两指针再一次相遇就是我们要找的环入口了，具体是为什么呢？我们看下面的图</p><img src="https://pic.leetcode-cn.com/3be69ecc0e8948a5c0d74edfaed34d3eb92768ab781c1516bf00e618621eda66-142%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82.png" alt="code" style="zoom:80%;" /><p>我们设<code>x</code>是头结点到环形入口节点的节点数，<code>y</code>是从入口节点到两个指针第一次相遇的节点的节点数，当第一次两指针在同一个节点相遇时，慢指针走了<code>x+y</code>，快指针走了<code>x+y+n(z+y)</code>其中<code>n(z+y)</code>是在环内多走了<code>n</code>圈</p><p>又因为快指针走的节点数是慢指针的两倍则有方程：<code>2(x+y)=x+y+n(z+y)</code>，化简的出<code>x=n(y+z)-y</code>，从n(y+z)提出一个y+z得出公式：<code>x=(n-1)(y+z)+z</code>，这个时候我们假设<code>n=1</code>，即快指针只用在环内多走一圈就，就可以得出<code>x=z</code></p><p>这样就得出了最终的结论：当两个指针在第一次相遇后，此时相遇节点到环形入口节点长度<code>等于</code>头结点到环形入口长度，那么问题就很容易了，我们随便将一个指针<code>重置</code>回头结点，再让两个指针同时出发，并且每一步只走<code>一格</code>长度，当再次相遇时，位置就是环形入口节点了</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode <span class="token operator">*</span><span class="token function">detectCycle</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token operator">||</span>head<span class="token operator">-></span>next<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token comment">//快指针</span>        ListNode<span class="token operator">*</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token comment">//慢指针</span>        <span class="token comment">//第一次相遇，判断是否有环路</span>        <span class="token keyword">do</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>fast<span class="token operator">||</span><span class="token operator">!</span>fast<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>            fast<span class="token operator">=</span>fast<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>            slow<span class="token operator">=</span>slow<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>slow<span class="token operator">!=</span>fast<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//重置快指针</span>        fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment">//第二次相遇则是入口</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token operator">!=</span>slow<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            fast <span class="token operator">=</span> fast<span class="token operator">-></span>next<span class="token punctuation">;</span>            slow <span class="token operator">=</span> slow<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> slow<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity笔记11-添加攻击属性</title>
      <link href="UnityNotes/Unity%E7%AC%94%E8%AE%B011-%E6%B7%BB%E5%8A%A0%E6%94%BB%E5%87%BB%E5%B1%9E%E6%80%A7/"/>
      <url>UnityNotes/Unity%E7%AC%94%E8%AE%B011-%E6%B7%BB%E5%8A%A0%E6%94%BB%E5%87%BB%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>在这一章节中我们来给人物还有史莱姆添加攻击的属性，同时也给史莱姆补充上攻击的动作，那么我们就开始吧</p><h1 id="创建有关攻击的ScriptableObject"><a href="#创建有关攻击的ScriptableObject" class="headerlink" title="创建有关攻击的ScriptableObject"></a>创建有关攻击的ScriptableObject</h1><p>首先还是新建文件夹和代码文件👇</p><img src="https://p5-tt.byteimg.com/origin/pgc-image/b58fb07a9dd74e99a87414a252bf97d5.png" alt="1.png" style="zoom:80%;" /><p>打开这个代码，我们来写一下有关攻击的属性</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">CreateAssetMenu</span><span class="token attribute-arguments"><span class="token punctuation">(</span>fileName <span class="token operator">=</span> <span class="token string">"New Data"</span><span class="token punctuation">,</span>menuName <span class="token operator">=</span> <span class="token string">"Attack/Attack Data"</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AttackData_SO</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">ScriptableObject</span></span><span class="token punctuation">&#123;</span>    <span class="token comment">//记录攻击相关属性</span>    <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">float</span></span> attackRange<span class="token punctuation">;</span><span class="token comment">//近战攻击范围</span>    <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">float</span></span> skillRange<span class="token punctuation">;</span><span class="token comment">//远程攻击范围</span>    <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">float</span></span> coolDown<span class="token punctuation">;</span><span class="token comment">//CD冷却</span>    <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">float</span></span> minDamage<span class="token punctuation">;</span><span class="token comment">//攻击最小伤害</span>    <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">float</span></span> maxDamage<span class="token punctuation">;</span><span class="token comment">//攻击最大伤害</span>    <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">float</span></span> criticalMultiplier<span class="token punctuation">;</span><span class="token comment">//暴击加成百分比</span>    <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">float</span></span> criticalChance<span class="token punctuation">;</span><span class="token comment">//暴击率</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打完代码之后我们就可以建立一个有关攻击的<code>ScriptableObject</code>了</p><img src="https://p6-tt.byteimg.com/origin/pgc-image/ab9faff156ca410f9a77dd7090b983e8.png" alt="2.png" style="zoom:80%;" /><p>然后我们可以根据自己需求进行属性值设定</p><img src="https://p6-tt.byteimg.com/origin/pgc-image/cc0abf9d1c1f4e6d8accc357cba98c51.png" alt="3.png" style="zoom:80%;" /><p>同时我们还要将它挂载到人物和敌人身上，我们打开<code>Monobehavior</code>文件夹下的<code>CharcterStates.cs</code>代码文件，这个代码文件是挂辅助将ScriptableObject挂载的</p><p>然后添加一行代码，接受外界提供的<code>Player BaseAttackData</code>的ScriptableObject</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token class-name">AttackData_SO</span> attackData<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后我们就可以回到史莱姆上挂载了</p><img src="https://p9-tt.byteimg.com/origin/pgc-image/ba22aeebd6224df78664695acf1c927f.png" alt="4.png" style="zoom:80%;" /><h1 id="补充之前的攻击相关代码"><a href="#补充之前的攻击相关代码" class="headerlink" title="补充之前的攻击相关代码"></a>补充之前的攻击相关代码</h1><p>还记得之前在写人物和史莱姆攻击时留下来的一些待补充代码吗？我们现在就可以逐步来完善它们了</p><p>第一个要修改的是<code>PlayerController.cs</code>里面人物的攻击距离，之前我们一直是默认为1，但是现在我们可以来补充它了</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token comment">//ScriptableObject相关变量</span><span class="token keyword">private</span> <span class="token class-name">CharcterStates</span> charcterStates<span class="token punctuation">;</span><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Awake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    charcterStates <span class="token operator">=</span> <span class="token generic-method"><span class="token function">GetComponent</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>CharcterStates<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token return-type class-name">IEnumerator</span> <span class="token function">MoveToAttackTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    agent<span class="token punctuation">.</span>isStopped <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    transform<span class="token punctuation">.</span><span class="token function">LookAt</span><span class="token punctuation">(</span>attactTarget<span class="token punctuation">.</span>transform<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//TODO:添加人物攻击距离</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>Vector3<span class="token punctuation">.</span><span class="token function">Distance</span><span class="token punctuation">(</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">,</span>attactTarget<span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">)</span><span class="token operator">></span>          charcterStates<span class="token punctuation">.</span>attackData<span class="token punctuation">.</span>attackRange<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//比较人物和敌人的距离是否大于0攻击距离，Distance()可以比较两个Vector3距离</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>agent<span class="token punctuation">.</span>destination <span class="token operator">=</span> attactTarget<span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">;</span>        <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在声明一个<code>CharcterStates</code>后，我们要把这里的while判断条件右边的1改成<code>charcterStates.attackData.attackRange</code>以获取攻击距离判断</p><p>然后是<code>EnemyController.cs</code>，这里修改量比较大</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token comment">//ScriptableObject相关变量</span><span class="token keyword">private</span> <span class="token class-name">CharcterStates</span> charcterStates<span class="token punctuation">;</span><span class="token comment">//这个敌人攻击相关的</span><span class="token keyword">private</span> <span class="token class-name"><span class="token keyword">float</span></span> lastAttackTime<span class="token punctuation">;</span><span class="token comment">//上一次攻击的时间（用来实现CD冷却效果）</span><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Awake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//...</span>    charcterStates <span class="token operator">=</span> <span class="token generic-method"><span class="token function">GetComponent</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>CharcterStates<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lastAttackTime <span class="token operator">=</span> charcterStates<span class="token punctuation">.</span>attackData<span class="token punctuation">.</span>coolDown<span class="token punctuation">;</span><span class="token comment">//开始获取冷却时间</span><span class="token punctuation">&#125;</span><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//...</span>    lastAttackTime<span class="token operator">-=</span>Time<span class="token punctuation">.</span>deltaTime<span class="token punctuation">;</span><span class="token comment">//每一帧都减冷却</span><span class="token punctuation">&#125;</span><span class="token comment">//判断攻击距离函数</span><span class="token return-type class-name"><span class="token keyword">bool</span></span> <span class="token function">TargetInAttackRange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//人物在敌人的攻击距离内</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>attackTarget<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> Vector3<span class="token punctuation">.</span><span class="token function">Distance</span><span class="token punctuation">(</span>attackTarget<span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">,</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">)</span>            <span class="token operator">&lt;=</span> charcterStates<span class="token punctuation">.</span>attackData<span class="token punctuation">.</span>attackRange<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token return-type class-name"><span class="token keyword">bool</span></span> <span class="token function">TargetInSkillRange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//人物在敌人的远程攻击距离内</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>attackTarget<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> Vector3<span class="token punctuation">.</span><span class="token function">Distance</span><span class="token punctuation">(</span>attackTarget<span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">,</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">)</span>            <span class="token operator">&lt;=</span> charcterStates<span class="token punctuation">.</span>attackData<span class="token punctuation">.</span>skillRange<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SwitchEnemyStates</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//...</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span>enemyStates<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> EnemyStates<span class="token punctuation">.</span>CHASE<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>追击            <span class="token comment">//...</span>            <span class="token comment">//TODO:在攻击范围攻击</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">TargetInAttackRange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token function">TargetInSkillRange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                isFollow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//停止跟随</span>                agent<span class="token punctuation">.</span>isStopped <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">//停下来</span>                <span class="token comment">//攻击冷却完成进行攻击，在前面声明了</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>lastAttackTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    lastAttackTime <span class="token operator">=</span> charcterStates<span class="token punctuation">.</span>attackData<span class="token punctuation">.</span>coolDown<span class="token punctuation">;</span>                    <span class="token comment">//暴击判断，随机获取的数值（0到1之间）在暴击率内则是暴击</span>                    <span class="token comment">//charcterStates.isCritical下面会讲，用来记录是否暴击的变量</span>                    charcterStates<span class="token punctuation">.</span>isCritical <span class="token operator">=</span> Random<span class="token punctuation">.</span><span class="token keyword">value</span> <span class="token operator">&lt;</span>                        charcterStates<span class="token punctuation">.</span>attackData<span class="token punctuation">.</span>criticalChance<span class="token punctuation">;</span>                    <span class="token comment">//执行攻击</span>                    <span class="token function">Attack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                            <span class="token punctuation">&#125;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//攻击控制函数</span><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Attack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    transform<span class="token punctuation">.</span><span class="token function">LookAt</span><span class="token punctuation">(</span>attackTarget<span class="token punctuation">.</span>transform<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//攻击时敌人看向目标</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">TargetInAttackRange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//近身攻击动画</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">TargetInSkillRange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//远程或技能攻击动画</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到中间控制攻击的时候有一个<code>charcterStates.isCritical</code>的新变量，这是在<code>CharcterStates.cs</code>中新声明的，可以供外界访问的布尔值，用来记录当前是否为暴击，同时虽然它是public属性，但是我们可以用<code>[HideInInspector]</code>将其隐藏起来</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token comment">//CharcterStates.cs</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CharcterStates</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MonoBehaviour</span></span><span class="token punctuation">&#123;</span>    <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">HideInInspector</span></span><span class="token punctuation">]</span>    <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">bool</span></span> isCritical<span class="token punctuation">;</span><span class="token comment">//是否暴击</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码开始复杂了起来，需要好好理解哦</p><h1 id="添加攻击动画"><a href="#添加攻击动画" class="headerlink" title="添加攻击动画"></a>添加攻击动画</h1><p>我们看到上面的代码有两个动画需要我们来添加，一个是近身攻击动画，一个是远程或技能动画</p><img src="https://p6-tt.byteimg.com/origin/pgc-image/3d2834012c04439d824cd2b2bbb56556.png" alt="5.png" style="zoom:80%;" /><p>我们按上图这样编辑动画控制器，建立两个<code>Trigger</code>类型的变量来分别控制<code>Attack01</code>和<code>Attack02</code>的动画触发条件，其次要注意的地方就是由巡逻状态切换过去攻击状态时并不需要动画的过渡效果，同时记得不要忘记把触发条件选择上</p><p>然后我们回到代码中，找到控制攻击的<code>Attack()</code>函数补充一下</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Attack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//控制敌人攻击的函数</span>    transform<span class="token punctuation">.</span><span class="token function">LookAt</span><span class="token punctuation">(</span>attackTarget<span class="token punctuation">.</span>transform<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//攻击时敌人看向目标</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">TargetInAttackRange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//近身攻击动画</span>        anim<span class="token punctuation">.</span><span class="token function">SetTrigger</span><span class="token punctuation">(</span><span class="token string">"Attack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">TargetInSkillRange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//远程或技能攻击动画</span>        anim<span class="token punctuation">.</span><span class="token function">SetTrigger</span><span class="token punctuation">(</span><span class="token string">"Skill"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样我们就实现了基本的攻击效果</p><p>我们还可以把暴击效果加上，可以把Skill动画换成我们的暴击效果动画</p><p>再次打开动画控制器，添加一个布尔类型的变量<code>Critical</code></p><p>我们把<code>Attack02</code>当做暴击动画，然后调整一下动画的切换过程</p><img src="https://p5-tt.byteimg.com/origin/pgc-image/d665b2ca32e840c8868baf19b0e587cf.png" alt="6.png" style="zoom:80%;" /><p>这里注意一点就是还要区别普通攻击时<code>Critical</code>触发状态应该是<code>false</code>，以防动画冲突</p><img src="https://p26-tt.byteimg.com/origin/pgc-image/4745d79d02704b0c9ef1bf7903896d5b.png" alt="7.png" style="zoom:80%;" /><p>然后返回代码，我们要时刻获取是否为暴击状态，那么可以如下操作</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token comment">//实时更新Animator里面史莱姆的状态布尔值</span><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SwitchAnimation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    anim<span class="token punctuation">.</span><span class="token function">SetBool</span><span class="token punctuation">(</span><span class="token string">"Critical"</span><span class="token punctuation">,</span>charcterStates<span class="token punctuation">.</span>isCritical<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//时刻获取是否为暴击</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于<code>SwitchAnimation()</code>是放在Update()里面运行的，所以可以把暴击状态放在这里让它每一刻都获取暴击状态</p><h1 id="修复人物脱离敌人攻击范围后敌人不动问题"><a href="#修复人物脱离敌人攻击范围后敌人不动问题" class="headerlink" title="修复人物脱离敌人攻击范围后敌人不动问题"></a>修复人物脱离敌人攻击范围后敌人不动问题</h1><p>最后，我们有个小问题要修复一下</p><p>由于之前我们写了发现敌人时敌人就要停下来</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">agent<span class="token punctuation">.</span>isStopped <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>所以，如果人物脱离敌人攻击范围时我们就要把停止状态取消掉，不然就会出现敌人停留在原地的现象</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">case</span> EnemyStates<span class="token punctuation">.</span>CHASE<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>追击<span class="token comment">//...</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">FoundPlayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//拉脱回上一个状态</span>        agent<span class="token punctuation">.</span>destination <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">;</span><span class="token comment">//人物脱离追击范围后，敌人停在当前位置</span>        isFollow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        isFollow <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">//找到人物就跑着追</span>        agent<span class="token punctuation">.</span>isStopped <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//&lt;-----------停止状态取消</span>        agent<span class="token punctuation">.</span>speed<span class="token operator">=</span>speed<span class="token punctuation">;</span>        <span class="token comment">//人物进到敌人的范围会给追击</span>        agent<span class="token punctuation">.</span>destination<span class="token operator">=</span>attackTarget<span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么到这，我们就完成了给人物和敌人添加攻击属性，并且还为敌人加了普通攻击和暴击等攻击动画，让游戏开始变得有模有样起来</p>]]></content>
      
      
      <categories>
          
          <category> Unity学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity笔记10-为人物添加属性</title>
      <link href="UnityNotes/Unity%E7%AC%94%E8%AE%B010-%E4%B8%BA%E4%BA%BA%E7%89%A9%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/"/>
      <url>UnityNotes/Unity%E7%AC%94%E8%AE%B010-%E4%B8%BA%E4%BA%BA%E7%89%A9%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>🎈<strong>注意</strong>：从这一章开始，笔记内容会在一些比较简单的地方进行简略</p><h1 id="认识Scriptable-Object"><a href="#认识Scriptable-Object" class="headerlink" title="认识Scriptable Object"></a>认识Scriptable Object</h1><p>这一章开始我们会频繁地使用代码以及更多地<code>ScriptableObject</code>起来，什么是Scriptable Object呢？就像下图我们的<code>Pipeline Setting</code>文件夹下的东西就是我们一种Scriptable Object实现方式</p><img src="https://p3-tt.byteimg.com/origin/pgc-image/158275c63e164f448921282c6cefad4a.png" alt="1.png" style="zoom:80%;" /><p>关于它的更多特性可以上网搜索资料，这里不过多描述</p><p>那么我们这次就拿它来给我们的人物包括敌人创建一些基本的属性值，如：血量、防御值等等</p><h1 id="为人物添加属性值"><a href="#为人物添加属性值" class="headerlink" title="为人物添加属性值"></a>为人物添加属性值</h1><p>首先要在<code>Scripts</code>文件夹创建一些文件夹以便日后管理</p><img src="https://p3-tt.byteimg.com/origin/pgc-image/5a19a7e92b1e41d1ad6996dbb1a0563a.png" alt="2.png" style="zoom:80%;" /><p>两个文件夹分别是存放挂载（MonoBehavior）与建立（ScriptableObject）我们的Scriptable Object的代码文件用的</p><p>除了上面的两个文件夹外，还有专门有用来存放<code>ScriptableObject</code>数据的文件夹</p><img src="https://p6-tt.byteimg.com/origin/pgc-image/dd8e1a4b80a646f5835de7c6834b4f19.png" alt="3.png" style="zoom:80%;" /><h2 id="创建专门存放属性值的Scriptable-Object"><a href="#创建专门存放属性值的Scriptable-Object" class="headerlink" title="创建专门存放属性值的Scriptable Object"></a>创建专门存放属性值的Scriptable Object</h2><p>之后再在<code>Charcter States/ScriptableObject</code>文件夹下新建个代码脚本文件<code>CharcterData_SO.cs</code></p><p>代码内容如下</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token comment">//添加右键菜单</span><span class="token punctuation">[</span><span class="token function">CreateAssetMenu</span><span class="token punctuation">(</span>fileName <span class="token operator">=</span> <span class="token string">"New Data"</span><span class="token punctuation">,</span>menuName <span class="token operator">=</span> <span class="token string">"Charcter States/Data"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CharcterData_SO</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">ScriptableObject</span></span><span class="token comment">//注意这个类继承的是ScriptableObject类</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一段代码可以在右键菜单中添加一个选项</p><img src="https://p3-tt.byteimg.com/origin/pgc-image/54d3f5656d33441fa14682fcf33ee71f.png" alt="4.1.png" style="zoom:80%;" /><p>创建出来的就是一个基于<code>CharcterData_SO</code>的ScriptableObject，我们将其命名为<code>Player Data</code></p><img src="https://p3-tt.byteimg.com/origin/pgc-image/5ff5985ea4a742efa56703027a071053.png" alt="4.png" style="zoom:80%;" /><img src="https://p26-tt.byteimg.com/origin/pgc-image/b6c7ca8158fb45f89fa331bffdba9eba.png" alt="5.png" style="zoom:80%;" /><p>这个时候还是什么都没有的，我们重新打开<code>CharcterData_SO.cs</code>继续填写代码</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token comment">//添加右键菜单</span><span class="token punctuation">[</span><span class="token function">CreateAssetMenu</span><span class="token punctuation">(</span>fileName <span class="token operator">=</span> <span class="token string">"New Data"</span><span class="token punctuation">,</span>menuName <span class="token operator">=</span> <span class="token string">"Charcter States/Data"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CharcterData_SO</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">ScriptableObject</span></span><span class="token punctuation">&#123;</span>    <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Header</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">"States Info（属性信息）"</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span>    <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">int</span></span> maxHealth<span class="token punctuation">;</span><span class="token comment">//最大生命值</span>    <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">int</span></span> currentHealthl<span class="token punctuation">;</span><span class="token comment">//当前生命值</span>    <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">int</span></span> baseDefence<span class="token punctuation">;</span><span class="token comment">//基础防御值</span>    <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">int</span></span> currentDefence<span class="token punctuation">;</span><span class="token comment">//当前防御值</span>    <span class="token comment">//攻击力比较复杂，打算分开写，这里暂时不写着先</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们赋予了4个属性，当Unity编译之后在我们刚刚新创建的<code>Player Data</code>就有了改变，多了几个属性值出来</p><img src="https://p3-tt.byteimg.com/origin/pgc-image/a9cdd098cf54461a8f0387b00d539f9b.png" alt="6.png" style="zoom:80%;" /><h2 id="挂载Scriptable-Object"><a href="#挂载Scriptable-Object" class="headerlink" title="挂载Scriptable Object"></a>挂载Scriptable Object</h2><p>那么有了存放的ScriptableObject之后，我们还要想办法将其运用（即挂载）到人物身上，方便数据之间的读取</p><p>我们在<code>Charcter States/MonoBehavior</code>中新建一个代码脚本，命名为<code>CharcterStates.cs</code></p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CharcterStates</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MonoBehaviour</span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">CharcterData_SO</span> charcterData<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> MaxHealth<span class="token punctuation">&#123;</span>        <span class="token keyword">get</span><span class="token punctuation">&#123;</span><span class="token comment">//取值属性</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>charcterData <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> charcterData<span class="token punctuation">.</span>maxHealth<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">set</span><span class="token punctuation">&#123;</span><span class="token comment">//赋值属性</span>            charcterData<span class="token punctuation">.</span>maxHealth <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//TODO:照上面模式写出其它几个属性值</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码中用到了C#的<strong>属性</strong>，即<code>get</code>和<code>set</code>来读取或写入人物的最大生命值，剩下的几个属性值也是同样方法来写</p><p>写好之后我们保存一下代码，将代码文件当作组件添加到人物上面</p><img src="https://p5-tt.byteimg.com/origin/pgc-image/4ccad37c1e6e4765a5459eef8bf7e044.png" alt="7.png" style="zoom:80%;" /><p>可以看到它需要接受一个<code>CharcterData_SO</code>类型的</p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> Unity学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity笔记9-敌人的随机巡逻</title>
      <link href="UnityNotes/Unity%E7%AC%94%E8%AE%B09-%E6%95%8C%E4%BA%BA%E7%9A%84%E9%9A%8F%E6%9C%BA%E5%B7%A1%E9%80%BB/"/>
      <url>UnityNotes/Unity%E7%AC%94%E8%AE%B09-%E6%95%8C%E4%BA%BA%E7%9A%84%E9%9A%8F%E6%9C%BA%E5%B7%A1%E9%80%BB/</url>
      
        <content type="html"><![CDATA[<p>​    在上一章节我们实现了敌人的追击效果，也就是敌人的追击状态，而这一章节我们来实现它的巡逻状态效果</p><h1 id="实时显示巡逻范围"><a href="#实时显示巡逻范围" class="headerlink" title="实时显示巡逻范围"></a>实时显示巡逻范围</h1><p>​    由于之后会有一个记录敌人巡逻范围的变量，因此为了方便到时候的设置，这里介绍一个函数可以实时在<code>Scene</code>窗口上显示这个范围出来</p><p>​    因为这个变量是在<code>EnemyController.cs</code>代码文件里声明的，所以我们就直接在此代码文件里用这个函数</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnemyController</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MonoBehaviour</span></span><span class="token punctuation">&#123;</span>    <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Header</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">"Patrol State（巡逻状态的设置项）"</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span>    <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">float</span></span> potralRange<span class="token punctuation">;</span><span class="token comment">//巡逻圈的半径大小</span>    <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OnDrawGizmosSelected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        Gizmos<span class="token punctuation">.</span>color <span class="token operator">=</span> Color<span class="token punctuation">.</span>blue<span class="token punctuation">;</span>        Gizmos<span class="token punctuation">.</span><span class="token function">DrawWireSphere</span><span class="token punctuation">(</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">,</span>potralRange<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在敌人当前位置画一个球形范围的线</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <code>OnDrawGizmosSelected()</code>是来自于<code>MonoBehaviour</code>类的一个函数，这里代码意思是只要选中了代码所在的对象上就会绘画出一个球形的线，而这个球形的半径就是<code>potralRange</code>，例如当此值调成为2时，球形如下图所示👇</p><img src="https://p26-tt.byteimg.com/origin/pgc-image/8c138a5dc08f44ed92287bc624597238.png" alt="1.png" style="zoom:80%;" /><p>​    当然你也可以添加其它参数的可视化效果，可以自由发挥</p><h1 id="实现敌人巡逻"><a href="#实现敌人巡逻" class="headerlink" title="实现敌人巡逻"></a>实现敌人巡逻</h1><p>​    接下来就进入正题，如何实现敌人巡逻，我们可以在它设定的巡逻范围内获得一个点，然后再让敌人走过去，反复执行这个动作，就可以让敌人巡逻起来了</p><h2 id="随机获得巡逻范围内的一个点"><a href="#随机获得巡逻范围内的一个点" class="headerlink" title="随机获得巡逻范围内的一个点"></a>随机获得巡逻范围内的一个点</h2><p>​    要获得巡逻范围内的一个点，我们就要有一个Vector3变量来记录这个点，然后每次使用随机数来改变它，所以我们创建一个函数来专门随机获得这个点的值</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token class-name">Vector3</span> wayPoint<span class="token punctuation">;</span><span class="token comment">//敌人巡逻的下一个随机目标点</span><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">GetNewWayPoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//获取下一个巡逻的随机目标点</span>    <span class="token comment">//Y轴是控制高度的，所以不用获取，保持原来的就行</span>    <span class="token comment">//获取的范围时[-potralRange,potralRange]</span>    <span class="token class-name"><span class="token keyword">float</span></span> randomX <span class="token operator">=</span> Random<span class="token punctuation">.</span><span class="token function">Range</span><span class="token punctuation">(</span><span class="token operator">-</span>potralRange<span class="token punctuation">,</span>potralRange<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name"><span class="token keyword">float</span></span> randomZ <span class="token operator">=</span> Random<span class="token punctuation">.</span><span class="token function">Range</span><span class="token punctuation">(</span><span class="token operator">-</span>potralRange<span class="token punctuation">,</span>potralRange<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//在敌人自己本身的坐标点上进行取随机点</span>    <span class="token class-name">Vector3</span> randomPoint <span class="token operator">=</span>        <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Vector3</span><span class="token punctuation">(</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">.</span>x<span class="token operator">+</span>randomX<span class="token punctuation">,</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">.</span>y<span class="token punctuation">,</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">.</span>z<span class="token operator">+</span>randomZ<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//FIXME:有可能出现问题</span>    wayPoint <span class="token operator">=</span> randomPoint<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    由于Y轴是记录敌人所在的高度的，所以这里暂时不用获取随机数，保持原来效果</p><p>​    同时上面代码中给标记了一个FIXME，有可能出现一个问题，我们先放一边到时候再来发现修改</p><h2 id="修改状态切换"><a href="#修改状态切换" class="headerlink" title="修改状态切换"></a>修改状态切换</h2><p>​    获取了随机点后，我们还要回到<code>SwitchStates()</code>函数中修改一下状态的衔接</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">switch</span><span class="token punctuation">(</span>enemyStates<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">case</span> EnemyStates<span class="token punctuation">.</span>PATROL<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>巡逻        isChase <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//不是追逐动画</span>        agent<span class="token punctuation">.</span>speed <span class="token operator">=</span> speed<span class="token operator">*</span><span class="token number">0.5f</span><span class="token punctuation">;</span><span class="token comment">//巡逻速度是追逐速度的一半</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>Vector3<span class="token punctuation">.</span><span class="token function">Distance</span><span class="token punctuation">(</span>wayPoint<span class="token punctuation">,</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> agent<span class="token punctuation">.</span>stoppingDistance<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//如果下一个巡逻点和当前人物的坐标点小于等于可移动距离则不移动</span>            isWalk <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//不播放走路的动画</span>            <span class="token function">GetNewWayPoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取下一个巡逻点随机数</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            <span class="token comment">//满足行走条件</span>            isWalk <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">//敌人动画改为走路动画</span>            agent<span class="token punctuation">.</span>destination <span class="token operator">=</span> wayPoint<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    上面就是判断到敌人为巡逻状态时要做的事情，里面还有一个if语句是用于判断如果下一个巡逻的点小于或等于导航组件可以移动的范围时就不移动，再获得下一个巡逻点</p><p>🎄而 <a href="https://docs.unity.cn/cn/2020.3/ScriptReference/AI.NavMeshAgent-stoppingDistance.html">stoppingDistance</a> 是<code>Nav Mesh Agent</code>组件里的一个属性，代表<code>停止距离</code>，即如果给定的目的点与当前点的距离小于这个值的话，敌人时不会进行移动的，这个值我们也可以在属性面板中进行调整</p><img src="https://p5-tt.byteimg.com/origin/pgc-image/107272d76d03463c8012565f3e821a87.png" alt="2.png" style="zoom:80%;" /><p>​    了解到这些之后我们继续回到代码中，我们写了巡逻状态时要做的事情，那么我们该怎样判断并进入巡逻状态呢？下面我们就来写一下这些代码</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Header</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">"Basic Settings"</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span><span class="token comment">//...</span><span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">bool</span></span> isGuard<span class="token punctuation">;</span><span class="token comment">//当前敌人是否为警卫（警戒状态）</span><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//开始游戏时先检测是否勾选了守卫状态</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>isGuard<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        enemyStates <span class="token operator">=</span> EnemyStates<span class="token punctuation">.</span>GUARD<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        enemyStates <span class="token operator">=</span> EnemyStates<span class="token punctuation">.</span>PATROL<span class="token punctuation">;</span>        <span class="token function">GetNewWayPoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//防止开始时巡逻点是空的默认走到地图(0,0,0)位置</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    这里我们新建了一个公开的布尔值变量<code>isGuard</code>，可以直接在属性面板勾选，用来判断当前敌人是否为一个守卫，如果为守卫就不会进行巡逻了</p><p>​    在弄好这些之后，敌人巡逻的基本功能就实现了，现在我们就可以去试玩一下了</p><h2 id="修复一些问题"><a href="#修复一些问题" class="headerlink" title="修复一些问题"></a>修复一些问题</h2><p>​    在试玩的过程中，会出现一些问题，我们下面就来修复它们</p><h3 id="敌人巡逻的范围越来越远"><a href="#敌人巡逻的范围越来越远" class="headerlink" title="敌人巡逻的范围越来越远"></a>敌人巡逻的范围越来越远</h3><p>​    首先是敌人巡逻范围的问题，如果只依照上面的代码我们会发现敌人的巡逻范围会越来越远，这是因为取随机坐标点的代码逻辑考虑不对劲</p><p>​    我们回到上面的标有FIXME代码块中</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token comment">//在敌人自己本身的坐标点上进行取随机点</span>    <span class="token class-name">Vector3</span> randomPoint <span class="token operator">=</span>        <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Vector3</span><span class="token punctuation">(</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">.</span>x<span class="token operator">+</span>randomX<span class="token punctuation">,</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">.</span>y<span class="token punctuation">,</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">.</span>z<span class="token operator">+</span>randomZ<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    出现问题的就是在上面这一句代码，我们取到的下一个随机目标点是基于敌人现在的位置基础上的，也就是每次取到的随机点都与现在位置相加，这就不对了，如果一直往同一个方向相加，只会导致敌人走的越来越远</p><p>​    因此这里<strong>不应该</strong><code>transform.position+xxx</code></p><p>​    </p><p>​    那么解决方案怎么样做呢？我们可以在游戏开始初始化把当前敌人所在的位置记录下来，然后每次取随机点是基于这个点来进行坐标相加的</p><p>​    同时这个坐标点也不止在巡逻状态这里用得到，我们在守卫状态下也需要这个初始坐标点，守卫状态下如果追击敌人脱战之后，我们必须让敌人回到这个初始坐标点继续守卫</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">private</span> <span class="token class-name">Vector3</span> puardPos<span class="token punctuation">;</span><span class="token comment">//当前敌人游戏开始时的初始位置</span><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Awake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//...</span> guardPos <span class="token operator">=</span> guardPos <span class="token operator">=</span> transform<span class="token punctuation">.</span>position<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">GetNewWayPoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//...</span>    <span class="token class-name">Vector3</span> randomPoint <span class="token operator">=</span>        <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Vector3</span><span class="token punctuation">(</span>guardPos<span class="token punctuation">.</span>x<span class="token operator">+</span>randomX<span class="token punctuation">,</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">.</span>y<span class="token punctuation">,</span>guardPos<span class="token punctuation">.</span>z<span class="token operator">+</span>randomZ<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    按照上面的代码修改，我们就解决了这个问题</p><p>​    🎈<strong>要注意</strong>：新的坐标点的Y轴还是以敌人当前位置为基础的</p><h3 id="敌人移动卡住"><a href="#敌人移动卡住" class="headerlink" title="敌人移动卡住"></a>敌人移动卡住</h3><p>​    第二个可能遇到的问题就是可能敌人走着走着会突然给卡住，但它仍然处于移动状态，这可能是因为所获取的目标点为<strong>不可移动区域</strong>造成的，例如树木、石头所在的点</p><img src="https://p5-tt.byteimg.com/origin/pgc-image/e5d07eb926e74385a3d3454bf171703c.png" alt="3.png" style="zoom:80%;" /><p>​    因此解决方法就是我们在获取点之后要判断一下所获得的点是否为到达的点，如果不是就再获取一遍</p><p>​    这里可以用到 <a href="https://docs.unity.cn/cn/2020.3/ScriptReference/AI.NavMeshAgent.html">NavMeshAgent</a> 的一个方法 <a href="https://docs.unity.cn/cn/2020.3/ScriptReference/AI.NavMeshAgent.SamplePathPosition.html">SamplePathPosition()</a> ，可以帮助我们来判断敌人到目标点是否可以行走，我们回到<code>GetNewWayPoint()</code>函数中</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">GetNewWayPoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//获取下一个巡逻的随机目标点</span>    <span class="token comment">//Y轴是控制高度的，所以不用获取，保持原来的就行</span>    <span class="token comment">//获取的范围时[-potralRange,potralRange]</span>    <span class="token class-name"><span class="token keyword">float</span></span> randomX <span class="token operator">=</span> Random<span class="token punctuation">.</span><span class="token function">Range</span><span class="token punctuation">(</span><span class="token operator">-</span>potralRange<span class="token punctuation">,</span>potralRange<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name"><span class="token keyword">float</span></span> randomZ <span class="token operator">=</span> Random<span class="token punctuation">.</span><span class="token function">Range</span><span class="token punctuation">(</span><span class="token operator">-</span>potralRange<span class="token punctuation">,</span>potralRange<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Vector3</span> randomPoint <span class="token operator">=</span>        <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Vector3</span><span class="token punctuation">(</span>guardPos<span class="token punctuation">.</span>x<span class="token operator">+</span>randomX<span class="token punctuation">,</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">.</span>y<span class="token punctuation">,</span>guardPos<span class="token punctuation">.</span>z<span class="token operator">+</span>randomZ<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//检测下个点是否可行</span>    <span class="token class-name">NavMeshHit</span> hit<span class="token punctuation">;</span>    wayPoint <span class="token operator">=</span><span class="token comment">//如果新的目标点可以到达则赋值，否则则把敌人当前所在点赋值</span>        NavMesh<span class="token punctuation">.</span><span class="token function">SamplePosition</span><span class="token punctuation">(</span>randomPoint<span class="token punctuation">,</span><span class="token keyword">out</span> hit<span class="token punctuation">,</span>potralRange<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">?</span> hit<span class="token punctuation">.</span>position <span class="token punctuation">:</span> transform<span class="token punctuation">.</span>position<span class="token punctuation">;</span>    <span class="token comment">//提供一个参考点，输出属性的网格信息</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    这样我们就解决了敌人会卡住的问题</p><h3 id="增加敌人等待时间"><a href="#增加敌人等待时间" class="headerlink" title="增加敌人等待时间"></a>增加敌人等待时间</h3><p>​    还有一个可以完善的地方就是敌人在移动到一个新的点后，它会立即又前往下一个地点，这里可以为它增加一些等待时间</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Header</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">"Patrol State（巡逻状态的设置项）"</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span><span class="token comment">//...</span><span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">float</span></span> lookAtTime<span class="token punctuation">;</span><span class="token comment">//敌人到达一个点停留的时间</span><span class="token keyword">private</span> <span class="token class-name"><span class="token keyword">float</span></span> remainLookAtTime<span class="token punctuation">;</span><span class="token comment">//还剩下的停留时间</span><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SwitchEnemyStates</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//...</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span>enemyStates<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">FoundPlayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                enemyStates <span class="token operator">=</span> EnemyStates<span class="token punctuation">.</span>CHASE<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token comment">//脱离战斗后判断回到守卫状态还是巡逻状态</span>                enemyStates <span class="token operator">=</span> isGuard <span class="token punctuation">?</span> EnemyStates<span class="token punctuation">.</span>GUARD <span class="token punctuation">:</span> EnemyStates<span class="token punctuation">.</span>PATROL<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//判断是否到了随机巡逻点</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>Vector3<span class="token punctuation">.</span><span class="token function">Distance</span><span class="token punctuation">(</span>wayPoint<span class="token punctuation">,</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> agent<span class="token punctuation">.</span>stoppingDistance<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">//如果下一个巡逻点和当前人物的坐标点小于等于可移动距离则不移动</span>                isWalk <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//不播放走路的动画</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>remainLookAtTime <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//如果剩余等待时间大于0则继续等待</span>                    remainLookAtTime <span class="token operator">-=</span> Time<span class="token punctuation">.</span>deltaTime<span class="token punctuation">;</span>                <span class="token keyword">else</span>                    <span class="token function">GetNewWayPoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取下一个巡逻点随机数</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token comment">//满足行走条件</span>                isWalk <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">//敌人动画改为走路动画</span>                agent<span class="token punctuation">.</span>destination <span class="token operator">=</span> wayPoint<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//PATROL</span>    <span class="token punctuation">&#125;</span><span class="token comment">//...</span><span class="token punctuation">&#125;</span><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">GetNewWayPoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//获取下一个巡逻的随机目标点</span>    remainLookAtTime <span class="token operator">=</span> lookAtTime<span class="token punctuation">;</span><span class="token comment">//重置剩余等待时间</span>    <span class="token comment">//...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    上面代码中我们添加了两个变量，<code>lookAtTime</code>表示需要等待时间的长度（可供外界进行调整），<code>remainLookAtTime</code>表示当前敌人还剩余的等待时间，然后我们在<code>SwitchEnemyStates()</code>函数里的追击状态中判断敌人到达了目标点就开始逐帧递减<code>remainLookAtTime</code>，当减到小于0敌人才会开始走动，同时再一次调用<code>GetNewWayPoint()</code>时会重置<code>remainLookAtTime</code></p><p>​    🎈注意：<code>lookAtTime</code>的单位是<strong>秒</strong></p><p>​    在switch代码前面还添加了一条语句用来判断脱离战斗后敌人回到守卫状态还是巡逻状态，这可以让我们敌人更加完善</p><p>​    到这里，本章的目的就实现了，我们让敌人随机巡逻了起来，快去游戏中试试吧！</p>]]></content>
      
      
      <categories>
          
          <category> Unity学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity笔记8--为敌人添加追击效果以及动画切换管理</title>
      <link href="UnityNotes/Unity%E7%AC%94%E8%AE%B08-%E4%B8%BA%E6%95%8C%E4%BA%BA%E6%B7%BB%E5%8A%A0%E8%BF%BD%E5%87%BB%E6%95%88%E6%9E%9C%E4%BB%A5%E5%8F%8A%E5%8A%A8%E7%94%BB%E5%88%87%E6%8D%A2%E7%AE%A1%E7%90%86/"/>
      <url>UnityNotes/Unity%E7%AC%94%E8%AE%B08-%E4%B8%BA%E6%95%8C%E4%BA%BA%E6%B7%BB%E5%8A%A0%E8%BF%BD%E5%87%BB%E6%95%88%E6%9E%9C%E4%BB%A5%E5%8F%8A%E5%8A%A8%E7%94%BB%E5%88%87%E6%8D%A2%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<!--终于期末考完试了，可以回到Unity上来了😃--><p>​    我们来继续完善敌人，还记得我们有个动画切换的框架代码摆在那吗？这一次我们来为敌人添加追击效果并且对不同状态下的动画切换进行管理</p><h1 id="保存修改后的素材"><a href="#保存修改后的素材" class="headerlink" title="保存修改后的素材"></a>保存修改后的素材</h1><p>​    在进行切换动画之前，我们先将上一次修改后的主角和史莱姆保存为一个素材对象，这方便以后我们的使用，特别是史莱姆，将其保存为素材对象后就可以批量创建敌人了</p><h2 id="保存主角为素材对象"><a href="#保存主角为素材对象" class="headerlink" title="保存主角为素材对象"></a>保存主角为素材对象</h2><p>​    由于我们的主角小狗在之前就保存为素材了，而在上一章我们为其添加了一个胶囊碰撞体，这里我们只用将胶囊碰撞体保存一下就行了</p><p>​    在<code>Hierarchy</code>视图选择我们的小人<code>Player</code>，然后找到胶囊碰撞体组件，右键它，按下图找到<code>Added Component-&gt;Apply to Prefab &#39;Player&#39;</code>，点击它就可以将新增加的胶囊碰撞体应用在原本的素材上了</p><img src="https://p9-tt.byteimg.com/origin/pgc-image/f15d609363c14d13b3e1a79616db15e6.png" alt="1.png" style="zoom:80%;" /><h2 id="保存史莱姆敌人为素材对象"><a href="#保存史莱姆敌人为素材对象" class="headerlink" title="保存史莱姆敌人为素材对象"></a>保存史莱姆敌人为素材对象</h2><p>​    保存史莱姆也是一个简单的事情，只用在<code>Hierarchy</code>视图下将史莱姆拖拽到到<code>Prefab-&gt;Characters</code>文件夹下就行了，注意在弹出的窗口中选择<code>Original Prefab</code></p><img src="https://p3-tt.byteimg.com/origin/pgc-image/e4d3d1be8f5a4a63aae9fa7f85938fdb.png" alt="2.png" style="zoom:80%;" /><h1 id="思考如何敌人的追击效果"><a href="#思考如何敌人的追击效果" class="headerlink" title="思考如何敌人的追击效果"></a>思考如何敌人的追击效果</h1><p>​    对于敌人追击我们人物，简而言之就是敌人的移动目标是我们的人物，我们可以在原有的代码基础上来实现追击效果</p><p>​    打开我们的<code>EnemyController.cs</code>代码文件，我们可以先在类中添加一个<code>attackTarget</code>的变量，这个代表着我们敌人追击的目标，并在先前写的<code>FoundPlayer</code>函数里对其赋予目标（即将在敌人一定范围找到人物时，追击目标为敌人）</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnemyController</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MonoBehaviour</span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">GameObject</span> attackTarget<span class="token punctuation">;</span>        <span class="token return-type class-name"><span class="token keyword">bool</span></span> <span class="token function">FoundPlayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Collider<span class="token punctuation">[</span><span class="token punctuation">]</span></span> colliders <span class="token operator">=</span> Physics<span class="token punctuation">.</span><span class="token function">OverlapSphere</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">,</span>sightRadius<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//接受一个圆点，一个半径的参数，返回的是碰撞体数组</span>                <span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token class-name">Collider</span> target <span class="token keyword">in</span> colliders<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//循环碰撞体数组，逐个查找</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">CompareTag</span><span class="token punctuation">(</span><span class="token string">"Player"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">//当前循环到的碰撞体的标签为Player就代表找到人物了</span>                attackTarget<span class="token operator">=</span>target<span class="token punctuation">.</span>gameObject<span class="token punctuation">;</span>                                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    做好上面这些后，我们要回到<code>SwitchEnemyStates</code>函数里进行完善Switch框架</p><p>​    在追击中，我们要思考一下在这过程有哪些行为，首先是追击敌人，追击到了的话会进行攻击，如果目标脱离了追击范围则应该回到上一个状态，同时这整个流程都要有动画的切换。以下代码中便用了TODO来描述要做的事情</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SwitchEnemyStates</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       <span class="token comment">//...</span>        <span class="token keyword">switch</span><span class="token punctuation">(</span>enemyStates<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">case</span> EnemyStates<span class="token punctuation">.</span>GUARD<span class="token punctuation">:</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> EnemyStates<span class="token punctuation">.</span>PATROL<span class="token punctuation">:</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> EnemyStates<span class="token punctuation">.</span>CHASE<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>追击                <span class="token comment">//TODO:追击Player</span>                <span class="token comment">//TODO:在攻击范围攻击</span>                <span class="token comment">//TODO:配合动画</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">FoundPlayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token comment">//TODO:拉脱回上一个状态</span>                <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                    <span class="token comment">//人物进到敌人的范围会给追击</span>                    agent<span class="token punctuation">.</span>destination<span class="token operator">=</span>attackTarget<span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> EnemyStates<span class="token punctuation">.</span>DEAD<span class="token punctuation">:</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    写了以上的代码后，当我们的人物靠近敌人时就被追击了，我们还可以给不同的状态赋予不同的速度，如守卫状态移动速度慢一点，而追击速度快一点等等</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnemyController</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MonoBehaviour</span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name"><span class="token keyword">float</span></span> speed<span class="token punctuation">;</span><span class="token comment">//敌人的速度</span>    <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Awake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        agent <span class="token operator">=</span> <span class="token generic-method"><span class="token function">GetComponent</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>NavMeshAgent<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        speed<span class="token operator">=</span>agent<span class="token punctuation">.</span>speed<span class="token punctuation">;</span><span class="token comment">//在初始化时速度初始化为原来默认的速度</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    之后我们就可以在<code>Switch</code>中不同状态下给定不同的速度值了</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token comment">//举个栗子</span><span class="token comment">//case xxx:</span>speed <span class="token operator">=</span> <span class="token number">1.0f</span><span class="token punctuation">;</span>agent<span class="token punctuation">.</span>speed<span class="token operator">=</span>speed<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="给敌人添加动画"><a href="#给敌人添加动画" class="headerlink" title="给敌人添加动画"></a>给敌人添加动画</h1><h2 id="一些要注意的地方"><a href="#一些要注意的地方" class="headerlink" title="一些要注意的地方"></a>一些要注意的地方</h2><p>​    上面的代码我们打好后先放在一边，先来看看史莱姆的动画如何添加</p><p>​    和之前的小狗一样，我们可以在素材的文件夹下预览动画的效果</p><img src="https://p6-tt.byteimg.com/origin/pgc-image/cbd42713bc444c18836fedb8b0b42622.png" alt="3.png" style="zoom:80%;" /><p>​    上图中可以看到有两个<code>Idle（闲置）</code>的动画效果，其中的<code>IdleBattle</code>是在攻击玩家中间CD时间时的闲置动作，而<code>IdleNormal</code>则是在一般闲置状态下的闲置效果，这里要注意区分</p><p>​    知道这些后，我们就可以再次使用动画控制器来管理动画的切换了</p><h2 id="使用动画管理器来管理动画"><a href="#使用动画管理器来管理动画" class="headerlink" title="使用动画管理器来管理动画"></a>使用动画管理器来管理动画</h2><p>​    首先在<code>Animations</code>文件夹下新建一个<code>Animator Controller</code>专门用来管理史莱姆的动画，这里我将它命名为<code>Enemy _Slime</code>，🎈记住创建好后要拖拽到史莱姆的属性面板上应用该Animator Controller</p><img src="https://p6-tt.byteimg.com/origin/pgc-image/7fbb2f64cba8440f93954e02b86e2f50.png" alt="4.png" style="zoom:80%;" /><p>​    接着双击打开他进入动画管理器</p><p>​    因为敌人有多种状态，所以我们要考虑如何来规划这些动画。而这里则可以使用不同的<code>Layer</code>来实现不同的状态</p><img src="https://p5-tt.byteimg.com/origin/pgc-image/d35a90c16257478d823a52b598c87578.png" alt="5.png" style="zoom:80%;" /><center>可以在不同的Layer中实现不同状态的动画</center><h3 id="Base-Layer"><a href="#Base-Layer" class="headerlink" title="Base Layer"></a>Base Layer</h3><p>​    刚开始我们只用到<code>Base Layer</code>，其它的layer我们之后再创建。而在最开始的<code>Base Layer</code>当中，我们完成最基本的状态：普通闲置和行走（巡逻状态）</p><p>​    如下图找到对应的动画并拖拽到动画控制器中，并进行状态转移的设置</p><img src="https://p9-tt.byteimg.com/origin/pgc-image/138c62781a3b47deb564aacdc3bd0e6f.png" alt="6.png" style="zoom:80%;" /><p>​    那么闲置状态切换到行走状态的条件是什么呢？在之前我们控制小人行走的动画切换是通过鼠标点击的方式来判断，而这里敌人的状态切换可以看做是一个逻辑状态，因此我们可以建立一个布尔变量来控制它们的切换，这里命名为<code>Walk</code></p><img src="https://p5-tt.byteimg.com/origin/pgc-image/fc09aba486814ef9942061481e2d610e.png" alt="7.png" style="zoom:80%;" /><p>​    然后填写动画之间的切换条件</p><img src="https://p26-tt.byteimg.com/origin/pgc-image/9bfd3f46132a4c938c0dddaf775ab53b.png" alt="8.png" style="zoom:80%;" /><center>两个切换都要（一个为true，一个为false）</center><p>​    </p><h3 id="Attack-Layer（实现追击）"><a href="#Attack-Layer（实现追击）" class="headerlink" title="Attack Layer（实现追击）"></a>Attack Layer（实现追击）</h3><p>​    接下来我们新建一个新的Layer，并将其命名为<code>Attack Layer</code>，我们的追击动画切换就在这里面来实现</p><p>​    新建好后我们要设置一下这个Layer的权重值，这里要调整<code>Weight</code>值为最大<code>1</code>，表示在动画触发的时候是完全覆盖原来的Base Layer里的动画，如果不是1的话就相当于是叠加原来的动画，两者进行混合</p><img src="https://p5-tt.byteimg.com/origin/pgc-image/f5282b22821c4d0b919674b2c68cca85.png" alt="9.png" style="zoom:80%;" /><p>​    那么我们是如何知道上一个状态是怎么切换到当前的Layer呢？我们可以在新建的Layer中创建一个<code>Empty State</code>并将它命名为<code>Base State</code>，这个空的State可以代表我们之前任意一个Layer，当满足条件的时候它就会切换过来并进一步切换动画</p><img src="https://p5-tt.byteimg.com/origin/pgc-image/ac40128c56244e46893c469a70178825.png" alt="10.png" style="zoom:80%;" /><p>​    切换过来<code>Attack Layer</code>的时候我们最先要进入的是一个闲置状态，再加上这是一个专门用于追击的Layer，因此我们可以使用<code>Idle_Battle</code>这个动画</p><img src="https://p3-tt.byteimg.com/origin/pgc-image/38b8683f9e2644ab8d281f80bcdd34fd.png" alt="11.png" style="zoom:80%;" /><p>​    同样我们切换条件也是可以建立一个<code>布尔值</code>变量来控制，这里取名为<code>Chase</code></p><p>​    上面的是一个敌人攻击空当时CD动画，当然我们还要有一个追的动画，也是要靠一个<code>布尔值</code>变量来控制，如下图</p><img src="https://p5-tt.byteimg.com/origin/pgc-image/43a30493ed3d4be0a6204f23af878588.png" alt="12.png" style="zoom:80%;" /><p>​    这里我把追击的动画（<code>RunFWD</code>）加了上去，并用一个新的布尔值<code>Follow</code>来作为它与<code>IdleBattle</code>之间的切换判断条件</p><p>​    🎈注意将三个布尔值都应用到对应的动画切换判断上去哦！</p><p>​    这样一来就有了一个逻辑：如果敌人发现了我们的控制的小人，并且两者距离大于敌人的攻击距离，敌人则会进行追击我们的小人，当靠近后则会进行攻击CD状态，等到下一个攻击到来（攻击动画效果这里还没实现）</p><h2 id="使用代码配合动画切换"><a href="#使用代码配合动画切换" class="headerlink" title="使用代码配合动画切换"></a>使用代码配合动画切换</h2><p>​    完成动画管理器中的前置工作后，我们就可以着手来写代码从而配合我们的动画切换了</p><p>​    打开<code>EnemyController.cs</code>，首先要获取<code>Animator</code>组件的信息</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnemyController</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MonoBehaviour</span></span><span class="token punctuation">&#123;</span>        <span class="token keyword">private</span> <span class="token class-name">Animator</span> anim<span class="token punctuation">;</span>        <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Awake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//...</span>        anim <span class="token operator">=</span> <span class="token generic-method"><span class="token function">GetComponent</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>Animator<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    然后要声明三个布尔变量对照着动画管理器的那三个布尔变量（Walk、Chase、Follow）</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnemyController</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MonoBehaviour</span></span><span class="token punctuation">&#123;</span><span class="token comment">//动画控制的三个布尔值变量</span>    <span class="token keyword">private</span> <span class="token class-name"><span class="token keyword">bool</span></span> isWalk<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name"><span class="token keyword">bool</span></span> isChase<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name"><span class="token keyword">bool</span></span> isFollow<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    这三个变量是用来实时更新动画控制器里的布尔变量的，因此我们要使用一个函数，并将它放在<code>Update()</code>里边</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">    <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//...</span>        <span class="token function">SwitchAnimation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//实时更新Animator里面史莱姆的三个布尔值</span>    <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SwitchAnimation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        anim<span class="token punctuation">.</span><span class="token function">SetBool</span><span class="token punctuation">(</span><span class="token string">"Walk"</span><span class="token punctuation">,</span>isWalk<span class="token punctuation">)</span><span class="token punctuation">;</span>        anim<span class="token punctuation">.</span><span class="token function">SetBool</span><span class="token punctuation">(</span><span class="token string">"Chase"</span><span class="token punctuation">,</span>isChase<span class="token punctuation">)</span><span class="token punctuation">;</span>        anim<span class="token punctuation">.</span><span class="token function">SetBool</span><span class="token punctuation">(</span><span class="token string">"Follow"</span><span class="token punctuation">,</span>isFollow<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    这样一来，我们在其它函数里更改了这三个is布尔值的话，他们就可以实时同步到Animator里面了</p><p>​    紧接着我们回到<code>SwitchEnemyStates()</code>函数里面修改一下</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token comment">//...</span><span class="token keyword">switch</span><span class="token punctuation">(</span>enemyStates<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     <span class="token comment">//...</span>        <span class="token keyword">case</span> EnemyStates<span class="token punctuation">.</span>CHASE<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>追击<span class="token comment">//TODO:追击Player</span>    <span class="token comment">//TODO:在攻击范围攻击</span>            <span class="token comment">//TODO:配合动画</span>        isWalk <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//追击时就不是走路了</span>        isChase <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">//切换到追击的Layer层动画</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">FoundPlayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">//TODO:拉脱回上一个状态</span>        isFollow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        isFollow <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">//找到人物就跑着追</span>      agent<span class="token punctuation">.</span>speed<span class="token operator">=</span>speed<span class="token punctuation">;</span>        <span class="token comment">//人物进到敌人的范围会给追击</span>        agent<span class="token punctuation">.</span>destination<span class="token operator">=</span>attackTarget<span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>   <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token comment">//...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    到这里我们就实现了敌人追击我们的状态啦，快去游戏中试一下吧</p><h1 id="解决敌人停下来有延迟的问题"><a href="#解决敌人停下来有延迟的问题" class="headerlink" title="解决敌人停下来有延迟的问题"></a>解决敌人停下来有延迟的问题</h1><p>​    试过游戏后我们可能会发现一个问题，就是当我们人物脱离敌人追击范围时敌人会再走一小段路才会停下来，这是因为我们没有及时修改敌人移动的目的地，也就是<code>agent.destination</code>，当脱离追击范围后，敌人的目的地还在后面一小段路，从而导致了延迟的效果</p><p>​    这里修改它也很简单，在上面代码添加一条语句就可以了</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token comment">//...</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">FoundPlayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//拉脱回上一个状态</span>    agent<span class="token punctuation">.</span>destination <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">;</span><span class="token comment">//人物脱离追击范围后，敌人停在当前位置</span>    isFollow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>    <span class="token comment">//...</span><span class="token punctuation">&#125;</span><span class="token comment">//...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    这样，敌人在脱离追击状态时就会立刻停在当前位置了</p><p>​    🎉到这里，本章我们就成功实现了敌人的一个简单的追击状态及动画切换管理，下一章我们将更加完善敌人其它一些状态，例如巡逻效果等</p>]]></content>
      
      
      <categories>
          
          <category> Unity学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity笔记7--修改相机移动视角以及添加敌人范围检测</title>
      <link href="UnityNotes/Unity%E7%AC%94%E8%AE%B07-%E4%BF%AE%E6%94%B9%E7%9B%B8%E6%9C%BA%E7%A7%BB%E5%8A%A8%E8%A7%86%E8%A7%92%E4%BB%A5%E5%8F%8A%E6%B7%BB%E5%8A%A0%E6%95%8C%E4%BA%BA%E8%8C%83%E5%9B%B4%E6%A3%80%E6%B5%8B/"/>
      <url>UnityNotes/Unity%E7%AC%94%E8%AE%B07-%E4%BF%AE%E6%94%B9%E7%9B%B8%E6%9C%BA%E7%A7%BB%E5%8A%A8%E8%A7%86%E8%A7%92%E4%BB%A5%E5%8F%8A%E6%B7%BB%E5%8A%A0%E6%95%8C%E4%BA%BA%E8%8C%83%E5%9B%B4%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<p>​    这一章我们将对项目做一些调整，包括：设置自由移动视角的相机、检测人物是否到达敌人附近、切换到追击模式等。以后我们可能会多次在项目开发途中停下来做一些小小的优化之类的，这些都是很有必要的。</p><h1 id="将相机改成可自由移动视角"><a href="#将相机改成可自由移动视角" class="headerlink" title="将相机改成可自由移动视角"></a>将相机改成可自由移动视角</h1><p>​    到目前为止我们的相机虽然都是可以跟随人物移动的，但是它视角是固定的，不能自由地去移动视角。如果你想更改成自由视角的相机的话，那么就现在来实现吧！</p><p>​    这里最主要的就是将<code>Cinemachine</code>插件中的<code>Virtual Camera</code>换成<code>FreeLook Camera</code></p><p>​    因此我们选择原来创建的<code>Virtual Camera</code>，然后将它关闭（如果你已经决定不想使用可以直接删除），具体关闭方法就是取消下图所示的勾勾</p><img src="https://p5.toutiaoimg.com/origin/pgc-image/be709270a95a408ca723e83e24f0df33.png" alt="1.png" style="zoom:80%;" /><p>​    凡是关闭后的对象在列表中都会变成淡灰色的</p><img src="https://p26.toutiaoimg.com/origin/pgc-image/076433cd57354d968359194bacc2c638.png" alt="2.png" style="zoom:80%;" /><p>​    之后我们再选中主摄像机，<code>Main Camera</code>，在Unity上方菜单中选择<code>Cinemachine</code>插件列表菜单项👉之后再选择如图第二个选项<code>FreeLook Camera</code></p><img src="https://p3.toutiaoimg.com/origin/pgc-image/487625f3bdce4f8db3115e37d2e53046.png" alt="3.png" style="zoom:80%;" /><p>​    创建完毕后，我们将新的相机和旧的相机都命名一下，防止搞混。</p><p>​    我们同样要来选择一下相机的跟踪对象和观察对象，我们把控制人物<code>Player</code>拖进去</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/586146b0a6ab4820958b1903848901a8.png" alt="4.png" style="zoom:80%;" /><p>​    我们在窗口中可以看到摄像机旁边有上中下三个红色圈圈，同时还有一条弧线包裹住它们，这是代表着我们相机可以在这三个维度里面自由旋转切换摄像机角度，同时可以进行上下角度的切换，我们可以根据喜好来调整这几个圈圈</p><img src="https://p26.toutiaoimg.com/origin/pgc-image/7dacd6ce8f324399aa660d3d593e8e2c.png" alt="5.png" style="zoom:80%;" /><p>​    然后就是如何来控制摄像机移动了，我们在<code>FreeLook Camera</code>的属性面板中可以看到有个<code>Axis Control</code>的项，在这里我们可以看到控制Y轴移动的是<code>Mouse Y</code>，控制X轴移动的是<code>Mouse X</code>，即默认情况是鼠标移动来控制，我们可以在此修改它</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/d5c98a365df147d79a90ce4fa823e67e.png" alt="6.png" style="zoom:80%;" /><p>​    我们打开<code>Project Setting...</code>，里面有个<code>Input Manager</code>，在这里就可以修改具体关于<code>Axis</code>按键的设置</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/3d0286059bc547ccabd4c79efcf82bef.png" alt="7.png" style="zoom:80%;" /><p>​    在Mouse Y下面有一个<code>Mouse ScrollWheel</code>，这个就是鼠标的滚轮，可以利用这个来进行视角的拉远和拉近</p><p>​    还有一个<code>Horizontal</code>的选项，这个可以来控制视角左右移动，并且它可以利用我们提供的自定义按键，如：A和D，只需要在<code>Negative Button</code>和<code>Positive Button</code>分别填入你想要的按键</p><img src="https://p5.toutiaoimg.com/origin/pgc-image/20c6e5d985d34974b7e52ecdafb2ff24.png" alt="8.png" style="zoom:80%;" /><p>​    自定义好按键之后，我们要把具体的<code>Axes</code>名称复制到摄像机属性面板中，如果测试的时候发现视角移动是反向的可以把<code>Invert</code>可选框的勾勾去掉，转向速度太慢可以修改<code>Speed</code>里的数值</p><p>​    🎈在调试之前可以把<code>Save During Play</code>选上，这样便可以点<code>Game</code>游玩时边玩边调整，并且修改的数据可以保存下来</p><img src="https://p26.toutiaoimg.com/origin/pgc-image/1dd06a7a2f0e49d39f3622ffa4bead06.png" alt="9.png" style="zoom:80%;" /><p>​    这样，我们的摄像机视角控制就自定义好了</p><p>​    如果发现摄像机离人物太近，我们可以修改以下的参数</p><p>​    <code>Orbits</code>项分别有三个<code>Rig</code>的修改参数框，我们可以在这修改</p><img src="https://p3.toutiaoimg.com/origin/pgc-image/54045622e4a64873846e612a7e679804.png" alt="10.png" style="zoom:80%;" /><p>​    这里我的参数修改如下</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/eeb5b826c51240e3bcf20c7f1ae81ac3.png" alt="11.png" style="zoom:80%;" /><p>​    到这我们的自由视角相机就设置好了</p><h1 id="检测人物是否在敌人附近"><a href="#检测人物是否在敌人附近" class="headerlink" title="检测人物是否在敌人附近"></a>检测人物是否在敌人附近</h1><p>​    接下来我们来实现让敌人检测人物是否在它自身的附近</p><p>​    我们打开之前已经写了一点框架的<code>EnemyController.cs</code>代码文件，先修改一下前面声明的<code>enemyStates</code>，将其改为<code>private</code>，因为这个敌人状态是靠后面代码自动改变的，不需要手动来弄，没有必要设成public</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">private</span> <span class="token class-name">EnemyStates</span> enemyStates<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    </p><p>​    然后我们可以弄一个变量，表示敌人的可视范围</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Header</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">"Basic Settings"</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span><span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">float</span></span> sightRadius<span class="token punctuation">;</span><span class="token comment">//敌人的可视范围</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    这里我用了一个<code>[Header(&quot;Basic Settings&quot;)]</code>，这样做可以在对象的属性面板有一个划分的作用，以后我们都可以这样来划分一些代码公开给外界的设置项👇</p><img src="https://p26.toutiaoimg.com/origin/pgc-image/6c60b7836bf74b1fb0671f9c2af7253f.png" alt="12.png" style="zoom:80%;" /><p>​    然后就到了我们关键的一个部分，写一个检测敌人附近是否有人物的函数，这里是利用了 <a href="https://docs.unity3d.com/ScriptReference/Physics.OverlapSphere.html">Physics.OverlapSphere</a> 的方法，这个函数检测了一个球体范围内是否有碰撞体，因此我们可以为人物添加一个碰撞体再结合这个方法来实现</p><p>​    我们先来写实现代码</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token return-type class-name"><span class="token keyword">bool</span></span> <span class="token function">FoundPlayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">Collider<span class="token punctuation">[</span><span class="token punctuation">]</span></span> colliders <span class="token operator">=</span> Physics<span class="token punctuation">.</span><span class="token function">OverlapSphere</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">,</span>sightRadius<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//接受一个圆点，一个半径的参数，返回的是碰撞体数组</span>        <span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token class-name">Collider</span> target <span class="token keyword">in</span> colliders<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//循环碰撞体数组，逐个查找</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">CompareTag</span><span class="token punctuation">(</span><span class="token string">"Player"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//当前循环到的碰撞体的标签为Player就代表找到人物了</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    因为<code>OverlapSphere</code>返回的是碰撞体数组，我们之后只要在这数组中遍历查找是否有标签为<code>Player</code>的对象就行了</p><p>​    然后修改一下之前的<code>SwitchEnemyStates</code>函数</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SwitchEnemyStates</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//如果发现player 切换到CHASE</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">FoundPlayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            enemyStates <span class="token operator">=</span> EnemyStates<span class="token punctuation">.</span>CHASE<span class="token punctuation">;</span>            Debug<span class="token punctuation">.</span><span class="token function">LogFormat</span><span class="token punctuation">(</span><span class="token string">"敌人&#123;0&#125;发现了玩家"</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//测试代码</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">switch</span><span class="token punctuation">(</span>enemyStates<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">case</span> EnemyStates<span class="token punctuation">.</span>GUARD<span class="token punctuation">:</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> EnemyStates<span class="token punctuation">.</span>PATROL<span class="token punctuation">:</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> EnemyStates<span class="token punctuation">.</span>CHASE<span class="token punctuation">:</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> EnemyStates<span class="token punctuation">.</span>DEAD<span class="token punctuation">:</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    写完代码后别忘了我们要为人物添加一个碰撞体，这里我选用的就是胶囊碰撞体<code>Capsule Collider</code>，然后调整一下胶囊的大小</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/31bf56dfd4ae4f998acbbc3320e577de.png" alt="13.png" style="zoom:80%;" /><img src="https://p3.toutiaoimg.com/origin/pgc-image/12273ccf82704bbdb3a69d8ff64a940c.png" alt="15.png" style="zoom:80%;" /><p>​    最后再把人物的标签设为<code>Player</code>，然后把之前设的公开变量<code>Sight Radius</code>视野范围赋予一个值</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/5fa32863fb39401ba974cd2e18443420.png" alt="14.png" style="zoom:80%;" /><img src="https://p3.toutiaoimg.com/origin/pgc-image/3892abc4f74f4700b0078adcbe3aa7ac.png" alt="16.png" style="zoom:80%;" /><p>​    这样我们就完成了敌人范围检测人物的功能了！</p>]]></content>
      
      
      <categories>
          
          <category> Unity学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity笔记6-创建敌人</title>
      <link href="UnityNotes/Unity%E7%AC%94%E8%AE%B06-%E5%88%9B%E5%BB%BA%E6%95%8C%E4%BA%BA/"/>
      <url>UnityNotes/Unity%E7%AC%94%E8%AE%B06-%E5%88%9B%E5%BB%BA%E6%95%8C%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<p>​     在本章节中，我们来学习如何创建我们的第一个敌人并添加一些关于移向敌人的代码和攻击动画，从而使我们的游戏更加完善</p><h1 id="下载并安装敌人素材"><a href="#下载并安装敌人素材" class="headerlink" title="下载并安装敌人素材"></a>下载并安装敌人素材</h1><p>​    我们今天要下载的敌人素材名字是<strong>RPG Monster Duo PBR Polyart</strong>，大家可以去 Assert Store 上下载下来</p><img src="https://p26.toutiaoimg.com/origin/pgc-image/06c4964d32aa45fa89ebb17df55275cf.jpg" alt="1.1.jpg" style="zoom:80%;" /><p>​    同样的，下载完后我们选择 <code>Import</code> 加载进我们的项目里，再把新素材的文件夹分类放好</p><p>​    我们可以预览一下刚下好的素材，但是发现是没有贴图的，这是因为我们还没把素材升级到URP，我们将素材升级一下就可以显示正常了，还记得如何将素材升级URP吗？不记得的话可以翻看前面的文章哦</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/9190e65818cf49a5ba851b0aabec2db9.png" alt="2.png" style="zoom:80%;" /><h1 id="布置并设置敌人的基本属性和状态"><a href="#布置并设置敌人的基本属性和状态" class="headerlink" title="布置并设置敌人的基本属性和状态"></a>布置并设置敌人的基本属性和状态</h1><h2 id="使用代码约束的方式来添加组件"><a href="#使用代码约束的方式来添加组件" class="headerlink" title="使用代码约束的方式来添加组件"></a>使用代码约束的方式来添加组件</h2><p>安装好敌人素材后，我们就可以把敌人拖到地图中了，将它放到你喜欢的位置之后，就可以着手来修改一下它的基本属性了</p><p>​    从这里开始我们要长远考虑，我们以后需要添加的敌人会有很多，而这些敌人都需要挂载一些相同的组件，我们需要有一种更好的方法来为以后敌人一键添加这些组件，而不是一个一个来添加，那么我们就开始吧</p><p>​    首先在下图的<code>Scripts👉Charcters</code>文件夹位置新建一个 C# 代码文件，可以命名为 <strong>EnemyController</strong>，然后打开编辑</p><img src="https://p5.toutiaoimg.com/origin/pgc-image/30321fb536f94b068f6b998b8e2b663e.png" alt="3.png" style="zoom:80%;" /><p>​    这个时候我们就可以来想一下，我们一般敌人需要哪些组件呢？首先想到的是智能导航 <code>NavMeshAgent</code>，那我们要确保它敌人对象肯定挂载这个组件的话，我们可以使用以下代码来约束它</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">using</span> <span class="token namespace">UnityEngine<span class="token punctuation">.</span>AI</span><span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">RequireComponent</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">NavMeshAgent</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    把<code>[RequireComponent()]</code>这一个约束句子放在代码文件开头的位置，就可以实现当你把代码作为一个组件添加到敌人或其它Unity对象中时，自动添加给约束的组件了</p><p>​    按上面代码来举栗子，当我把包含上面代码的文件作为组件添加到我们的敌人中时，会自动附带一个<code>NavMeshAgent</code>组件了</p><img src="https://p3.toutiaoimg.com/origin/pgc-image/ff7fb226a3524c7e8aec1e566b2a0e43.png" alt="4.png" style="zoom:80%;" /><p>​    而且当你试图删除<code>NavMeshAgent</code>组件时Unity还会发出警告提示不能删除</p><img src="https://p9.toutiaoimg.com/origin/pgc-image/85dda0a8a4a2418cb95ff0402e2a5292.png" alt="5.png" style="zoom:80%;" /><p>​    所以当你的代码需要用到一定的组件在多个物体上，你就可以运用这种方式来确保你的物体包含了这些组件，以致于你的代码能够正常运行</p><p>​    到这里，我们就可以在<code>Awake()</code>函数里面获取我们的组件了</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">using</span> <span class="token namespace">UnityEngine</span><span class="token punctuation">;</span><span class="token keyword">using</span> <span class="token namespace">UnityEngine<span class="token punctuation">.</span>AI</span><span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">RequireComponent</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">NavMeshAgent</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnemyController</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MonoBehaviour</span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">NavMeshAgent</span> agent<span class="token punctuation">;</span>    <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Awake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        agent <span class="token operator">=</span> <span class="token generic-method"><span class="token function">GetComponent</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>NavMeshAgent<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    </p><h2 id="设置敌人基本属性"><a href="#设置敌人基本属性" class="headerlink" title="设置敌人基本属性"></a>设置敌人基本属性</h2><p>​    接下来我们设置一下敌人的基本属性，先来看看<code>NavMeshAgent</code>的信息</p><img src="https://p9.toutiaoimg.com/origin/pgc-image/8c5a62e350ad41d689b6fd0a38cfd104.png" alt="6.png" style="zoom:80%;" /><p>​    这里我修改了一下这个敌人的速度<code>Speed</code>，因为速度太快会导致我们的主角无法摆脱战斗；同样修改了的还有转角速度<code>Angular Speed</code>和高度<code>Height</code>，这些都可以自己尝试来调整到自己喜欢的数值</p><p>​    其次，我们还要来添加一个碰撞体组件<code>Collider</code>，我们要借用这个碰撞体来判断我们鼠标的射线是否点击到了我们的敌人，如果没有碰撞体我们是没有办法来判断是否击中的。</p><p>​    我们可以根据自己喜好和需求来添加不同的碰撞体组件，我这里为了简单就使用<code>BoxCollider</code></p><img src="https://p3.toutiaoimg.com/origin/pgc-image/11640e3d6b6048f282feb4622684ece2.png" alt="7.png" style="zoom:80%;" /><p>​    添加好调整一下方体的位置，使方框刚好包含敌人</p><img src="https://p26.toutiaoimg.com/origin/pgc-image/3f63124e04c9414a94edbdfc62310fb5.png" alt="8.png" style="zoom:80%;" /><p>​    其次，我们还要调整一下我们敌人的图层，以防被其它东西挡住了看不见。</p><p>​    和之前剔除人物遮挡一样步骤，我们只需要添加一个图层并在<code>URP</code>文件中的<code>Layer Mask</code>下拉列表（可以多选）勾选我们的新图层就行了</p><img src="https://p3.toutiaoimg.com/origin/pgc-image/eb0776b3a1324e76919f62b6201061ca.png" alt="10.png" style="zoom:80%;" /><img src="https://p5.toutiaoimg.com/origin/pgc-image/c1efe22bdbce4eeb839e358479ad7702.png" alt="11.png" style="zoom:80%;" /><p>​    图层加了之后也别忘了也要新建一个<code>Enemy</code>的标签</p><h2 id="编写敌人的状态"><a href="#编写敌人的状态" class="headerlink" title="编写敌人的状态"></a>编写敌人的状态</h2><p>​    首先我们要思考一下敌人会有多少种状态呢？这里我可以先想到有：警戒、巡逻、追击主角、死亡 这四种状态，当然你也可以根据你所喜好的状态去设计</p><p>​    我们在<code>EnemyController.cs</code>代码文件中添加下面这一行枚举代码，<u>注意是打在类的外边作为全局形式</u></p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">EnemyStates</span><span class="token punctuation">&#123;</span>GUARD<span class="token punctuation">,</span>PATROL<span class="token punctuation">,</span>CHASE<span class="token punctuation">,</span>DEAD<span class="token punctuation">&#125;</span><span class="token comment">//敌人的四种状态，警戒、巡逻、追击、死亡</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    然后我们再在类中声明变量</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token class-name">EnemyStates</span> enemyStates<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    这个时候我们返回Unity中就可以在敌人对象中代码组件部分看到多了个<code>Enemy States</code>的下拉菜单了</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/09d6536220f44ff2919ed22b29442031.png" alt="9.png" style="zoom:80%;" /><p>​    这里我们可以利用较为简单的状态切换方式—Switch切换，当然还可以选择复杂点的状态机切换方式，这里暂时不使用先，打开我们的<code>EnemyController.cs</code>代码文件，写一个基本的Switch判断框架</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">SwitchEnemyStates</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SwitchEnemyStates</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span>enemyStates<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> EnemyStates<span class="token punctuation">.</span>GUARD<span class="token punctuation">:</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> EnemyStates<span class="token punctuation">.</span>PATROL<span class="token punctuation">:</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> EnemyStates<span class="token punctuation">.</span>CHASE<span class="token punctuation">:</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> EnemyStates<span class="token punctuation">.</span>DEAD<span class="token punctuation">:</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    以上的框架编写好后我们先放一边到时候再来补充</p><h1 id="添加人物移动到敌人的方法"><a href="#添加人物移动到敌人的方法" class="headerlink" title="添加人物移动到敌人的方法"></a>添加人物移动到敌人的方法</h1><h2 id="添加事件"><a href="#添加事件" class="headerlink" title="添加事件"></a>添加事件</h2><p>​    接下来又要回到我们的<code>MouseManager.cs</code>代码文件中，我们要添加一个新的事件，来代表当我们鼠标点击敌人时的事件</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">event</span> <span class="token class-name">Action<span class="token punctuation">&lt;</span>GameObject<span class="token punctuation">></span></span> OnEnemyClicked<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    这样我们事件发生的时候传递的就是<code>GameObject</code>类型，也就是我们鼠标点击的敌人了，这样做我们就可以获得更多的敌人相关信息，比如坐标、名字等</p><p>​    然后我们再把当前代码文件下的<code>MouseControl</code>函数修改一下，添加一些代码</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">MouseControl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>Input<span class="token punctuation">.</span><span class="token function">GetMouseButtonDown</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> hitInfo<span class="token punctuation">.</span>collider <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>hitInfo<span class="token punctuation">.</span>collider<span class="token punctuation">.</span><span class="token function">CompareTag</span><span class="token punctuation">(</span><span class="token string">"Ground"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            OnMouseClicked<span class="token punctuation">?.</span><span class="token function">Invoke</span><span class="token punctuation">(</span>hitInfo<span class="token punctuation">.</span>point<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>hitInfo<span class="token punctuation">.</span>collider<span class="token punctuation">.</span><span class="token function">CompareTag</span><span class="token punctuation">(</span><span class="token string">"Enemy"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            OnEnemyClicked<span class="token punctuation">?.</span><span class="token function">Invoke</span><span class="token punctuation">(</span>hitInfo<span class="token punctuation">.</span>collider<span class="token punctuation">.</span>gameObject<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//这里传递的是射线碰撞到的对象，也就是敌人了</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    接下来转到<code>PlayerController.cs</code>代码文件来配置一下角色点击到敌人的反应</p><p>​    我们在代码文件的类下添加下面的代码</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PlayerController</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MonoBehaviour</span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">GameObject</span> attactTarget<span class="token punctuation">;</span><span class="token comment">//为了编写点击敌人函数方便而声明的变量</span>    <span class="token keyword">private</span> <span class="token class-name"><span class="token keyword">float</span></span> lastAttactTime<span class="token punctuation">;</span><span class="token comment">//一个关于上一次攻击时间的变量，简单的计时器，一旦超过所给的CD时间就可以再攻击一次</span>    <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        MouseManager<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>OnMouseClicked<span class="token operator">+=</span>MoveToTarget<span class="token punctuation">;</span><span class="token comment">//普通移动</span>        MouseManager<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>OnEnemyClicked<span class="token operator">+=</span>EventAttact<span class="token punctuation">;</span><span class="token comment">//我们点击了攻击目标，即敌人</span>    <span class="token punctuation">&#125;</span>    <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">EventAttact</span><span class="token punctuation">(</span><span class="token class-name">GameObject</span> obj<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//这里就可以填写点击敌人后需要的操作了</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    </p><h2 id="利用协程的方式来写人物移向敌人"><a href="#利用协程的方式来写人物移向敌人" class="headerlink" title="利用协程的方式来写人物移向敌人"></a>利用协程的方式来写人物移向敌人</h2><p>​    那么我们就要来思考<code>EventAttact</code>在函数里要实现什么了</p><p>​    首先我们来实现小人跑到敌人的面前，这里就要判断小人是否到了可以攻击敌人的射程，如果没有到的话就要继续移动，而这就要用到<code>协程</code>的方式来实现，具体关于什么是协程大家可以自行搜寻资料</p><p>​    我们在上面代码的基础下，再写一个关于协程的函数</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Collections</span><span class="token punctuation">;</span><span class="token return-type class-name">IEnumerator</span> <span class="token function">MoveToAttackTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//这里用到的IEnumerator就是一个协程</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​    同时因为我们即将要用到上面声明过的<code>attactTarget（GameObject类型）</code>我们还要对原先的函数进行一些修改</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">EventAttact</span><span class="token punctuation">(</span><span class="token class-name">GameObject</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//如果鼠标点击的目标不为空，或者点击的敌人不是属于死亡状态</span>        attact <span class="token operator">=</span> target<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    现在我们就可以正式来编写<code>MoveToAttackTarget</code>函数了</p><p>​    因为要实现小人跑到敌人面前，那么就先要实现小人会转向我们的目标，这样我们就可以用下面这行代码</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token return-type class-name">IEnumerator</span> <span class="token function">MoveToAttackTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>transform<span class="token punctuation">.</span><span class="token function">LookAt</span><span class="token punctuation">(</span>attactTarget<span class="token punctuation">.</span>transform<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//因为这个代码文件是作为组件安在小人对象上的，因此前面this.transform获取的是小人的transform</span>    <span class="token comment">//transform自带的LookAt()函数就可以实现小人的转向</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    接着，我们可以写一个循环，当小人与敌人的距离大于所给定的<code>攻击距离</code>（这里暂时定为1，到时候可以更改，甚至可以根据武器种类不同而给定不同的值）时，小人就不断地向敌人靠近（之所以要不断循环判断，是因为敌人可能处在巡逻的状态，每一帧的位置都不一样，因此要不断更新目的地）</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token return-type class-name">IEnumerator</span> <span class="token function">MoveToAttackTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    agent<span class="token punctuation">.</span>isStopped <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//取消人物的停止状态</span>    transform<span class="token punctuation">.</span><span class="token function">LookAt</span><span class="token punctuation">(</span>attactTarget<span class="token punctuation">.</span>transform<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>Vector3<span class="token punctuation">.</span><span class="token function">Distance</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">,</span>attactTarget<span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//比较人物和敌人的距离是否大于0攻击距离，Distance()可以比较两个Vector3距离</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>agent<span class="token punctuation">.</span>destination <span class="token operator">=</span> attactTarget<span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">;</span><span class="token comment">//小人的目的地是敌人</span>        <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">//下一帧再执行循环判断</span>    <span class="token punctuation">&#125;</span>    agent<span class="token punctuation">.</span>isStopped <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">//人物到达敌人面前停下来</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    这个方法在while循环前后都用到了<code>agent.isStopped</code>，当它为<code>true</code>能够让人物停止，而<code>false</code>时代表没停止</p><p>​    打完上面的代码，我们还要回到<code>EventAttact</code>添加一句代码从而调用协程</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">EventAttact</span><span class="token punctuation">(</span><span class="token class-name">GameObject</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//如果鼠标点击的目标不为空，或者点击的敌人不是属于死亡状态</span>        attactTarget <span class="token operator">=</span> target<span class="token punctuation">;</span>        <span class="token function">StartCoroutine</span><span class="token punctuation">(</span><span class="token function">MoveToAttackTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    这样我们就可以初步实现小人向敌人移动，并在移动的时候不停地来判断是否到达攻击距离了</p><h2 id="最后的修改"><a href="#最后的修改" class="headerlink" title="最后的修改"></a>最后的修改</h2><p>​    但是我们会发现一个Bug，就是在往敌人方向移动的过程中我们是无法取消移动或移向新的目标地点的，这是因为我们在协程代码的循环并没有判断到停止指令，因此我们来完善一下</p><p>​    我们可以在移动方法<code>MoveToTarget</code>中添加代码</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">MoveToTarget</span><span class="token punctuation">(</span><span class="token class-name">Vector3</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        agent<span class="token punctuation">.</span>isStopped <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//解决攻击完后无法移动</span>        <span class="token function">StopAllCoroutines</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//停止所有的协程</span>        agent<span class="token punctuation">.</span>destination <span class="token operator">=</span> target<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    这个<code>StopAllCoroutines()</code>方法可以将所有进行中的协程停止，就可以实现当我们在移向敌人的过程中，点击了其它位置就能中断移向敌人并移动到新的目的地了</p><p>​    同时上面还有一行<code>agent.isStopped = false</code>，这是为了防止我们攻击完敌人后处于人物停止状态而导致无法移动</p><h1 id="添加一下攻击动画和攻击冷却时间"><a href="#添加一下攻击动画和攻击冷却时间" class="headerlink" title="添加一下攻击动画和攻击冷却时间"></a>添加一下攻击动画和攻击冷却时间</h1><h2 id="添加攻击敌人的动画"><a href="#添加攻击敌人的动画" class="headerlink" title="添加攻击敌人的动画"></a>添加攻击敌人的动画</h2><p>​    我们来添加一下人物攻击敌人的动画吧，打开我们人物<code>Player</code>的动画<code>Animation</code>修改动画</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/895243b835bf4d71a0f6c9eb1e871794.png" alt="12.png" style="zoom:80%;" /><p>​    先新建一个<code>Trigger</code>类型的变量，命名为<code>Attack</code></p><img src="https://p9.toutiaoimg.com/origin/pgc-image/c3199d9921284b15b414308b04f3e837.png" alt="13.png" style="zoom:80%;" /><p>​    然后我们从人物素材包中找到攻击动画，再把该动画拖出来（这里我用的是<code>Attack01</code>）</p><img src="https://p26.toutiaoimg.com/origin/pgc-image/171d1f9a693d4ce090172252c58f7825.png" alt="14.png" style="zoom:80%;" /><p>​    拖出来后我们将其重命名节点为<code>Attack Base</code>，然后与普通动作节点建立来回两条切换的线路</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/4251a0aadfe145dd8e29234f9c0cb7f4.png" alt="15.png" style="zoom:80%;" /><p>​    紧接着，我们设置一下普通动画切换到攻击动画的设置，由于我们是当<code>Attack</code>变量触发就会进入攻击动画的，因此不需要退出时间</p><img src="https://p3.toutiaoimg.com/origin/pgc-image/d09bbe1e30774774a22d75da1fa8c35d.png" alt="16.png" style="zoom:80%;" /><p>​    同时还要注意切换条件是变量<code>Attack</code>给触发就进行切换</p><img src="https://p9.toutiaoimg.com/origin/pgc-image/9e975d5f4a0140aaa81400ea62bfd6c6.png" alt="16.5.png" style="zoom:80%;" /><p>​    然后是攻击动画切换回普通动画的设置，这里我们想攻击动画播放完再切换回去，因此退出动画可以设置为1，同时过渡动画可以按自己喜好自行设置</p><img src="https://p3.toutiaoimg.com/origin/pgc-image/d09bbe1e30774774a22d75da1fa8c35d.png" alt="16.png" style="zoom:80%;" /><p>​    动画建立好后，我们的动画触发跟着冷却时间一起设置</p><h2 id="添加攻击冷却时间"><a href="#添加攻击冷却时间" class="headerlink" title="添加攻击冷却时间"></a>添加攻击冷却时间</h2><p>​    还记得前面声明的<code>lastAttactTime</code>变量吗？这里就是用到它的时候，延续着上边协程函数，我们的冷却时间代码和动画触发代码都在这里编写</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token comment">//当人物到达可以攻击敌人的距离后</span><span class="token keyword">if</span><span class="token punctuation">(</span>lastAttactTime<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    animator<span class="token punctuation">.</span><span class="token function">SetTrigger</span><span class="token punctuation">(</span><span class="token string">"Attack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//触发攻击动画</span>    lastAttactTime <span class="token operator">=</span> <span class="token number">0.5f</span><span class="token punctuation">;</span><span class="token comment">//重置冷却时间</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    把这一段代码放在原来的协程函数就变成</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token return-type class-name">IEnumerator</span> <span class="token function">MoveToAttackTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    agent<span class="token punctuation">.</span>isStopped <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    transform<span class="token punctuation">.</span><span class="token function">LookAt</span><span class="token punctuation">(</span>attactTarget<span class="token punctuation">.</span>transform<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>Vector3<span class="token punctuation">.</span><span class="token function">Distance</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">,</span>attactTarget<span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//比较人物和敌人的距离是否大于0攻击距离，Distance()可以比较两个Vector3距离</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>agent<span class="token punctuation">.</span>destination <span class="token operator">=</span> attactTarget<span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">;</span>        <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    agent<span class="token punctuation">.</span>isStopped <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment">//攻击动画和CD都在下面</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>lastAttactTime<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        animator<span class="token punctuation">.</span><span class="token function">SetTrigger</span><span class="token punctuation">(</span><span class="token string">"Attack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//触发攻击动画</span>        lastAttactTime <span class="token operator">=</span> <span class="token number">0.5f</span><span class="token punctuation">;</span><span class="token comment">//重置冷却时间</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    我们这里写到了重置冷却时间，但这个时间肯定要有一个递减的过程的，那我们就要找个地方来让它递减，这里<code>Update</code>是一个不错的选择</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">SwitchPlyerAnimation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lastAttactTime <span class="token operator">-=</span> Time<span class="token punctuation">.</span>deltaTime<span class="token punctuation">;</span><span class="token comment">//递减去每一帧之间的时间</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​    这样，一个冷却时间的效果还有攻击动画就完成啦！</p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> Unity学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity笔记5--剔除人物的遮挡</title>
      <link href="UnityNotes/Unity%E7%AC%94%E8%AE%B05-%E5%89%94%E9%99%A4%E4%BA%BA%E7%89%A9%E7%9A%84%E9%81%AE%E6%8C%A1/"/>
      <url>UnityNotes/Unity%E7%AC%94%E8%AE%B05-%E5%89%94%E9%99%A4%E4%BA%BA%E7%89%A9%E7%9A%84%E9%81%AE%E6%8C%A1/</url>
      
        <content type="html"><![CDATA[<p>​    我们发现在移动到一些物体（比如说树）后面的时候，人物就会给遮挡住了，那么有什么办法可以剔除掉这个遮挡呢？可以参考一些游戏，大部分游戏在移动到遮挡物后面时会把人物的轮廓显示出来，这个章节我们就来实现这种效果。</p><h1 id="利用-Shader-Graph（着色器可视化编辑器）剔除遮挡"><a href="#利用-Shader-Graph（着色器可视化编辑器）剔除遮挡" class="headerlink" title="利用 Shader Graph（着色器可视化编辑器）剔除遮挡"></a>利用 Shader Graph（着色器可视化编辑器）剔除遮挡</h1><h2 id="创建一个Shader"><a href="#创建一个Shader" class="headerlink" title="创建一个Shader"></a>创建一个Shader</h2><p>​    首先为了以后的操作方便，我们在 Materials 文件夹下再新建一个 <strong>Shader Graph 文件夹</strong>，我们就在这个文件夹目录下新建一个 Shader Graph （Create —&gt; Shader —&gt; Universal Render Pipeline —&gt; Unlit Shader Graph）并将它命名为 <strong>Occlusion Shader</strong> （遮挡着色器）。</p><p>​    同时选中该 Shader 右键新建一个 Material 材质，命名为 <strong>Occlusion</strong> ，将它拖到上级目录 Materials ，完成后如下图所示</p><img src="https://p9.toutiaoimg.com/origin/pgc-image/bda871c8cfc34794a0f19650681d08c2.jpg" alt="1.jpg" style="zoom:80%;" /><img src="https://p6.toutiaoimg.com/origin/pgc-image/7e8acbcfdcb349588d889a38ea6b699d.jpg" alt="2.jpg" style="zoom:67%;" /><p>​    </p><p>​    做好这些分类工作后，我们双击打开 Occlusion Shader 打开着色器编辑器窗口，看到如下界面，我们可以先在右上角的 Graph Settings 选项卡中<strong>勾选 Alpha Clip</strong> 打开透明通道，勾选了这个之后我们就可以在 Fragment 节点中修改透明值了</p><img src="https://p26.toutiaoimg.com/origin/pgc-image/6d0dd303bf884583b5bf7803d0f5998a.jpg" alt="3.jpg" style="zoom:80%;" /><p>​    然后我们在空白的地方右键新建一个节点，搜索添加  <strong>Fresnel Effect</strong> （菲涅尔效应），我们到时候可以将人物应用这个 Shader 来实现透明化的效果</p><img src="https://p26.toutiaoimg.com/origin/pgc-image/ef52362a31bb45228a82e169ee052644.jpg" alt="4.jpg" style="zoom:80%;" /><p>​    但是我们看这个光圈有点单调，我们可以给它来上点颜色</p><h2 id="添加颜色"><a href="#添加颜色" class="headerlink" title="添加颜色"></a>添加颜色</h2><p>​    要添加颜色，首先就要在左上角新建一个 <strong>Color类型</strong> 的参数（这些新建出来的参数之后都可以直接材质对象的属性界面板修改它们），然后给这个参数设置一个默认颜色值</p><img src="https://p26.toutiaoimg.com/origin/pgc-image/afff800563c946299acfd483a3bb2f67.jpg" alt="5.jpg" style="zoom:80%;" /><p>​    有了颜色值，我们想应用到上面的 Fresnel Effect 节点的话，有个方法就是将它们相乘，这样颜色就可以与之混合：拖拽 Fresnel Effect 节点窗口的 Out 然后点击空白处，在弹出的搜索框中搜索 Multiply（乘），这时候就多了一个节点窗口，A值由原来的 Fresnel Effect 节点输入进来，而剩下一个B值就是留给我们颜色的</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/ca8248f9b6e046ae959697d41e8da5d8.jpg" alt="6.jpg" style="zoom:80%;" /><p>​    此时我们再将左上角的 Color 拖拽出来，并传给B值，这样颜色就混合进去Fresnel Effect 节点了</p><img src="https://p3.toutiaoimg.com/origin/pgc-image/278510f8f57e4f57a093c66168a16cd7.jpg" alt="7.jpg" style="zoom:80%;" /><p>​    将 Multiply 节点输出 Out 值拖入到 Fragment 节点的 Base Color 项中，可以看到右下角的预览窗口就是我们材质的最终效果了</p><img src="https://p9.toutiaoimg.com/origin/pgc-image/7dc333ce40314957b7ed649b5b9fa013.jpg" alt="8.jpg" style="zoom:80%;" /><p>​    当然我们还可以更完善一下，添加一些额外的东西</p><h2 id="添加噪点"><a href="#添加噪点" class="headerlink" title="添加噪点"></a>添加噪点</h2><p>​    我们可以添加一些噪点填充我们的材质</p><p>​    右键创建一个 <strong>Dither</strong> 节点窗口，改变X的值可以看到噪点渐变的效果</p><img src="https://p26.toutiaoimg.com/origin/pgc-image/5253d92200c34098b2989374df8573da.jpg" alt="9.jpg" style="zoom:80%;" /><p>​    由于这个X值是一个 Float 类型，我们可以创建一个<strong>float类型参数</strong>来供外界改变它，我们就把这个参数命名为 <strong>DitherCount</strong> ，默认值可以暂时设为1</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/3554a59477874c29b9730008f8d6207c.jpg" alt="10.jpg" style="zoom:80%;" /><p>​    最后将输出 Out 值传给 Fragment 节点中的 Alpha 即可</p><img src="https://p3.toutiaoimg.com/origin/pgc-image/52e712db91204e3b869a6f13a4876508.jpg" alt="11.jpg" style="zoom:80%;" /><p>​    </p><h2 id="保存Shader并生成为材质"><a href="#保存Shader并生成为材质" class="headerlink" title="保存Shader并生成为材质"></a>保存Shader并生成为材质</h2><p>​    最后的最后我们可以再添加一个控制 Alpha Clip Threshold （Alpha阈值）的参数值，当然它也是 float类型的，命名为 AlphaThreshold</p><img src="https://p3.toutiaoimg.com/origin/pgc-image/891aa0b188d44acc835c192ca99c33de.jpg" alt="12.jpg" style="zoom:80%;" /><p>​    </p><p>​    点击保存，我们就可以在最开始创建的 Occlusion 材质看到效果了，可以看到它的属性面板中有了三个参数，这三个参数就是我们在 Shader 编辑器中创建的三个变量值</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/a2f1c9f63ad443778b5f1cc23c69996a.jpg" alt="13.jpg" style="zoom:80%;" /><h1 id="将材质应用到人物中"><a href="#将材质应用到人物中" class="headerlink" title="将材质应用到人物中"></a>将材质应用到人物中</h1><h2 id="创建一个Render-Objects"><a href="#创建一个Render-Objects" class="headerlink" title="创建一个Render Objects"></a>创建一个Render Objects</h2><p>​    在上面创建好了材质后，我们就可以尝试把它应用到我们的人物里了，我们想要的是当人物移动到树等物体后面给遮挡时应用这个材质，这样就等同于显示人物的轮廓了，那就让我们开始吧！</p><p>​    我们找到我们的 Pipeline Setting 文件夹，选中 <strong>UniversalRenderPipelineAsset_Renderer</strong> ，在右边的属性面板中点击 <strong>Add Renderer Feature</strong> 按钮，新建一个 <strong>Render Objects</strong></p><p>​    因为我们要区分人物在遮挡物前面和在遮挡物后面的情况，所以可以先将这个 Render Object 命名为 <strong>CharcterBehind</strong> ，而判断是否在遮挡物后面的条件就是根据 深度（Depth）来判断，所以我们要勾选 <strong>Depth</strong> 选项，并按下图来设置</p><img src="https://p5.toutiaoimg.com/origin/pgc-image/3a0b69da1498450b9896af76a181e118.jpg" alt="14.jpg" style="zoom:80%;" /><p>​    图中的 Material 选项则是选择我们前面创建的材质 Occlusion，这样当人物在判断成功的条件下就会给渲染出这个材质效果了</p><h2 id="设置过滤图层"><a href="#设置过滤图层" class="headerlink" title="设置过滤图层"></a>设置过滤图层</h2><p>​    做完了上面这些还不够，我们还要考虑 <strong>Filters（过滤）</strong>哪一些东西，我们可以在上方的 <strong>Layer Mask</strong> 中选择我们要过滤的图层，因为我们这里遮挡只涉及到人物，因此我们只用过滤人物图层就行了</p><p>​    但是问题在于 Layer Mask 默认自带的选项并没有我们的人物图层，那我们就自创一个：找到我们的人物对象（我这里的名字是Player），然后点击属性面板中的 <strong>Layer —&gt; Add Layer…</strong></p><img src="https://p6.toutiaoimg.com/origin/pgc-image/88e43d5e10e6489eaaf3de4128e87533.jpg" alt="15.jpg" style="zoom:80%;" /><p>​    然后为了方便记忆，可以将这个新图层命名为 Player</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/e0c625c03a9d422681ba030f982dbe7f.jpg" alt="16.jpg" style="zoom:80%;" /><p>​    新建好后不要忘了回到人物属性中选择我们的新图层，这时候弹出一个对话框，我们选择下图第一个选项，将子物体也一起更改为新图层</p><img src="https://p5.toutiaoimg.com/origin/pgc-image/b156a4461b024c348d80d8b760201cde.jpg" alt="17.jpg" style="zoom:80%;" /><h2 id="最后的调整"><a href="#最后的调整" class="headerlink" title="最后的调整"></a>最后的调整</h2><p>​    这个时候我们人物已经有了一些变化了，把它放在树后面可以看到渲染出来的是轮廓了，但是还有一些问题需要调整：当我们不是在遮挡物后面时，人物的一些部件也会有遮挡效果，我们就要来解决它</p><img src="https://p9.toutiaoimg.com/origin/pgc-image/0130ed394a4c479b8b5d210748ed8dd8.jpg" alt="18.jpg" style="zoom:80%;" /><p>​    我们只需要再新建一个 <strong>Render Objects</strong> ，并命名为 <strong>CharcterInFront</strong> 代表是人物在遮挡物前面的时候（与上一个 Render Object 相反情况），然后只需要改变 Layer Mask 为我们新建的 Player 图层，人物就恢复正常了</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/43099fd6b674481abab6aebe7a902607.jpg" alt="19.jpg" style="zoom:80%;" /><img src="https://p9.toutiaoimg.com/origin/pgc-image/cd173ce71bc44957a77546101663df92.jpg" alt="20.jpg" style="zoom:80%;" /><p>​    因为这样设置就代表着人物在被其它物体遮挡了会应用透明化的材质（第一个 CharcterBehind Render Object），在没有被遮挡的情况下就什么都不变（第二个 CharcterInFront Render Object）</p><p>​    到这里，我们就完成了剔除人物遮挡效果啦！</p>]]></content>
      
      
      <categories>
          
          <category> Unity学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity笔记4--设置人物的动画</title>
      <link href="UnityNotes/Unity%E7%AC%94%E8%AE%B04-%E8%AE%BE%E7%BD%AE%E4%BA%BA%E7%89%A9%E7%9A%84%E5%8A%A8%E7%94%BB/"/>
      <url>UnityNotes/Unity%E7%AC%94%E8%AE%B04-%E8%AE%BE%E7%BD%AE%E4%BA%BA%E7%89%A9%E7%9A%84%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<p>​    在前面两个章节我们成功地让我们的人物在地图上走了起来，但是我们发现小人的动作是素材下载下来时默认的状态，需要我们来进行调整，那么这一章节就来修改一下小人的动作吧！</p><h1 id="查看素材小人自带的动作动画"><a href="#查看素材小人自带的动作动画" class="headerlink" title="查看素材小人自带的动作动画"></a>查看素材小人自带的动作动画</h1><p>​    我们之前下载下来的人物是有自带的动作的，我们先来查看一下它们是怎样的</p><p>​    打开如下目录（ <strong>Assets Packs —&gt; DogKnight —&gt; Animations</strong> ），找到图片中的这些文件，这一些文件就是我们小人自带的动作了，而在右边有个小窗口可以预览播放动作动画，但是我们发现预览窗口中的人是紫色的，怎样可以调成我们人物的样例呢？</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/d855bb2c3cb24ba0b1e5b351658616e1.jpg" alt="1.jpg" style="zoom:80%;" /><p>​        我们只需要点一下预览窗口上方一个按钮就可以导入一个人物样例用在这个动画上了</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/994679f9c4704258b10a25ab51ad1273.jpg" alt="2.jpg" style="zoom:80%;" /><p>​    点击绿色小人按钮，然后选择 **Other…**，我们就可以在新出来的窗口 <strong>Select GameObject</strong> 中选择我们要用的样例了，这里我选择的是 DogPBR ，也就是我们游戏中要用到的小狗</p><p>​    知道了动作动画在哪里以及怎么预览动作之后，我们就可以着手来实现更改角色的动作了</p><h1 id="使用动作控制器修改人物动作"><a href="#使用动作控制器修改人物动作" class="headerlink" title="使用动作控制器修改人物动作"></a>使用动作控制器修改人物动作</h1><p>​    首先我们新建一个目录来专门存放一个动作控制器文件的文件夹，可以参考下图目录</p><img src="https://p3.toutiaoimg.com/origin/pgc-image/2d3c92a24b084da1825b3632a043a377.jpg" alt="3.jpg" style="zoom:80%;" /><p>​    <strong>Animators</strong> 文件夹中我们右键 <strong>Create</strong> 一个 <strong>Animator Controller</strong> 文件，并可以将它命名为 Player ，这个文件就是用来控制我们人物动作的控制器文件</p><img src="https://p26.toutiaoimg.com/origin/pgc-image/805493fbe75d4f3db98752c50dde6af4.jpg" alt="4.jpg" style="zoom:80%;" /><p>​    新建好动作控制器文件后，我们双击打开它，可以看到如下图一个默认的界面</p><img src="https://p5.toutiaoimg.com/origin/pgc-image/b9f85f9d22ab4bae8e8d5b7eec6983ec.jpg" alt="5.jpg" style="zoom:80%;" /><p>​    我们在中间视图右键然后新建一个 <strong>Blend Tree</strong> （即混合树，用来解决多个动画之间的混合，经常用于移动动画之间的混合），新建好后命名为：Locomotion，并双击打开这个 Blend Tree</p><img src="https://p3.toutiaoimg.com/origin/pgc-image/7922cd39288d461b8746c05bd0e315b2.jpg" alt="6.jpg" style="zoom:80%;" /><p>​    打开后我们首先要做的事就是把左上方 <strong>Parameters（参数）</strong> 选项卡中默认的 Blend 参数删除，并自己新建一个 **Float 类型 **的参数，这个参数是用来参考要哪一个数值来切换我们的动作，这里理所应当是看移动时人物的速度是多少从而来切换不同的动作，因此我们这个 Float 类型的参数就命名为 <strong>“ Speed ”</strong>，到时候我们在代码中就要用到这个值</p><p>​    了解参数之后，我们右键中间的 Blend Tree ，选择 <strong>Add Motion</strong> 添加动作，这里我们可以考虑一下总共要多少个动作：一个是人物没有移动的时候是 <strong>站立不动</strong>，一个是移动速度较慢，属于 <strong>慢走状态</strong>，还有一个速度较快，变为了 <strong>快跑</strong>，这样我们就有了三个动作。因此在这里就要添加三次 Motion 了</p><p>​    <img src="https://p6.toutiaoimg.com/origin/pgc-image/f5ad228bf45040e393dd2e88d27c040a.jpg" alt="7.jpg" style="zoom:80%;" /></p><p>​    添加好 Motion 后我们在右边的 Inspector 视图中便可以看到多了三个空的 Motion ，这个时候要注意<u>先把 Parameter（参数）选择为刚刚创建的 Speed</u> 先，然后就分别把 站立、行走、奔跑 三个动作拖入到三个空 Motion 框中（动作在文章前面可以找到路径），完成后如下图所示</p><img src="https://p5.toutiaoimg.com/origin/pgc-image/58ff789af1ab4b3eb11464c2de7469df.jpg" alt="8.jpg" style="zoom:80%;" /><p>​    弄好上面这些东西后，剩下的就要交给代码来解决了，也是我们应用 Speed 参数的时候了，这次的代码打在了之前创建过的 <strong>PlayerController</strong> 代码文件中，下面贴出这次要用到的代码👇👇👇</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">using</span> <span class="token namespace">UnityEngine</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PlayerController</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MonoBehaviour</span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">NavMeshAgent</span> agent<span class="token punctuation">;</span><span class="token comment">//导航控制，之前用到的</span>    <span class="token keyword">private</span> <span class="token class-name">Animator</span> animator<span class="token punctuation">;</span><span class="token comment">//动作控制</span>        <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Awake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//获取当前组件并赋值给上面声明的变量</span>         agent <span class="token operator">=</span> <span class="token generic-method"><span class="token function">GetComponent</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>NavMeshAgent<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>animator<span class="token operator">=</span><span class="token generic-method"><span class="token function">GetComponent</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>Animator<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//实时更新动作动画</span><span class="token function">SwitchPlyerAnimation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SwitchPlyerAnimation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//切换人物角色的动作动画</span><span class="token comment">//弄好后整个函数放进Update里</span>        animator<span class="token punctuation">.</span><span class="token function">SetFloat</span><span class="token punctuation">(</span><span class="token string">"Speed"</span><span class="token punctuation">,</span>agent<span class="token punctuation">.</span>velocity<span class="token punctuation">.</span>sqrMagnitude<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置一个Float值，参数2为要设置的值</span>        <span class="token comment">//API解释</span>                <span class="token comment">//velocity -- 获取 NavMeshAgent 组件的当前速度，或者设置一个速度来手动控制代理。</span>        <span class="token comment">//API网址：https://docs.unity.cn/cn/2020.3/ScriptReference/AI.NavMeshAgent-velocity.html</span>                <span class="token comment">//sqrMagnitude -- 属于 Vector3 的方法，返回这个向量的长度的平方（只读），计算长度的平方而不是magnitude是非常快的</span>        <span class="token comment">//API网址：http://docs.manew.com/Script/Vector3.sqrMagnitude.html</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    打完代码后，再把 Animator Controller 文件 <strong>Player</strong> 拖到人物属性面板中的 <strong>Animator — Controller</strong> 框框中就大功告成啦！进入游戏看看你的人物是否在移动时会变换指定的动作吧！</p><img src="https://p9.toutiaoimg.com/origin/pgc-image/5b9d38d06a01422394b2959ab214244c.jpg" alt="9.jpg" style="zoom:80%;" />]]></content>
      
      
      <categories>
          
          <category> Unity学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity笔记3--摄像机跟踪处理</title>
      <link href="UnityNotes/Unity%E7%AC%94%E8%AE%B03-%E6%91%84%E5%83%8F%E6%9C%BA%E8%B7%9F%E8%B8%AA%E5%A4%84%E7%90%86/"/>
      <url>UnityNotes/Unity%E7%AC%94%E8%AE%B03-%E6%91%84%E5%83%8F%E6%9C%BA%E8%B7%9F%E8%B8%AA%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>​    在上一章节，我们第一次在Unity上使用代码来实现了我们人物的移动。但是我们发现镜头并不会跟着人物移动，因此在这一章节我们就来实现如何让摄像机跟着我们小人走。</p><p>​    同样我们也要安装一个插件，叫做 <strong>Cinemachine</strong> ，安装完后我们可以在Unity界面上方的菜单栏看见它的功能条</p><img src="https://p6.toutiaoimg.com/origin/pgc-image/2edd56f142984d5ca500ad9372783225.jpg" alt="1.jpg" style="zoom: 67%;" /><img src="https://p6.toutiaoimg.com/origin/pgc-image/a9788d8d88904631b6965ad7b0f5b286.jpg" alt="2.jpg" style="zoom:80%;" /><center>首先安装好Cinemachine</center><p>​    在这里我们用到的选项是第一个，先选中我们的主摄像机 Main Camera（我这里对主摄像机的命名），在菜单栏中找到 <strong>GameObject—&gt;Align View to Selected</strong>（这一步操作是把我们的视角调到和摄像机的视角一样的角度），然后再在刚刚的 <strong>Cinemachine</strong> 菜单栏中点击<strong>创建一个 Virtual Camera</strong> </p><img src="https://p9.toutiaoimg.com/origin/pgc-image/a2106f307e6d4818b7bfa9ade25435ad.jpg" alt="3.jpg" style="zoom: 75%;" /><p>​    创建好后，我们的 Virtual Camera（虚拟摄像机） 就会顶替了我们的主摄像机，我们找到刚刚创建好的虚拟摄像机对象，在属性栏中进行一些调整：</p><p>​    1）首先在 Body 选择为 <strong>Framing Transposer</strong> ，这样相机就会跟随着我们人物了，这里简单介绍一些其他几个选项的作用</p><img src="https://p26.toutiaoimg.com/origin/pgc-image/f9ab6d9da189491187c26eb6b7f47249.jpg" alt="4.jpg" style="zoom:80%;" /><ul><li><p>Do Nothing：不移动虚拟相机 </p></li><li><p>Framing Transposer：跟随目标移动，并在屏幕空间保持相机和跟随目标的相对位置。 </p></li><li><p>Hard Lock to Target：虚拟相机和跟随目标使用相同位置。</p></li><li><p> Orbital Transposer：相机和跟随目标的相对位置是可变的，还能接收用户的输入。常见于玩家控制的相机。</p></li><li><p> Tracked Dolly：相机沿着预先设置的轨道移动。 </p></li><li><p>Transposer：跟随目标移动，并在世界空间保持相机和跟随目标的相对位置固定。</p><p>2）在 Aim 选项中选择 <strong>Do Nothing</strong> （这里对其它几个选项感兴趣的可以自己去试一下，选择POV的时候视野会跟着鼠标转动，一般可用于第一人称的游戏）</p><img src="https://p26.toutiaoimg.com/origin/pgc-image/2d597d7729c044f4a771b53cde8b0077.jpg" alt="5.jpg" style="zoom:80%;" /><p>3）将你的人物对象拖入 Follow 的框框中（这里其实本质是相机跟随一个像素点，如果想调整跟随的点可以自己调整，也可以新建一个人物子类Empty对象，然后调整这个空对象的位置，再让相机跟随这个对象）</p><img src="https://p5.toutiaoimg.com/origin/pgc-image/edb5d7890a4441ff965a759adb6de889.jpg" alt="6.jpg" style="zoom:80%;" /></li></ul><p>​    到这里，你的摄像机就会跟随着人物移动而转变视角了，当然还可以更进一步，调整一下缓冲区域（就是让相机不要跟随着太紧，让人物走那么一点点距离再相机跟随）：我们可以通过调整下图几个参数而调整，预览屏幕的框框可以看到你的缓冲区大小</p><img src="https://p3.toutiaoimg.com/origin/pgc-image/b17d8f6eca6e4c1494f6b28ede1ecec3.jpg" alt="7.jpg" style="zoom:80%;" /><img src="https://p5.toutiaoimg.com/origin/pgc-image/4242f83084d54044bdb5ecedf8ad588a.jpg" alt="8.jpg" style="zoom:80%;" /><p>​    当然感兴趣的话还可以去查找更多的设置方法去调整你的摄像机，从而让你的视野移动更完美。</p>]]></content>
      
      
      <categories>
          
          <category> Unity学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity笔记2--智能导航的烘焙和鼠标控制人物移动</title>
      <link href="UnityNotes/Unity%E7%AC%94%E8%AE%B02-%E6%99%BA%E8%83%BD%E5%AF%BC%E8%88%AA%E7%9A%84%E7%83%98%E7%84%99%E5%92%8C%E9%BC%A0%E6%A0%87%E6%8E%A7%E5%88%B6%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8/"/>
      <url>UnityNotes/Unity%E7%AC%94%E8%AE%B02-%E6%99%BA%E8%83%BD%E5%AF%BC%E8%88%AA%E7%9A%84%E7%83%98%E7%84%99%E5%92%8C%E9%BC%A0%E6%A0%87%E6%8E%A7%E5%88%B6%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>​    这一次我们来实现人物在地图上走动，在实现之前我们有一些准备工作要做，首先就是我们的地图烘焙了。</p><h1 id="智能导航地图的烘焙"><a href="#智能导航地图的烘焙" class="headerlink" title="智能导航地图的烘焙"></a>智能导航地图的烘焙</h1><p>​    地图的烘焙就是标记我们场景哪些区域是可以供人物移动的，而哪一些是障碍物或不可走区域，只有规划好了之后我们才可以更好的去实现人物移动，不然可以想一下因为一些粗心失误使得一些障碍物没有设置成功，从而导致人物移动穿模了就不妙了。</p><p>​    那么我们来开始吧！</p><p>​    首先还是要安装一个插件叫做 — <strong>Navigation</strong> ，安装步骤就不再过多介绍了</p><p>​    安装好了之后我们打开界面如下图，我们来看一下怎么烘焙吧</p><img src="https://p6-tt.byteimg.com/origin/pgc-image/148f5c914e914e808596ffa68e51d87d.jpg" alt="1.jpg" style="zoom: 80%;" /><p>​    </p><p>​    首先我们在场景中<strong>选择一个地面</strong>，然后再在 Navigation 插件里点击 <strong>Object选项卡</strong>，可以有个 <strong>Navigation Static</strong> 的选项，我们把这个选项 ✅ 勾上，因为只有设为 static 之后才可以进行烘焙。</p><p>​    ⚠有时候选择了 static 之后会弹出一个对话框，询问是否将该对象所包含的子对象（例如在地板对象中还包含了树木和石头等对象）都设为 static ，这个我们看自己情况选择。</p><p>​    选择 static 后，下面的 <strong>Navigation Area</strong> 就可以选择当前区域为可移动还是不可移动区域了</p><img src="https://p5-tt.byteimg.com/origin/pgc-image/4074b3afad1f40a1b0fc3ea55c186842.jpg" alt="2.jpg" style="zoom:80%;" /><p>​    回到 Bake 选项卡，我们看到可以设置地面在哪些情况下可以走，如 <strong>Max Slope</strong> 代表着可行坡度，就好像我所调的35°，这代表着我们小人最多可以走35角度的坡，如果大于35°的话我们小人是无法到达的</p><p>​    而图中的蓝色圆柱体以代表着你的人物身高和半径，我们修改这些属性也会影响到我们地图上可行区域</p><img src="https://p6-tt.byteimg.com/origin/pgc-image/1400e1a2f3784cb2ac84e3f87c22a959.jpg" alt="3.jpg" style="zoom:80%;" /><p>​    设置完这一切之后我们就可以点击下方的 <strong>Bake</strong> 按钮来烘焙啦，我们也可以在地图上看到颜色的变化，有颜色标记的区域是可以走的，而没有颜色则代表是无法到达的区域</p><p>​    </p><p>​    除了像上面那样直接使用 Navigation 插件进行障碍物等设置方法，我们还可以直接在物件的 <strong>Inspector</strong> 视图中添加一个 <strong>Navigation</strong> 的 <strong>Component</strong></p><p>​                             <img src="https://p6-tt.byteimg.com/origin/pgc-image/290b93d207ca4b5386932a8dcbef0407.jpg" alt="4.jpg" style="zoom:80%;" />                    <img src="https://p26-tt.byteimg.com/origin/pgc-image/e250b8ffcaf84d4f9eb2ef4e009069be.jpg" alt="5.jpg" style="zoom:80%;" /></p><p>​    添加完之后我们可以设置是可移动区域还是障碍区域，最后再进行 <strong>Bake</strong> ，用这种方式实现的地图烘焙有一个优点就是在你移动物体时，所设置的可行或不可行区域也会跟随物体移动，例如：我设置了一个石头为障碍物，在我移动石头时，该障碍物区域也会跟随着移动。</p><p>​    不止地面可以烘焙，我们地面上的树木石头都可以烘焙，具体操作也是先选中这些对象（鉴于可能物体较多，我们可以在Hierarchy视图上多选），然后设为 static ，再接着设置圆柱体范围等可行区域最后再烘焙就大功告成啦</p><h1 id="实现鼠标控制人物移动"><a href="#实现鼠标控制人物移动" class="headerlink" title="实现鼠标控制人物移动"></a>实现鼠标控制人物移动</h1><p>​    在烘焙好地图区域后，我们就可以着手来实现鼠标控制人物移动啦</p><p>​    因为这部分需要涉及到打代码，我们新建一个 <strong>Scripts</strong> 文件夹专门存放我们的代码</p><p>​    新建一个 <strong>C#</strong> 代码文件，一个 <strong>Unity Empty对象</strong>，把它们都命名为 <strong>MouseManager</strong> ，并把代码文件拖拽到 Unity Empty对象中</p><p>​               <img src="https://p3-tt.byteimg.com/origin/pgc-image/21776254d90d48bca1cf31c28f6c402e.jpg" alt="6.jpg" style="zoom:80%;" />                                        <img src="https://p5-tt.byteimg.com/origin/pgc-image/b54f60e1cb4146ff84a3922d31e64f57.jpg" alt="7.jpg" style="zoom:80%;" /></p><p>​    接下来就是编写代码了，由于这里展示的是单例模式，我们还要新建一个名为： <strong>PlayerController</strong> 的C#文件拖拽到要控制的人物上，下面分别是两个C#文件的代码</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token comment">//MouseManager.cs</span><span class="token comment">//这里只展示重要的部分并附上注释</span><span class="token keyword">using</span> <span class="token namespace">UnityEngine</span><span class="token punctuation">;</span><span class="token comment">//for Vector3,RaycastHit,Ray</span><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span><span class="token comment">//for Action</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MouseManager</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MonoBehaviour</span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">event</span> <span class="token class-name">Action<span class="token punctuation">&lt;</span>Vector3<span class="token punctuation">></span></span> OnMouseClicked<span class="token punctuation">;</span><span class="token comment">//声明一个事件，用于当鼠标点击时进行操作</span>    <span class="token class-name">RaycastHit</span> hitInfo<span class="token punctuation">;</span><span class="token comment">//用来存储射线Ray返回的坐标点消息</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">MouseManager</span> Instance<span class="token punctuation">;</span><span class="token comment">//MouseManager类的唯一实例（单例模式用）</span>        <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SetCursorTexture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//发射一条射线，起点是主相机（MainCamera）</span>        <span class="token comment">//射线另一端点则是鼠标点击的坐标（Input.mousePosition）</span>        <span class="token class-name">Ray</span> ray <span class="token operator">=</span> Camera<span class="token punctuation">.</span>main<span class="token punctuation">.</span><span class="token function">ScreenPointToRay</span><span class="token punctuation">(</span>Input<span class="token punctuation">.</span>mousePosition<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>Physics<span class="token punctuation">.</span><span class="token function">Raycast</span><span class="token punctuation">(</span>ray<span class="token punctuation">,</span><span class="token keyword">out</span> hitInfo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//上面的Raycast函数里将射线点信息返回到了out属性的hitInfo变量里</span>            <span class="token comment">//TODO</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>             <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">MouseControl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         <span class="token comment">//如果鼠标点击了一个地方并且hitInfo坐标点不为空的话</span><span class="token keyword">if</span><span class="token punctuation">(</span>Input<span class="token punctuation">.</span><span class="token function">GetMouseButtonDown</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> hitInfo<span class="token punctuation">.</span>collider <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//所点击的物体标签是“Ground”（地面）的话，（注意要把你的地面添加为Ground标签）</span><span class="token keyword">if</span><span class="token punctuation">(</span>hitInfo<span class="token punctuation">.</span>collider<span class="token punctuation">.</span><span class="token function">CompareTag</span><span class="token punctuation">(</span><span class="token string">"Ground"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">//判断OnMouseClicked事件是否为空，不为空的话则传递坐标点</span>OnMouseClicked<span class="token punctuation">?.</span><span class="token function">Invoke</span><span class="token punctuation">(</span>hitInfo<span class="token punctuation">.</span>point<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//DeBug Info</span><span class="token class-name">Vector3</span> point <span class="token operator">=</span> hitInfo<span class="token punctuation">.</span>point<span class="token punctuation">;</span>Debug<span class="token punctuation">.</span><span class="token function">LogFormat</span><span class="token punctuation">(</span><span class="token string">"鼠标左键单击了&#123;0&#125;! X:&#123;1&#125;,Y:&#123;2&#125;,Z:&#123;3&#125;"</span><span class="token punctuation">,</span>hitInfo<span class="token punctuation">.</span>collider<span class="token punctuation">.</span>name<span class="token punctuation">,</span>point<span class="token punctuation">.</span>x<span class="token punctuation">,</span>point<span class="token punctuation">.</span>y<span class="token punctuation">,</span>point<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Debug显示鼠标点击的坐标</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>        <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Awake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">//在Unity的脚本C#代码文件中，Awake()是在脚本对象实例化时被调用的，也就是在这个类被创建的时候就进行操作</span><span class="token keyword">if</span><span class="token punctuation">(</span>Instance <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">Destroy</span><span class="token punctuation">(</span>gameObject<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Instance <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>        <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//将上面两个主要的函数放进Update里</span><span class="token function">SetCursorTexture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">MouseControl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//class MouseManager</span><span class="token comment">//PlayerController.cs</span><span class="token comment">//把这个文件拖入到你要控制的人物中</span><span class="token keyword">using</span> <span class="token namespace">UnityEngine</span><span class="token punctuation">;</span><span class="token comment">//for Component.GetComponent&lt;></span><span class="token keyword">using</span> <span class="token namespace">UnityEngine<span class="token punctuation">.</span>AI</span><span class="token punctuation">;</span><span class="token comment">//for CLASS NavMeshAgent;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PlayerController</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MonoBehaviour</span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">NavMeshAgent</span> agent<span class="token punctuation">;</span><span class="token comment">//导航控制</span>        <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Awake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//GetComponent为获取组件</span>        <span class="token comment">//我们在人物添加过一个NavMeshAgent的Component，这里获取的就是它</span>        agent <span class="token operator">=</span> <span class="token generic-method"><span class="token function">GetComponent</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>NavMeshAgent<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">MoveToTarget</span><span class="token punctuation">(</span><span class="token class-name">Vector3</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//从事件中获得的坐标点赋值给人物移动的目标点</span>agent<span class="token punctuation">.</span>destination <span class="token operator">=</span> target<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>        <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//将函数方法注册到事件中</span>MouseManager<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>OnMouseClicked<span class="token operator">+=</span>MoveToTarget<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    到此，人物移动的核心部分就实现了，快去实验一下你的小人能不能移动吧！</p>]]></content>
      
      
      <categories>
          
          <category> Unity学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity笔记1--熟悉Unity界面以及构建场景</title>
      <link href="UnityNotes/Unity%E7%AC%94%E8%AE%B01-%E7%86%9F%E6%82%89Unity%E7%95%8C%E9%9D%A2%E4%BB%A5%E5%8F%8A%E6%9E%84%E5%BB%BA%E5%9C%BA%E6%99%AF/"/>
      <url>UnityNotes/Unity%E7%AC%94%E8%AE%B01-%E7%86%9F%E6%82%89Unity%E7%95%8C%E9%9D%A2%E4%BB%A5%E5%8F%8A%E6%9E%84%E5%BB%BA%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="熟悉Unity界面"><a href="#熟悉Unity界面" class="headerlink" title="熟悉Unity界面"></a>熟悉Unity界面</h1><p>​    首先在开始之前说一下我所使用的Unity版本，我目前所安装的Unity是2020.3版本，具体版本号如下图所示：</p><p><img src="https://p6-tt.byteimg.com/origin/pgc-image/39050d7c97954612bc110e85d4b0d84e.jpg" alt="1.jpg"></p><p>​    同时这个版本也是稳定版本（LTS）</p><p>​    安装完Unity，我们就要开始创建项目，这里我们直接创建一个普通3D项目，项目名为：3DRPG ，进去之后我们按自己喜好调整一下界面布局，具体每个界面的作用这里作简单的介绍，随着我们不断推进项目我们也可以比较快地熟悉各个窗口的作用。</p><p><img src="https://p5-tt.byteimg.com/origin/pgc-image/aa00a709e4fe479aa99a5b3040a5a298.jpg" alt="2.jpg"></p><p>​    👆我们来看一下上面的图，这个界面是我在进行了几个章节之后截的图，一般我们都有几个主要的窗口界面：</p><ul><li><p><strong>Scene</strong>  这个是我们Unity的可视化场景管理窗口，简单来说就是我们可以直接将我们的人物、小物件等东西在Scene窗口上进行操作，这可以极大的方便我们进行场景的布置工作。</p></li><li><p><strong>Hierarchy</strong> 也就是上图靠中间上边的视图，在这个视图中我们可以看到在Scene视图中摆放了哪些物件对象，包括你的小人，花草树木甚至你的Camera(摄像机🎥)和光照对象都会在Hierarchy视图上显示出来。</p></li><li><p><strong>Project</strong> 这个视图里我们可以管理当前项目的文档文件，比如C#代码文件或其它配置文件等都可以在这里直接访问。</p></li><li><p><strong>Inspector</strong> 在这个视图里我们可以查看并修改当前选中对象的属性值，例如我可以在Scene视图或Hierarchy视图选中我的小人，然后修改它的高度、位置等等许多属性。</p></li><li><p><strong>Console</strong> 还有一个视图就是我们的输出控制台啦，在这个控制台里我们可以查看代码错误或者代码输出等信息，在往后我们的C#代码文件中可以利用Debug来输出特定的信息👉👉👉<code>Debug.LogFormat(&quot;调试信息&#123;0&#125;&quot;,xxxx);</code></p><h1 id="安装URP渲染管线"><a href="#安装URP渲染管线" class="headerlink" title="安装URP渲染管线"></a>安装URP渲染管线</h1><p>​    熟悉完界面后，我们就可以开始安装<strong>URP(Universal Render Pipeline)渲染管线</strong>了，首先我们在上边的菜单栏找到Window–Package Manager </p><img src="https://p6-tt.byteimg.com/origin/pgc-image/63fdcf0caf734225823ae387e05ea777.jpg" alt="3.jpg" style="zoom: 67%;" /><p>​    在 Package Manager 中我们可以管理当前项目使用的Unity插件，以后也会经常用到，之后在Package Manager 窗口中左上角我们选择 Pcakages 为<strong>Unity Registry</strong>，随后在右上角搜索<em>Universal RP</em>找到我们要的URP渲染管线并点击安装</p><img src="https://p9-tt.byteimg.com/origin/pgc-image/0c5d7ad152214e88b346851f86c86726.jpg" alt="4.jpg" style="zoom:67%;" /><p>​    我这里安装的URP版本号为 10.4.0 ，该版本已经在Unity 2020.3 中得到了认证。</p><p>​    安装完后我们就要开始配置工作了，首先我们在Project视图点那个+号，然后找到 Rendering -&gt; Universal Render Pipeline -&gt; Pipeline Asset (Forward Renderer) ，如下图👇</p><img src="https://p9-tt.byteimg.com/origin/pgc-image/d659c489af584a5ca3c337957af35a19.jpg" alt="5.jpg" style="zoom:67%;" /><p>​    点击之后我们看到Unity为我们创建了两个文件（下图的第二第三个），当然为了以后更好的管理各种杂七杂八的文件，我们要养成分类的好习惯，所以我们弄个文件夹把它们放在一起，这里我文件夹起名 Pipeline Setting</p><img src="https://p3-tt.byteimg.com/origin/pgc-image/fd12dcde3ace40bf9a60e5db6307675a.jpg" alt="6.jpg" style="zoom: 67%;" /><p>​    下一步我们打开菜单栏中的 Edit—ProjectSettings…</p><img src="https://p5-tt.byteimg.com/origin/pgc-image/35de350f60d04bf7a21461765e3c9f11.jpg" alt="7.jpg" style="zoom: 60%;" /><p>​    在新打开的窗口中我们可以对我们当前的项目进行一些设置操作，这里我们要设置默认的渲染管线为刚刚创建的URP渲染管线，我们分别在左侧栏中选择 Graphics 和 Quality ，再按照下图标蓝色框位置选择我们的URP渲染管线</p><img src="https://p6-tt.byteimg.com/origin/pgc-image/5dac041ae0e14100a36c7ed5e7fa1991.jpg" alt="8.jpg" style="zoom:70%;" /><center>Graphics界面设置URP</center><img src="https://p6-tt.byteimg.com/origin/pgc-image/78eb8e07811a40a08c3f1e084e204cbc.jpg" alt="9.jpg" style="zoom:70%;" /></li></ul><center>Quality界面设置URP</center><p>​    至此，我们的URP渲染管线安装配置就暂时到这了，接下来我们便可以开始导入素材测试渲染效果了。</p><h1 id="导入素材并构建场景"><a href="#导入素材并构建场景" class="headerlink" title="导入素材并构建场景"></a>导入素材并构建场景</h1><h2 id="使用Unity素材商店导入素材"><a href="#使用Unity素材商店导入素材" class="headerlink" title="使用Unity素材商店导入素材"></a>使用Unity素材商店导入素材</h2><p>​    我们可以通过Unity自带的官方商店里面寻找我们喜欢的素材，我们可以点击这个<a href="https://assetstore.unity.com/">链接</a>进入素材商店，也可以在Unity内的 Window—Asset Store 内打开</p><img src="https://p5-tt.byteimg.com/origin/pgc-image/150853385a5e42e282a36d8e1e651371.jpg" alt="10.jpg" style="zoom:60%;" /><p>​    值得注意的是，从Unity2020版开始取消了内置商店的窗口，如果你是2020版或之后的版本的话，打开Asset Store会得到一个无法访问的界面，我们需要再点击 Search Online 按钮按钮来打开网页版商店</p><img src="https://p6-tt.byteimg.com/origin/pgc-image/da99be76548c4ff18c4954eb06ad1d62.jpg" alt="11.jpg" style="zoom:65%;" /><p>​    </p><p>​    我们目前可以先找两个免费素材，如下图所示，一个是场景素材，一个是人物素材，可以供我们前期暂时学习使用了，这里我们点击蓝色的按钮并根据操作添加到你的Unity账户里，就可以在Unity里面下载下来了</p><p><img src="https://p5-tt.byteimg.com/origin/pgc-image/63fc0f40f92a4af181788740c7f975bc.jpg" alt="12.jpg"></p><p>​    在挑选素材时要注意一点就是要看好素材是否支持我们所选择的渲染管线，一般在素材商店界面都会有说明</p><p>​    素材添加到账户之后，我们打开 Package Manager，并在左上角的 Packages 选择为 My Assets，就可以看到在Unity商店添加的素材了，选中素材点击下载并Import就可以添加到项目中啦</p><img src="https://p3-tt.byteimg.com/origin/pgc-image/20d6062a1db34a62a9182d0aa5943889.jpg" alt="13.jpg" style="zoom:70%;" /><p>​    将我们小人拖到Scene视图中，可能会出现小人一身粉色还没渲染外观出来，这时我们就要将素材升级到我们的渲染管线，具体操作是 Edit -&gt; Render Pipeline -&gt; Universal Render Pipeline -&gt; 此时我们可以看到有出来两个选项，第☝个选项是将我们项目里的所以素材都升级为URP；第✌个选项是将当前选中的材质升级为URP，这里我们可以选择第一个。点击升级URP后小人就可以正常显示了</p><img src="https://p5-tt.byteimg.com/origin/pgc-image/29036628920f45c09b47e29ad9a2eaf0.jpg" alt="14.jpg" style="zoom:80%;" /><p>​    </p><h2 id="构建场景"><a href="#构建场景" class="headerlink" title="构建场景"></a>构建场景</h2><p>​    搭建场景部分我们可以先从调整天空样式开始，因为默认的天空样式灰溜溜的并不好看😐，那么我们就开始吧！</p><h3 id="天空"><a href="#天空" class="headerlink" title="天空"></a>天空</h3><p>​    首先调整天空可以先去下个天空盒子（Skybox）素材，这里我下载的是下图所示的Skybox：<a href="https://assetstore.unity.com/packages/vfx/shaders/free-skybox-extended-shader-107400">FREE Skybox Extended Shader</a></p><p><img src="https://p9-tt.byteimg.com/origin/pgc-image/e72308b7966b47368c2cc814dcf5dca4.jpg" alt="15.jpg"></p><p>​    添加好资源后回到Unity内下载并 Import（注意将文件夹分好类），我们可以在素材目录下看到有Demo样例</p><img src="https://p3-tt.byteimg.com/origin/pgc-image/0b812466543d478b9211e068a949438f.jpg" alt="16.jpg" style="zoom:80%;" /><p>​    那么如何来使用这个Skybox呢？</p><p>​    首先我们要在菜单栏打开 Window -&gt; Rendering -&gt; Lighting 窗口</p><img src="https://p6-tt.byteimg.com/origin/pgc-image/448dfc0867b14cea8a884b1da2cd1cc8.jpg" alt="17.jpg" style="zoom:70%;" /><p>​    然后我们在新打开的 Lighting 窗口点击 Environment 选项卡，在Skybox Material 那一栏中就可以选择自己喜欢的Skybox素材了</p><img src="https://p6-tt.byteimg.com/origin/pgc-image/e489644b78364fab8c4b97e49a5f69d3.jpg" alt="18.jpg" style="zoom:80%;" /><p>​    另外，我们在Scene选项卡中可以先点击一下New Lighting Settings按钮来新建一个光照配置文件并将它分类摆好，这个配置文件我们后面可以用来配置场景环境光</p><img src="https://p3-tt.byteimg.com/origin/pgc-image/07234fec87af42b8a7db9fbd227478b5.jpg" alt="19.jpg" style="zoom:80%;" /><p><img src="https://p9-tt.byteimg.com/origin/pgc-image/042dbd7860774728a5a7a00969f383e9.jpg" alt="20.jpg"></p><center>将这个配置文件分类摆在Pipeline Setting文件夹下</center><p>​    </p><p>​    现在我们就把刚刚下载下来的Skybox适用到场景中了，如果想要调整参数的话，我们可以到素材目录下找到刚刚选择的Skybox素材对象，并在 Inspector 视图窗口中调整这些参数</p><img src="https://p26-tt.byteimg.com/origin/pgc-image/e3033b1ee0d947b4b315b4a1c17afbf2.jpg" alt="21.jpg" style="zoom:80%;" /><center>我们可以看到右边的Inspector视图内可以修改Skybox的属性</center><p>​    </p><p>​    至此，天空场景就这样搭建好了，接下来我们来搭建地面的元素吧！</p><h3 id="地面"><a href="#地面" class="headerlink" title="地面"></a>地面</h3><p>​    如果想在Unity中自己来绘制场景地面的话，我们可以利用两个插件 — <strong>Poly Brush</strong> 和 <strong>ProBuilder</strong> 来自己建模。</p><h4 id="Poly-Brush"><a href="#Poly-Brush" class="headerlink" title="Poly Brush"></a>Poly Brush</h4><p>​    我们还是打开 Package Manager，左上角的 Packages 选择为 <strong>Unity Registry</strong> 然后我们在搜索框查找 <strong>Poly Brush</strong> 然后下载下来安装。安装好 Poly Brush 不要着急关闭 Package Manager 窗口，我们还要点开 Samples 导入属于我们URP的 Shader Examples ，即下图中的<strong>第二个选项</strong></p><img src="https://p6-tt.byteimg.com/origin/pgc-image/0a1867154c2045d2ada819d40e319961.jpg" alt="22.jpg" style="zoom:80%;" /><center>如果我们使用URP的话选择的是第二个选项</center><p>​    当然如果你是使用普通的Unity项目而没有使用URP渲染管线的话就选择<strong>第一个选项</strong></p><p>​    安装好后我们的 Project 视图里就会多出了一个 Polybrush 插件的文件夹，由于之后我们还要安装一些插件，所以我们可以新建一个文件夹命名为 <strong>Addons</strong> 来专门存放这些插件的文件（要养成分类的好习惯）</p><p>​    弄好这些东西后，我们回到Unity主界面，我们通过上方菜单栏的 <strong>Tools-&gt;Polybrush-&gt;Polybrush Window</strong> 来打开Polybrush窗口</p><img src="https://p26-tt.byteimg.com/origin/pgc-image/c58b3d98cab54de79fac9e3d9a0eaac6.jpg" alt="23.jpg" style="zoom:80%;" /><center>打开 Polybrush 窗口</center><p>​    打开 Polybrush 窗口后我们了解一下这些按钮的功能</p><img src="https://p6-tt.byteimg.com/origin/pgc-image/d8e4a421ebcb42719f15c86813a7e131.jpg" alt="24.jpg" style="zoom:80%;" /><ul><li><p>第一个按钮是调整地面的高度，选中该按钮然后在地面上拖拽鼠标即可将地面升高，按住 Ctrl 并拖拽鼠标便是下降。我们看到下面面板中还有一些参数供我们调整：</p><p><strong>OuterRadius</strong> 可以选择外角大小</p><p><strong>InnerRadius</strong> 则修改内角大小。按住 shift 键滑动鼠标滚轮可以调整内圈大小，按住 Ctrl 键滑动滚轮调整外圈。</p><p><strong>Strength</strong>可以修改强度</p><p><strong>Direction</strong> 可以选择地形改变的方向，默认为normal，下拉可以进行修改。</p><p><strong>BrushMirroring</strong>可以复制笔刷，沿着选中的的x,y,z镜像同时修改地形</p></li><li><p>第二个按钮是柔化按钮，羽化功能可以将地图较为僵硬的顶点进行柔化</p></li><li><p>第三个按钮是颜色刷，可以使我们很方便地将我们的地板涂上我们想要的颜色</p></li><li><p>第四个按钮是将预设的物体涂到地板上，我们可以在面板中勾选要刷的物体以及密度（即概率）</p></li><li><p>第五个是贴图刷，和预制体刷子的功能一样，它是将一些texture刷到场景中，可以把图片素材可以引用在场景中选中的物体上。</p></li></ul><h4 id="ProBuilder"><a href="#ProBuilder" class="headerlink" title="ProBuilder"></a>ProBuilder</h4><p>​    上面的Poly Brush插件是用来绘制修改地面的，那么我们如何来创建自己的地面呢？这下就要用到我们的另一个插件 — <strong>ProBuilder</strong> 了</p><p>​    同样地，我们通过 Package Manager 来安装此插件，下载下来后同样把插件文件夹分好类，然后打开窗口</p><img src="https://p5-tt.byteimg.com/origin/pgc-image/9e16aa320d6e461a9fc6a22752440486.jpg" alt="25.jpg" style="zoom:80%;" /><center>ProBuilder界面</center><p>​    我们可以按住 <strong>左Shift</strong> 并鼠标指到图形按钮来查看这些按钮的功能，我们看到有些按钮右上角有个小齿轮，这代表着我们可以进一步来设置，只用按住 Alt 并点击他们就可以进一步地来设置，拿第一个按钮（功能是<strong>创建几何体</strong>）来说</p><img src="https://p6-tt.byteimg.com/origin/pgc-image/bacf417b80d14ac18301bb95e8fb9034.jpg" alt="26.jpg" style="zoom:80%;" /><p>​    按住 Alt 并点击第一个按钮我们打开如上图所示的窗口，这里我们可以选择要创建的物体是什么，这里我选择的是 Plane （平面），下面可以设置该几何体的的轴的朝向、宽度、长度以及顶点数（如上图顶点数是30x30）</p><p>​    具体的功能我们可以自己去尝试，配合 Polybrush 我们就可以轻松地来创建我们的场景并绘制他们啦！</p><p>​    要注意的是我们如果要使用 <em>Low Poly</em> 风格的场景的话，我们要设置地图网格呈三角形，这里可以通过上面 ProBuilder 图中的 <strong>第二排第五个</strong> 按钮来实现，选中我们的地面几何体，然后点击该按钮便可以设置成功。</p><p>​    </p><p>​    到这里，我们就可以自己去尝试一下构建属于自己的场景了。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>​    在这一章节中，我们开始第一次接触Unity并尝试了解它，了解如何导入素材并构建、绘制我们的场景，我们只有多去尝试使用这些工具，才可以变得熟悉。所以，我们先可以发挥自己创意来构建一个场景，以便后面来操作吧。</p>]]></content>
      
      
      <categories>
          
          <category> Unity学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我</title>
      <link href="%E8%AE%B0%E4%BA%8B/%E5%85%B3%E4%BA%8E%E6%88%91/"/>
      <url>%E8%AE%B0%E4%BA%8B/%E5%85%B3%E4%BA%8E%E6%88%91/</url>
      
        <content type="html"><![CDATA[<h1 id="关于这个博客的一些事🍥"><a href="#关于这个博客的一些事🍥" class="headerlink" title="关于这个博客的一些事🍥"></a>关于这个博客的一些事🍥</h1><p>​    当初创建这个博客的目的是想着记录自己在大学生活中遇到的一些问题或者学习笔记等，平时也看了不少别人的个人博客，于是心血来潮就想自己也创一个属于自己的个人博客。</p><p>​    刚开始我便去查找有什么博客平台，因为我喜欢自己自定义界面的方式，便找到了可以利用GitHub来做一个博客方式，即：<a href="https://hexo.io/zh-cn/">hexo</a> 。之后我便跟着教程开始搭建，也发现了一些很好看的主题，我现在用的这个主题是<a href="https://butterfly.js.org/">butterfly</a>（<a href="https://github.com/jerryc127/hexo-theme-butterfly/tree/dev">GitHub地址</a>）。之后研究美化界面又花了好一些时间，不过在弄这些东西的时候我都觉得很满足，看着属于自己的博客慢慢开始搭建起来，一股成就感就上来了，而且在其中也接触到了许多之前没有遇到过的知识。</p><p>​    弄好博客的基本框架后，才是真正的开始，希望有一个博客之后，能够对我自己有更好的帮助，可以更好地去总结知识点，也希望可以分享一些知识给观看博客的你😀。</p><h1 id="关于我的一些事"><a href="#关于我的一些事" class="headerlink" title="关于我的一些事"></a>关于我的一些事</h1><p>​    待更新…….💨</p>]]></content>
      
      
      <categories>
          
          <category> 记事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记事 </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
